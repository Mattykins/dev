{
  "version": 3,
  "sources": ["../../../../phaser-genesis/src/config/const.ts", "../../../../phaser-genesis/src/config/ConfigStore.ts", "../../../../phaser-genesis/src/config/backgroundcolor/SetBackgroundColor.ts", "../../../../phaser-genesis/src/config/backgroundcolor/BackgroundColor.ts", "../../../../phaser-genesis/src/config/banner/SetBanner.ts", "../../../../phaser-genesis/src/config/batchsize/SetBatchSize.ts", "../../../../phaser-genesis/src/config/batchsize/BatchSize.ts", "../../../../phaser-genesis/src/renderer/BindingQueue.ts", "../../../../phaser-genesis/src/config/backgroundcolor/GetBackgroundColor.ts", "../../../../phaser-genesis/src/config/size/GetHeight.ts", "../../../../phaser-genesis/src/config/size/GetResolution.ts", "../../../../phaser-genesis/src/config/size/GetWidth.ts", "../../../../phaser-genesis/src/config/renderer/SetRenderer.ts", "../../../../phaser-genesis/src/config/defaultorigin/SetDefaultOrigin.ts", "../../../../phaser-genesis/src/config/globalvar/SetGlobalVar.ts", "../../../../phaser-genesis/src/config/globalvar/GlobalVar.ts", "../../../../phaser-genesis/src/config/maxtextures/SetMaxTextures.ts", "../../../../phaser-genesis/src/dom/GetElement.ts", "../../../../phaser-genesis/src/config/parent/SetParent.ts", "../../../../phaser-genesis/src/config/parent/Parent.ts", "../../../../phaser-genesis/src/config/scenes/SetScenes.ts", "../../../../phaser-genesis/src/config/scenes/Scenes.ts", "../../../../phaser-genesis/src/config/size/SetSize.ts", "../../../../phaser-genesis/src/renderer/webgl1/GL.ts", "../../../../phaser-genesis/src/renderer/webgl1/renderpass/Draw.ts", "../../../../phaser-genesis/src/renderer/webgl1/renderpass/Flush.ts", "../../../../phaser-genesis/src/renderer/webgl1/renderpass/End.ts", "../../../../phaser-genesis/src/renderer/webgl1/textures/GetCompressedTextures.ts", "../../../../phaser-genesis/src/renderer/webgl1/colors/GetRGBArray.ts", "../../../../phaser-genesis/src/config/webglcontext/GetWebGLContext.ts", "../../../../phaser-genesis/src/renderer/webgl1/fbo/CreateFramebuffer.ts", "../../../../phaser-genesis/src/renderer/webgl1/textures/CreateGLTexture.ts", "../../../../phaser-genesis/src/renderer/webgl1/fbo/DeleteFramebuffer.ts", "../../../../phaser-genesis/src/renderer/webgl1/textures/DeleteGLTexture.ts", "../../../../phaser-genesis/src/math/pow2/IsSizePowerOfTwo.ts", "../../../../phaser-genesis/src/renderer/webgl1/textures/SetGLTextureFilterMode.ts", "../../../../phaser-genesis/src/renderer/webgl1/textures/UpdateGLTexture.ts", "../../../../phaser-genesis/src/renderer/webgl1/textures/GLTextureBinding.ts", "../../../../phaser-genesis/src/renderer/webgl1/renderpass/ProcessBindingQueue.ts", "../../../../phaser-genesis/src/colormatrix/const.ts", "../../../../phaser-genesis/src/renderer/webgl1/renderpass/BlendModeStack.ts", "../../../../phaser-genesis/src/components/color/CompareColorMatrix.ts", "../../../../phaser-genesis/src/renderer/webgl1/renderpass/ColorMatrixStack.ts", "../../../../phaser-genesis/src/renderer/webgl1/renderpass/FramebufferStack.ts", "../../../../phaser-genesis/src/config/batchsize/GetBatchSize.ts", "../../../../phaser-genesis/src/config/maxtextures/GetMaxTextures.ts", "../../../../phaser-genesis/src/math/mat4/Mat4Ortho.ts", "../../../../phaser-genesis/src/renderer/webgl1/glsl/MULTI_QUAD_FRAG.ts", "../../../../phaser-genesis/src/renderer/webgl1/shaders/DefaultQuadAttributes.ts", "../../../../phaser-genesis/src/renderer/webgl1/GL_CONST.ts", "../../../../phaser-genesis/src/renderer/webgl1/shaders/CreateAttributes.ts", "../../../../phaser-genesis/src/renderer/webgl1/fbo/CreateDepthBuffer.ts", "../../../../phaser-genesis/src/renderer/webgl1/shaders/DeleteShaders.ts", "../../../../phaser-genesis/src/renderer/webgl1/shaders/CreateProgram.ts", "../../../../phaser-genesis/src/renderer/webgl1/shaders/CreateShader.ts", "../../../../phaser-genesis/src/renderer/webgl1/shaders/CreateUniformSetter.ts", "../../../../phaser-genesis/src/renderer/webgl1/shaders/CreateUniforms.ts", "../../../../phaser-genesis/src/renderer/webgl1/shaders/DefaultQuadUniforms.ts", "../../../../phaser-genesis/src/renderer/webgl1/glsl/SINGLE_QUAD_FRAG.ts", "../../../../phaser-genesis/src/renderer/webgl1/glsl/SINGLE_QUAD_VERT.ts", "../../../../phaser-genesis/node_modules/bitecs/src/Storage.js", "../../../../phaser-genesis/node_modules/bitecs/src/Util.js", "../../../../phaser-genesis/node_modules/bitecs/src/Serialize.js", "../../../../phaser-genesis/node_modules/bitecs/src/Entity.js", "../../../../phaser-genesis/node_modules/bitecs/src/Query.js", "../../../../phaser-genesis/node_modules/bitecs/src/Component.js", "../../../../phaser-genesis/node_modules/bitecs/src/World.js", "../../../../phaser-genesis/node_modules/bitecs/src/System.js", "../../../../phaser-genesis/node_modules/bitecs/src/index.js", "../../../../phaser-genesis/src/components/transform/Extent2DComponent.ts", "../../../../phaser-genesis/src/components/dirty/DirtyComponent.ts", "../../../../phaser-genesis/src/components/dirty/SetDirtyTransform.ts", "../../../../phaser-genesis/src/components/transform/SetExtent.ts", "../../../../phaser-genesis/src/components/vertices/QuadVertexComponent.ts", "../../../../phaser-genesis/src/components/vertices/SetUV.ts", "../../../../phaser-genesis/src/textures/Frame.ts", "../../../../phaser-genesis/src/textures/Texture.ts", "../../../../phaser-genesis/src/renderer/webgl1/shaders/Shader.ts", "../../../../phaser-genesis/src/renderer/webgl1/shaders/QuadShader.ts", "../../../../phaser-genesis/src/renderer/webgl1/shaders/MultiTextureQuadShader.ts", "../../../../phaser-genesis/src/renderer/webgl1/renderpass/ShaderStack.ts", "../../../../phaser-genesis/src/components/bounds/BoundsComponent.ts", "../../../../phaser-genesis/src/GameObjectWorld.ts", "../../../../phaser-genesis/src/components/bounds/AddBoundsComponent.ts", "../../../../phaser-genesis/src/math/mat4/Matrix4Component.ts", "../../../../phaser-genesis/src/math/mat4/AddMatrix4Component.ts", "../../../../phaser-genesis/src/camera/StaticCamera.ts", "../../../../phaser-genesis/src/renderer/webgl1/renderpass/CreateTempTextures.ts", "../../../../phaser-genesis/src/textures/WhiteTexture.ts", "../../../../phaser-genesis/src/renderer/webgl1/renderpass/TextureStack.ts", "../../../../phaser-genesis/src/renderer/webgl1/buffers/DeleteGLBuffer.ts", "../../../../phaser-genesis/src/renderer/webgl1/buffers/VertexBuffer.ts", "../../../../phaser-genesis/src/renderer/webgl1/renderpass/VertexBufferStack.ts", "../../../../phaser-genesis/src/geom/rectangle/RectangleContains.ts", "../../../../phaser-genesis/src/geom/rectangle/Rectangle.ts", "../../../../phaser-genesis/src/geom/rectangle/RectangleEquals.ts", "../../../../phaser-genesis/src/renderer/webgl1/renderpass/ViewportStack.ts", "../../../../phaser-genesis/src/renderer/webgl1/renderpass/RenderPass.ts", "../../../../phaser-genesis/src/renderer/webgl1/renderpass/Start.ts", "../../../../phaser-genesis/src/renderer/RendererInstance.ts", "../../../../phaser-genesis/src/renderer/webgl1/WebGLRendererInstance.ts", "../../../../phaser-genesis/src/renderer/webgl1/WebGLRenderer.ts", "../../../../phaser-genesis/src/config/webgl/WebGL.ts", "../../../../phaser-genesis/src/config/webglcontext/SetWebGLContext.ts", "../../../../phaser-genesis/src/config/worldsize/SetWorldSize.ts", "../../../../phaser-genesis/src/events/Emit.ts", "../../../../phaser-genesis/src/input/keyboard/Key.ts", "../../../../phaser-genesis/src/input/keyboard/keys/DownKey.ts", "../../../../phaser-genesis/src/input/keyboard/keys/LeftKey.ts", "../../../../phaser-genesis/src/input/keyboard/keys/RightKey.ts", "../../../../phaser-genesis/src/input/keyboard/keys/UpKey.ts", "../../../../phaser-genesis/src/components/hierarchy/HierarchyComponent.ts", "../../../../phaser-genesis/src/components/hierarchy/ClearHierarchyComponent.ts", "../../../../phaser-genesis/src/components/hierarchy/GetLastChildID.ts", "../../../../phaser-genesis/src/components/hierarchy/GetNumChildren.ts", "../../../../phaser-genesis/src/gameobjects/GameObjectCache.ts", "../../../../phaser-genesis/src/components/hierarchy/GetWorldID.ts", "../../../../phaser-genesis/src/components/hierarchy/GetWorldFromParentID.ts", "../../../../phaser-genesis/src/components/hierarchy/GetParentID.ts", "../../../../phaser-genesis/src/display/IsValidParent.ts", "../../../../phaser-genesis/src/components/hierarchy/GetParents.ts", "../../../../phaser-genesis/src/components/dirty/SetDirtyChild.ts", "../../../../phaser-genesis/src/components/dirty/SetDirtyChildCache.ts", "../../../../phaser-genesis/src/components/permissions/PermissionsComponent.ts", "../../../../phaser-genesis/src/components/permissions/WillCacheChildren.ts", "../../../../phaser-genesis/src/components/permissions/WillTransformChildren.ts", "../../../../phaser-genesis/src/components/dirty/SetDirtyParents.ts", "../../../../phaser-genesis/src/components/hierarchy/SetFirstChildID.ts", "../../../../phaser-genesis/src/components/hierarchy/SetIndex.ts", "../../../../phaser-genesis/src/components/hierarchy/SetLastChildID.ts", "../../../../phaser-genesis/src/components/hierarchy/SetNextSiblingID.ts", "../../../../phaser-genesis/src/components/hierarchy/SetNumChildren.ts", "../../../../phaser-genesis/src/components/hierarchy/SetParentID.ts", "../../../../phaser-genesis/src/components/hierarchy/SetPreviousSiblingID.ts", "../../../../phaser-genesis/src/components/dirty/SetDirtyDisplayList.ts", "../../../../phaser-genesis/src/display/ClearWorld.ts", "../../../../phaser-genesis/src/components/hierarchy/GetFirstChildID.ts", "../../../../phaser-genesis/src/components/hierarchy/GetNextSiblingID.ts", "../../../../phaser-genesis/src/components/hierarchy/MoveNext.ts", "../../../../phaser-genesis/src/components/hierarchy/DepthFirstSearchFromParentID.ts", "../../../../phaser-genesis/src/display/SetWorld.ts", "../../../../phaser-genesis/src/display/AddChild.ts", "../../../../phaser-genesis/src/display/AddChildAt.ts", "../../../../phaser-genesis/src/display/GetChildIndex.ts", "../../../../phaser-genesis/src/gameobjects/GameObjectTree.ts", "../../../../phaser-genesis/src/components/dirty/SetDirtyWorldDisplayList.ts", "../../../../phaser-genesis/src/components/hierarchy/GetChildrenFromParentID.ts", "../../../../phaser-genesis/src/components/hierarchy/UpdateNumChildren.ts", "../../../../phaser-genesis/src/components/hierarchy/ClearWorldAndParentID.ts", "../../../../phaser-genesis/src/components/hierarchy/UpdateChildIndexes.ts", "../../../../phaser-genesis/src/display/RemoveChildrenBetween.ts", "../../../../phaser-genesis/src/display/DestroyChildren.ts", "../../../../phaser-genesis/src/components/transform/Transform2DComponent.ts", "../../../../phaser-genesis/src/components/transform/AddTransform2DComponent.ts", "../../../../phaser-genesis/src/components/color/ColorComponent.ts", "../../../../phaser-genesis/src/components/color/AddColorComponent.ts", "../../../../phaser-genesis/src/components/dirty/SetDirtyColor.ts", "../../../../phaser-genesis/src/components/dirty/AddDirtyComponent.ts", "../../../../phaser-genesis/src/components/dirty/ClearDirtyChild.ts", "../../../../phaser-genesis/src/components/dirty/ClearDirtyColor.ts", "../../../../phaser-genesis/src/components/dirty/ClearDirtyDisplayList.ts", "../../../../phaser-genesis/src/components/dirty/ClearDirtyTransform.ts", "../../../../phaser-genesis/src/components/dirty/HasDirtyChildCache.ts", "../../../../phaser-genesis/src/components/dirty/HasDirtyColor.ts", "../../../../phaser-genesis/src/components/dirty/HasDirtyDisplayList.ts", "../../../../phaser-genesis/src/components/dirty/HasDirtyTransform.ts", "../../../../phaser-genesis/src/components/color/Color.ts", "../../../../phaser-genesis/src/components/hierarchy/AddHierarchyComponent.ts", "../../../../phaser-genesis/src/components/permissions/AddPermissionsComponent.ts", "../../../../phaser-genesis/src/gameobjects/events/DestroyEvent.ts", "../../../../phaser-genesis/src/components/hierarchy/GetParentGameObject.ts", "../../../../phaser-genesis/src/components/permissions/GetVisible.ts", "../../../../phaser-genesis/src/components/permissions/GetVisibleChildren.ts", "../../../../phaser-genesis/src/display/SetParent.ts", "../../../../phaser-genesis/src/display/ReparentChildren.ts", "../../../../phaser-genesis/src/components/permissions/SetVisible.ts", "../../../../phaser-genesis/src/components/permissions/SetVisibleChildren.ts", "../../../../phaser-genesis/src/components/permissions/WillRender.ts", "../../../../phaser-genesis/src/gameobjects/GameObject.ts", "../../../../phaser-genesis/src/config/defaultorigin/GetDefaultOriginX.ts", "../../../../phaser-genesis/src/config/defaultorigin/GetDefaultOriginY.ts", "../../../../phaser-genesis/src/components/transform/UpdateExtent.ts", "../../../../phaser-genesis/src/components/transform/Origin.ts", "../../../../phaser-genesis/src/renderer/webgl1/renderpass/PopColor.ts", "../../../../phaser-genesis/src/components/transform/Position.ts", "../../../../phaser-genesis/src/components/transform/Scale.ts", "../../../../phaser-genesis/src/renderer/webgl1/renderpass/SetColor.ts", "../../../../phaser-genesis/src/components/transform/Size.ts", "../../../../phaser-genesis/src/components/transform/Skew.ts", "../../../../phaser-genesis/src/gameobjects/container/Container.ts", "../../../../phaser-genesis/src/display/RemoveChildAt.ts", "../../../../phaser-genesis/src/display/RemoveChild.ts", "../../../../phaser-genesis/src/display/RemoveChildren.ts", "../../../../phaser-genesis/src/components/vertices/SetQuadPosition.ts", "../../../../phaser-genesis/src/components/vertices/AddQuadVertex.ts", "../../../../phaser-genesis/src/renderer/webgl1/renderpass/GetVertexBufferEntry.ts", "../../../../phaser-genesis/src/components/vertices/SetQuadTextureIndex.ts", "../../../../phaser-genesis/src/renderer/webgl1/draw/BatchTexturedQuadBuffer.ts", "../../../../phaser-genesis/src/gameobjects/sprite/SetFrame.ts", "../../../../phaser-genesis/src/textures/TextureManagerInstance.ts", "../../../../phaser-genesis/src/textures/GetTexture.ts", "../../../../phaser-genesis/src/gameobjects/sprite/SetTexture.ts", "../../../../phaser-genesis/src/gameobjects/sprite/Sprite.ts", "../../../../phaser-genesis/src/math/Between.ts", "../../../../phaser-genesis/src/config/banner/AddBanner.ts", "../../../../phaser-genesis/src/config/globalvar/AddGlobalVar.ts", "../../../../phaser-genesis/src/components/timer/TimeComponent.ts", "../../../../phaser-genesis/src/components/timer/AddTimeComponent.ts", "../../../../phaser-genesis/src/dom/AddToDOM.ts", "../../../../phaser-genesis/src/config/parent/AddToParent.ts", "../../../../phaser-genesis/src/config/renderer/CreateRenderer.ts", "../../../../phaser-genesis/src/scenes/RenderStatsComponent.ts", "../../../../phaser-genesis/src/scenes/AddRenderStatsComponent.ts", "../../../../phaser-genesis/src/GameInstance.ts", "../../../../phaser-genesis/src/config/scenes/GetScenes.ts", "../../../../phaser-genesis/src/events/EventInstance.ts", "../../../../phaser-genesis/src/events/On.ts", "../../../../phaser-genesis/src/events/Once.ts", "../../../../phaser-genesis/src/scenes/ResetRenderStats.ts", "../../../../phaser-genesis/src/scenes/SceneManagerInstance.ts", "../../../../phaser-genesis/src/world/WorldList.ts", "../../../../phaser-genesis/src/scenes/SceneManager.ts", "../../../../phaser-genesis/src/scenes/CreateSceneManager.ts", "../../../../phaser-genesis/src/textures/CreateCanvas.ts", "../../../../phaser-genesis/src/textures/TextureManager.ts", "../../../../phaser-genesis/src/textures/CreateTextureManager.ts", "../../../../phaser-genesis/src/dom/DOMContentLoaded.ts", "../../../../phaser-genesis/src/events/EventEmitter.ts", "../../../../phaser-genesis/src/scenes/GetRenderStatsAsObject.ts", "../../../../phaser-genesis/src/components/timer/ResetLastTick.ts", "../../../../phaser-genesis/src/scenes/GetConfigValue.ts", "../../../../phaser-genesis/src/scenes/Install.ts", "../../../../phaser-genesis/src/scenes/Scene.ts", "../../../../phaser-genesis/src/config/SetConfigDefaults.ts", "../../../../phaser-genesis/src/components/timer/UpdateDelta.ts", "../../../../phaser-genesis/src/components/timer/UpdateTime.ts", "../../../../phaser-genesis/src/Game.ts", "../../../../phaser-genesis/src/loader/CreateFile.ts", "../../../../phaser-genesis/src/loader/GetURL.ts", "../../../../phaser-genesis/src/loader/RequestFile.ts", "../../../../phaser-genesis/src/loader/files/ImageFile.ts", "../../../../phaser-genesis/src/input/keyboard/Keyboard.ts", "../../../../phaser-genesis/src/components/bounds/BoundsIntersects.ts", "../../../../phaser-genesis/src/components/vertices/SetQuadColor.ts", "../../../../phaser-genesis/src/components/color/UpdateQuadColorSystem.ts", "../../../../phaser-genesis/src/components/hierarchy/SetWorldID.ts", "../../../../phaser-genesis/src/components/permissions/HasRenderableChildren.ts", "../../../../phaser-genesis/src/components/permissions/WillRenderChildren.ts", "../../../../phaser-genesis/src/components/permissions/WillUpdate.ts", "../../../../phaser-genesis/src/components/permissions/WillUpdateChildren.ts", "../../../../phaser-genesis/src/components/transform/CopyLocalToWorld.ts", "../../../../phaser-genesis/src/components/transform/CopyWorldToWorld.ts", "../../../../phaser-genesis/src/components/transform/MultiplyLocalWithWorld.ts", "../../../../phaser-genesis/src/components/transform/UpdateWorldTransform.ts", "../../../../phaser-genesis/src/world/RenderDataComponent.ts", "../../../../phaser-genesis/src/components/transform/UpdateLocalTransform.ts", "../../../../phaser-genesis/src/components/vertices/UpdateVertexPositionSystem.ts", "../../../../phaser-genesis/src/world/events/WorldAfterUpdateEvent.ts", "../../../../phaser-genesis/src/world/events/WorldBeforeUpdateEvent.ts", "../../../../phaser-genesis/src/world/events/WorldPostRenderEvent.ts", "../../../../phaser-genesis/src/world/events/WorldRenderEvent.ts", "../../../../phaser-genesis/src/world/events/WorldShutdownEvent.ts", "../../../../phaser-genesis/src/world/events/WorldUpdateEvent.ts", "../../../../phaser-genesis/src/world/AddRenderDataComponent.ts", "../../../../phaser-genesis/src/scenes/events/SceneDestroyEvent.ts", "../../../../phaser-genesis/src/world/BaseWorld.ts", "../../../../phaser-genesis/src/renderer/webgl1/renderpass/SetCamera.ts", "../../../../phaser-genesis/src/renderer/webgl1/renderpass/Begin.ts", "../../../../phaser-genesis/src/components/hierarchy/MoveNextRenderable.ts", "../../../../phaser-genesis/src/components/hierarchy/MoveNextUpdatable.ts", "../../../../phaser-genesis/src/world/RebuildWorldTransforms.ts", "../../../../phaser-genesis/src/world/ResetWorldRenderData.ts", "../../../../phaser-genesis/src/camera/WorldCamera.ts", "../../../../phaser-genesis/src/world/StaticWorld.ts", "../../src/test/snow.ts"],
  "sourcesContent": ["export const CONFIG_DEFAULTS = {\n    AUTO: 'Auto',\n    BACKGROUND_COLOR: 'BackgroundColor',\n    BANNER: 'Banner',\n    BATCH_SIZE: 'BatchSize',\n    CANVAS_CONTEXT: 'CanvasContext',\n    CANVAS: 'Canvas',\n    DEFAULT_ORIGIN: 'DefaultOrigin',\n    GLOBAL_VAR: 'GlobalVar',\n    MAX_TEXTURES: 'MaxTextures',\n    PARENT: 'Parent',\n    RENDERER: 'Renderer',\n    SCENES: 'Scenes',\n    SIZE: 'Size',\n    WEBGL_CONTEXT: 'WebGLContext',\n    WEBGL: 'WebGL',\n    WORLD_SIZE: 'WorldSize',\n    WORLD_WIDTH: 'WorldWidth',\n    WORLD_HEIGHT: 'WorldHeight'\n};\n", "export const ConfigStore = new Map();\n", "import { CONFIG_DEFAULTS } from '../const';\nimport { ConfigStore } from '../ConfigStore';\n\nexport function SetBackgroundColor (color: number): void\n{\n    ConfigStore.set(CONFIG_DEFAULTS.BACKGROUND_COLOR, color);\n}\n", "import { SetBackgroundColor } from './SetBackgroundColor';\n\nexport function BackgroundColor (color: number): () => void\n{\n    return (): void =>\n    {\n        SetBackgroundColor(color);\n    };\n}\n", "import { CONFIG_DEFAULTS } from '../const';\nimport { ConfigStore } from '../ConfigStore';\n\nexport function SetBanner (title: string = '', version: string = '', url: string = '', color: string = '#fff', background: string = 'linear-gradient(#3e0081 40%, #00bcc3)'): void\n{\n    ConfigStore.set(CONFIG_DEFAULTS.BANNER, { title, version, url, color, background });\n}\n", "import { CONFIG_DEFAULTS } from '../const';\nimport { ConfigStore } from '../ConfigStore';\n\nexport function SetBatchSize (size: number): void\n{\n    ConfigStore.set(CONFIG_DEFAULTS.BATCH_SIZE, size);\n}\n", "import { SetBatchSize } from './SetBatchSize';\n\nexport function BatchSize (size: number): () => void\n{\n    return (): void =>\n    {\n        SetBatchSize(size);\n    };\n}\n", "import { IGLTextureBindingConfig } from './webgl1/textures/IGLTextureBindingConfig';\nimport { ITexture } from '../textures/ITexture';\n\nexport type BindingQueueEntry = {\n    texture: ITexture,\n    glConfig: IGLTextureBindingConfig\n};\n\nconst queue: BindingQueueEntry[] = [];\n\nexport const BindingQueue =\n{\n    add: (texture: ITexture, glConfig?: IGLTextureBindingConfig): void =>\n    {\n        queue.push({ texture, glConfig });\n    },\n\n    get: (): BindingQueueEntry[] =>\n    {\n        return queue;\n    },\n\n    clear: (): void =>\n    {\n        queue.length = 0;\n    }\n};\n", "import { CONFIG_DEFAULTS } from '../const';\nimport { ConfigStore } from '../ConfigStore';\n\nexport function GetBackgroundColor (): number\n{\n    return ConfigStore.get(CONFIG_DEFAULTS.BACKGROUND_COLOR);\n}\n", "import { CONFIG_DEFAULTS } from '../const';\nimport { ConfigStore } from '../ConfigStore';\n\nexport function GetHeight (): number\n{\n    return ConfigStore.get(CONFIG_DEFAULTS.SIZE).height;\n}\n", "import { CONFIG_DEFAULTS } from '../const';\nimport { ConfigStore } from '../ConfigStore';\n\nexport function GetResolution (): number\n{\n    return ConfigStore.get(CONFIG_DEFAULTS.SIZE).resolution;\n}\n", "import { CONFIG_DEFAULTS } from '../const';\nimport { ConfigStore } from '../ConfigStore';\n\nexport function GetWidth (): number\n{\n    return ConfigStore.get(CONFIG_DEFAULTS.SIZE).width;\n}\n", "import { CONFIG_DEFAULTS } from '../const';\nimport { ConfigStore } from '../ConfigStore';\nimport { IRendererConstructor } from '../../renderer/IRendererConstructor';\n\nexport function SetRenderer (renderer: IRendererConstructor): void\n{\n    ConfigStore.set(CONFIG_DEFAULTS.RENDERER, renderer);\n}\n", "import { CONFIG_DEFAULTS } from '../const';\nimport { ConfigStore } from '../ConfigStore';\n\nexport function SetDefaultOrigin (x: number = 0.5, y: number = x): void\n{\n    ConfigStore.set(CONFIG_DEFAULTS.DEFAULT_ORIGIN, { x, y });\n}\n", "import { CONFIG_DEFAULTS } from '../const';\nimport { ConfigStore } from '../ConfigStore';\n\nexport function SetGlobalVar (name: string): void\n{\n    ConfigStore.set(CONFIG_DEFAULTS.GLOBAL_VAR, name);\n}\n", "import { SetGlobalVar } from './SetGlobalVar';\n\nexport function GlobalVar (name: string): () => void\n{\n    return (): void =>\n    {\n        SetGlobalVar(name);\n    };\n}\n", "import { CONFIG_DEFAULTS } from '../const';\nimport { ConfigStore } from '../ConfigStore';\n\nexport function SetMaxTextures (max: number): void\n{\n    ConfigStore.set(CONFIG_DEFAULTS.MAX_TEXTURES, max);\n}\n", "/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * Attempts to get the target DOM element based on the given value, which can be either\n * a string, in which case it will be looked-up by ID, or an element node. If nothing\n * can be found it will return a reference to the document.body.\n *\n * @function Phaser.DOM.GetElement\n * @since 4.0.0\n *\n * @param {(string | HTMLElement)} [target] - The DOM element to look-up.\n * \n * @returns {HTMLElement} The HTML Element that was found.\n */\nexport function GetElement (target?: string | HTMLElement): HTMLElement\n{\n    let element: HTMLElement;\n\n    if (target)\n    {\n        if (typeof target === 'string')\n        {\n            //  Hopefully an element ID\n            element = document.getElementById(target);\n        }\n        else if (typeof target === 'object' && target.nodeType === 1)\n        {\n            //  Quick test for a HTMLElement\n            element = target;\n        }\n    }\n\n    if (!element)\n    {\n        element = document.body;\n    }\n\n    return element;\n}\n", "import { CONFIG_DEFAULTS } from '../const';\nimport { ConfigStore } from '../ConfigStore';\nimport { GetElement } from '../../dom/GetElement';\n\nexport function SetParent (parentElement?: string | HTMLElement): void\n{\n    //  If this function was called and `null` *wasn't* given as the parent\n    //  then we try to figure it out, or fallback to the document body\n    if (parentElement)\n    {\n        ConfigStore.set(CONFIG_DEFAULTS.PARENT, GetElement(parentElement));\n    }\n}\n", "import { SetParent } from './SetParent';\n\nexport function Parent (parentElement?: string | HTMLElement): () => void\n{\n    return (): void =>\n    {\n        SetParent(parentElement);\n    };\n}\n", "import { CONFIG_DEFAULTS } from '../const';\nimport { ConfigStore } from '../ConfigStore';\nimport { ISceneConstructor } from '../../scenes/ISceneConstructor';\n\nexport function SetScenes (scenes?: ISceneConstructor | Array<ISceneConstructor>): void\n{\n    ConfigStore.set(CONFIG_DEFAULTS.SCENES, [].concat(scenes));\n}\n", "import { ISceneConstructor } from '../../scenes/ISceneConstructor';\nimport { SetScenes } from './SetScenes';\n\nexport function Scenes (scenes?: ISceneConstructor | Array<ISceneConstructor>): () => void\n{\n    return (): void =>\n    {\n        SetScenes(scenes);\n    };\n}\n", "import { CONFIG_DEFAULTS } from '../const';\nimport { ConfigStore } from '../ConfigStore';\n\nexport function SetSize (width: number = 800, height: number = 600, resolution: number = 1): void\n{\n    if (resolution === 0)\n    {\n        resolution = window.devicePixelRatio;\n    }\n\n    ConfigStore.set(CONFIG_DEFAULTS.SIZE, { width, height, resolution });\n}\n", "export let gl: WebGLRenderingContext;\n\nexport const GL =\n{\n    get: (): WebGLRenderingContext =>\n    {\n        return gl;\n    },\n\n    set: (context: WebGLRenderingContext | undefined): void =>\n    {\n        gl = context;\n    }\n};\n", "import { IRenderPass } from './IRenderPass';\nimport { gl } from '../GL';\n\nexport function Draw (renderPass: IRenderPass): void\n{\n    const count = renderPass.count;\n\n    if (count === 0)\n    {\n        return;\n    }\n\n    const currentBuffer = renderPass.vertexbuffer.current;\n    const currentShader = renderPass.shader.current;\n\n    const renderToFramebuffer = currentShader.shader.renderToFramebuffer;\n\n    if (renderToFramebuffer)\n    {\n        renderPass.framebuffer.set(currentShader.shader.framebuffer, true);\n    }\n\n    if (count === currentBuffer.batchSize)\n    {\n        const type = (currentBuffer.isDynamic) ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;\n\n        gl.bufferData(gl.ARRAY_BUFFER, currentBuffer.data, type);\n    }\n    else\n    {\n        const subsize = count * currentBuffer.entryElementSize;\n\n        const view = currentBuffer.vertexViewF32.subarray(0, subsize);\n\n        gl.bufferSubData(gl.ARRAY_BUFFER, 0, view);\n    }\n\n    if (currentBuffer.indexed)\n    {\n        gl.drawElements(gl.TRIANGLES, count * currentBuffer.entryIndexSize, gl.UNSIGNED_SHORT, 0);\n    }\n    else\n    {\n        gl.drawArrays(gl.TRIANGLES, 0, count * currentBuffer.elementsPerEntry);\n    }\n\n    if (renderToFramebuffer)\n    {\n        renderPass.framebuffer.pop();\n    }\n}\n", "import { Draw } from './Draw';\nimport { IRenderPass } from './IRenderPass';\n\nexport function Flush (renderPass: IRenderPass, forceCount?: number): boolean\n{\n    if (forceCount)\n    {\n        renderPass.count = forceCount;\n    }\n\n    const count = renderPass.count;\n\n    if (count === 0)\n    {\n        return false;\n    }\n\n    Draw(renderPass);\n\n    renderPass.flush();\n\n    return true;\n}\n", "import { Flush } from './Flush';\nimport { IRenderPass } from './IRenderPass';\n\nexport function End (renderPass: IRenderPass): void\n{\n    Flush(renderPass);\n}\n", "import { ICompressedTextures } from './ICompressedTextures';\n\nexport function GetCompressedTextures (gl: WebGLRenderingContext): ICompressedTextures\n{\n    const extString = 'WEBGL_compressed_texture_';\n    const wkExtString = 'WEBKIT_' + extString;\n\n    const hasExt = (format: string) =>\n    {\n        const results = gl.getExtension(extString + format) || gl.getExtension(wkExtString + format);\n\n        if (results)\n        {\n            const glEnums = {};\n\n            for (const key in results)\n            {\n                glEnums[results[key]] = key;\n            }\n\n            return glEnums;\n        }\n    };\n\n    return {\n        ETC: hasExt('etc'),\n        ETC1: hasExt('etc1'),\n        ATC: hasExt('atc'),\n        ASTC: hasExt('astc'),\n        BPTC: hasExt('bptc'),\n        RGTC: hasExt('rgtc'),\n        PVRTC: hasExt('pvrtc'),\n        S3TC: hasExt('s3tc'),\n        S3TCSRGB: hasExt('s3tc_srgb'),\n        IMG: true\n    };\n}\n", "export function GetRGBArray (color: number, output: number[] = []): number[]\n{\n    const r: number = color >> 16 & 0xFF;\n    const g: number = color >> 8 & 0xFF;\n    const b: number = color & 0xFF;\n    const a: number = (color > 16777215) ? color >>> 24 : 255;\n\n    output[0] = r / 255;\n    output[1] = g / 255;\n    output[2] = b / 255;\n    output[3] = a / 255;\n\n    return output;\n}\n", "import { CONFIG_DEFAULTS } from '../const';\nimport { ConfigStore } from '../ConfigStore';\n\nexport function GetWebGLContext (): WebGLContextAttributes\n{\n    return ConfigStore.get(CONFIG_DEFAULTS.WEBGL_CONTEXT);\n}\n", "import { gl } from '../GL';\n\nexport function CreateFramebuffer (texture: WebGLTexture, attachment?: GLenum): WebGLFramebuffer\n{\n    if (!attachment)\n    {\n        attachment = gl.COLOR_ATTACHMENT0;\n    }\n\n    const framebuffer = gl.createFramebuffer();\n\n    gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n\n    gl.framebufferTexture2D(gl.FRAMEBUFFER, attachment, gl.TEXTURE_2D, texture, 0);\n\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n\n    return framebuffer;\n}\n", "import { IGLMipmapType } from './IGLTextureBindingConfig';\nimport { IGLTextureBinding } from './IGLTextureBinding';\nimport { gl } from '../GL';\n\nexport function CreateGLTexture <T extends IGLTextureBinding> (binding: T, mipmaps?: IGLMipmapType[]): WebGLTexture\n{\n    const { generateMipmap, minFilter, parent, compressed, internalFormat, flipY, unpackPremultiplyAlpha, magFilter, wrapS, wrapT, isPOT } = binding;\n\n    const source = parent.image;\n\n    let width = parent.width;\n    let height = parent.height;\n\n    const glTexture: WebGLTexture = gl.createTexture();\n\n    gl.activeTexture(gl.TEXTURE0);\n    gl.bindTexture(gl.TEXTURE_2D, glTexture);\n\n    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flipY);\n    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, unpackPremultiplyAlpha);\n\n    if (source)\n    {\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, source);\n\n        width = source.width;\n        height = source.height;\n    }\n    else if (compressed && mipmaps)\n    {\n        for (let i = 0; i < mipmaps.length; i++)\n        {\n            gl.compressedTexImage2D(gl.TEXTURE_2D, i, internalFormat, mipmaps[i].width, mipmaps[i].height, 0, mipmaps[i].data);\n        }\n    }\n    else\n    {\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n    }\n\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, minFilter);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, magFilter);\n\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, wrapS);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, wrapT);\n\n    if (generateMipmap && isPOT)\n    {\n        gl.generateMipmap(gl.TEXTURE_2D);\n    }\n\n    binding.texture = glTexture;\n\n    return glTexture;\n}\n", "import { gl } from '../GL';\n\nexport function DeleteFramebuffer (framebuffer: WebGLFramebuffer): void\n{\n    if (gl && gl.isFramebuffer(framebuffer))\n    {\n        gl.deleteFramebuffer(framebuffer);\n    }\n}\n", "import { gl } from '../GL';\n\nexport function DeleteGLTexture (texture: WebGLTexture): void\n{\n    if (gl.isTexture(texture))\n    {\n        gl.deleteTexture(texture);\n    }\n}\n", "/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * Checks if the given `width` and `height` are a power of two.\n * Useful for checking texture dimensions.\n *\n * @function Phaser.Math.Pow2.IsSize\n * @since 3.0.0\n *\n * @param {number} width - The width.\n * @param {number} height - The height.\n *\n * @return {boolean} `true` if `width` and `height` are a power of two, otherwise `false`.\n */\nexport function IsSizePowerOfTwo (width: number, height: number): boolean\n{\n    if (width < 1 || height < 1)\n    {\n        return false;\n    }\n\n    return ((width & (width - 1)) === 0) && ((height & (height - 1)) === 0);\n}\n", "import { gl } from '../GL';\n\nexport function SetGLTextureFilterMode (texture: WebGLTexture, linear: boolean = true): void\n{\n    gl.activeTexture(gl.TEXTURE0);\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n\n    const mode = (linear) ? gl.LINEAR : gl.NEAREST;\n\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, mode);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, mode);\n}\n", "import { IGLTextureBinding } from './IGLTextureBinding';\nimport { gl } from '../GL';\n\nexport function UpdateGLTexture <T extends IGLTextureBinding> (binding: T): WebGLTexture\n{\n    const source = binding.parent.image;\n    const width = source.width;\n    const height = source.height;\n\n    if (width > 0 && height > 0)\n    {\n        gl.activeTexture(gl.TEXTURE0);\n        gl.bindTexture(gl.TEXTURE_2D, binding.texture);\n\n        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, binding.flipY);\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, source);\n    }\n\n    return binding.texture;\n}\n", "import { IGLMipmapType, IGLTextureBindingConfig } from './IGLTextureBindingConfig';\n\nimport { CreateFramebuffer } from '../fbo/CreateFramebuffer';\nimport { CreateGLTexture } from './CreateGLTexture';\nimport { DeleteFramebuffer } from '../fbo/DeleteFramebuffer';\nimport { DeleteGLTexture } from './DeleteGLTexture';\nimport { IGLTextureBinding } from './IGLTextureBinding';\nimport { ITexture } from '../../../textures/ITexture';\nimport { IsSizePowerOfTwo } from '../../../math/pow2/IsSizePowerOfTwo';\nimport { SetGLTextureFilterMode } from './SetGLTextureFilterMode';\nimport { UpdateGLTexture } from './UpdateGLTexture';\nimport { gl } from '../GL';\n\nexport class GLTextureBinding implements IGLTextureBinding\n{\n    parent: ITexture;\n\n    texture: WebGLTexture;\n    framebuffer: WebGLFramebuffer;\n    depthbuffer: WebGLRenderbuffer;\n\n    format: string;\n    internalFormat: GLenum;\n    compressed: boolean;\n    mipmaps: IGLMipmapType[];\n\n    isBound: boolean = false;\n    textureUnit: number = 0;\n\n    unpackPremultiplyAlpha: boolean = true;\n\n    minFilter: GLenum;\n    magFilter: GLenum;\n    wrapS: GLenum;\n    wrapT: GLenum;\n\n    flipY: boolean = false;\n    isPOT: boolean = false;\n    generateMipmap: boolean = false;\n\n    constructor (parent: ITexture, config: IGLTextureBindingConfig = {})\n    {\n        this.parent = parent;\n\n        this.isPOT = IsSizePowerOfTwo(parent.width, parent.height);\n\n        //  Add option to dump the mipmaps arrays after binding - but prevents context loss restoration\n\n        const {\n            mipmaps = null,\n            compressed = false,\n            format = 'IMG',\n            internalFormat = 0,\n            texture = null,\n            framebuffer = null,\n            createFramebuffer = false,\n            depthbuffer = null,\n            unpackPremultiplyAlpha = true,\n            minFilter = (this.isPOT) ? gl.LINEAR_MIPMAP_LINEAR : gl.LINEAR,\n            magFilter = gl.LINEAR,\n            wrapS = gl.CLAMP_TO_EDGE,\n            wrapT = gl.CLAMP_TO_EDGE,\n            generateMipmap = this.isPOT,\n            flipY = false\n        } = config;\n\n        this.compressed = compressed;\n        this.format = format;\n        this.internalFormat = internalFormat;\n        this.mipmaps = mipmaps;\n\n        //  If you don't set minFilter to LINEAR then the compressed textures don't work!\n        if (compressed)\n        {\n            this.minFilter = gl.LINEAR;\n        }\n        else\n        {\n            this.minFilter = minFilter;\n        }\n\n        this.magFilter = magFilter;\n        this.wrapS = wrapS;\n        this.wrapT = wrapT;\n        this.generateMipmap = generateMipmap;\n        this.flipY = flipY;\n        this.unpackPremultiplyAlpha = unpackPremultiplyAlpha;\n\n        if (texture)\n        {\n            this.texture = texture;\n        }\n        else\n        {\n            CreateGLTexture(this, mipmaps);\n        }\n\n        if (framebuffer)\n        {\n            this.framebuffer = framebuffer;\n        }\n        else if (createFramebuffer)\n        {\n            this.framebuffer = CreateFramebuffer(this.texture);\n        }\n\n        if (depthbuffer)\n        {\n            this.depthbuffer = depthbuffer;\n        }\n\n        parent.binding = this;\n    }\n\n    //  Needed?\n    setFilter (linear: boolean): void\n    {\n        if (this.texture)\n        {\n            SetGLTextureFilterMode(this.texture, linear);\n        }\n    }\n\n    create (): WebGLTexture\n    {\n        const texture = this.texture;\n\n        if (texture)\n        {\n            DeleteGLTexture(texture);\n        }\n\n        return CreateGLTexture(this);\n    }\n\n    update (): WebGLTexture\n    {\n        const texture = this.texture;\n\n        if (!texture)\n        {\n            return CreateGLTexture(this);\n        }\n        else\n        {\n            return UpdateGLTexture(this);\n        }\n    }\n\n    bind (index: number): void\n    {\n        this.isBound = true;\n        this.textureUnit = index;\n    }\n\n    unbind (): void\n    {\n        this.isBound = false;\n        this.textureUnit = 0;\n    }\n\n    destroy (): void\n    {\n        this.unbind();\n\n        DeleteGLTexture(this.texture);\n        DeleteFramebuffer(this.framebuffer);\n\n        this.parent = null;\n        this.texture = null;\n        this.framebuffer = null;\n    }\n}\n", "import { BindingQueue } from '../../BindingQueue';\nimport { GLTextureBinding } from '../textures/GLTextureBinding';\n\nexport function ProcessBindingQueue (): void\n{\n    const queue = BindingQueue.get();\n\n    queue.forEach(entry =>\n    {\n        const { texture, glConfig } = entry;\n\n        if (!texture.binding)\n        {\n            texture.binding = new GLTextureBinding(texture, glConfig);\n        }\n    });\n\n    BindingQueue.clear();\n}\n", "export const DEFAULT_COLOR_MATRIX = new Float32Array([ 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 ]);\nexport const DEFAULT_COLOR_OFFSET = new Float32Array(4);\n", "import { IRenderPass } from './IRenderPass';\nimport { gl } from '../GL';\n\nexport type BlendModeStackEntry = {\n    enable: boolean;\n    sfactor?: number;\n    dfactor?: number;\n};\n\nexport class BlendModeStack\n{\n    renderPass: IRenderPass;\n\n    stack: BlendModeStackEntry[];\n    default: BlendModeStackEntry;\n    index: number;\n\n    constructor (renderPass: IRenderPass)\n    {\n        this.renderPass = renderPass;\n        this.stack = [];\n    }\n\n    get current (): BlendModeStackEntry\n    {\n        return this.stack[this.index];\n    }\n\n    add (enable: boolean, sfactor?: number, dfactor?: number): BlendModeStackEntry\n    {\n        const entry = { enable, sfactor, dfactor };\n\n        this.index++;\n\n        //  cursor already at the end of the stack, so we need to grow it\n        if (this.index === this.stack.length)\n        {\n            this.stack.push(entry);\n        }\n        else\n        {\n            this.stack[this.index] = entry;\n        }\n\n        return entry;\n    }\n\n    bindDefault (): void\n    {\n        this.index = 0;\n\n        this.bind(this.default);\n    }\n\n    bind (entry?: BlendModeStackEntry): void\n    {\n        if (!entry)\n        {\n            entry = this.current;\n        }\n\n        if (entry.enable)\n        {\n            if (!gl.isEnabled(gl.BLEND) || (this.current.sfactor !== entry.sfactor || this.current.dfactor !== entry.dfactor))\n            {\n                gl.enable(gl.BLEND);\n                gl.blendFunc(entry.sfactor, entry.dfactor);\n            }\n        }\n        else\n        {\n            gl.disable(gl.BLEND);\n        }\n    }\n\n    pop (): void\n    {\n        this.index--;\n\n        this.bind();\n    }\n\n    set (enable: boolean, sfactor?: number, dfactor?: number): void\n    {\n        const entry = this.add(enable, sfactor, dfactor);\n\n        this.bind(entry);\n    }\n\n    setDefault (enable: boolean, sfactor?: number, dfactor?: number): void\n    {\n        const entry = { enable, sfactor, dfactor };\n\n        //  The default entry always goes into index zero\n        this.stack[0] = entry;\n\n        this.index = 0;\n\n        this.default = entry;\n    }\n}\n", "\nexport function CompareColorMatrix (srcMatrix: Float32Array, srcOffset: Float32Array, targetMatrix: Float32Array, targetOffset: Float32Array): boolean\n{\n    for (let i = 0; i < srcOffset.length; i++)\n    {\n        if (srcOffset[i] !== targetOffset[i])\n        {\n            return false;\n        }\n    }\n\n    for (let i = 0; i < srcMatrix.length; i++)\n    {\n        if (srcMatrix[i] !== targetMatrix[i])\n        {\n            return false;\n        }\n    }\n\n    return true;\n}\n", "import { Color } from '../../../components/color/Color';\nimport { CompareColorMatrix } from '../../../components/color/CompareColorMatrix';\nimport { Flush } from './Flush';\nimport { IRenderPass } from './IRenderPass';\n\nexport type ColorMatrixStackEntry = {\n    colorMatrix: Float32Array;\n    colorOffset: Float32Array;\n};\n\nexport class ColorMatrixStack\n{\n    renderPass: IRenderPass;\n\n    stack: ColorMatrixStackEntry[];\n    default: ColorMatrixStackEntry;\n    index: number;\n\n    constructor (renderPass: IRenderPass)\n    {\n        this.renderPass = renderPass;\n        this.stack = [];\n    }\n\n    get current (): ColorMatrixStackEntry\n    {\n        return this.stack[this.index];\n    }\n\n    add (colorMatrix: Float32Array, colorOffset: Float32Array): ColorMatrixStackEntry\n    {\n        const entry = { colorMatrix, colorOffset };\n\n        this.index++;\n\n        //  cursor already at the end of the stack, so we need to grow it\n        if (this.index === this.stack.length)\n        {\n            this.stack.push(entry);\n        }\n        else\n        {\n            this.stack[this.index] = entry;\n        }\n\n        return entry;\n    }\n\n    bindDefault (): void\n    {\n        this.index = 0;\n\n        this.bind(this.default);\n    }\n\n    bind (entry?: ColorMatrixStackEntry): void\n    {\n        if (!entry)\n        {\n            entry = this.current;\n        }\n\n        const shader = this.renderPass.getCurrentShader();\n\n        Flush(this.renderPass);\n\n        shader.setUniform('uColorMatrix', entry.colorMatrix);\n        shader.setUniform('uColorOffset', entry.colorOffset);\n    }\n\n    pop (): void\n    {\n        this.index--;\n\n        this.bind();\n    }\n\n    set (color: Color): void\n    {\n        const current = this.current;\n\n        const entry = this.add(color.colorMatrix, color.colorOffset);\n\n        if (!CompareColorMatrix(entry.colorMatrix, entry.colorOffset, current.colorMatrix, current.colorOffset))\n        {\n            this.bind(entry);\n        }\n    }\n\n    setDefault (colorMatrix: Float32Array, colorOffset: Float32Array): void\n    {\n        const entry = { colorMatrix, colorOffset };\n\n        //  The default entry always goes into index zero\n        this.stack[0] = entry;\n\n        this.index = 0;\n\n        this.default = entry;\n    }\n}\n", "import { IRenderPass } from './IRenderPass';\nimport { Rectangle } from '../../../geom/rectangle/Rectangle';\nimport { gl } from '../GL';\n\nexport type FramebufferStackEntry = {\n    framebuffer: WebGLFramebuffer;\n    viewport?: Rectangle;\n};\n\nexport class FramebufferStack\n{\n    renderPass: IRenderPass;\n\n    stack: FramebufferStackEntry[];\n    active: WebGLFramebuffer;\n    default: FramebufferStackEntry;\n    index: number;\n\n    constructor (renderPass: IRenderPass)\n    {\n        this.renderPass = renderPass;\n        this.stack = [];\n    }\n\n    get current (): FramebufferStackEntry\n    {\n        return this.stack[this.index];\n    }\n\n    add (framebuffer: WebGLFramebuffer, viewport?: Rectangle): FramebufferStackEntry\n    {\n        const entry = { framebuffer, viewport };\n\n        this.index++;\n\n        //  cursor already at the end of the stack, so we need to grow it\n        if (this.index === this.stack.length)\n        {\n            this.stack.push(entry);\n        }\n        else\n        {\n            this.stack[this.index] = entry;\n        }\n\n        return entry;\n    }\n\n    bindDefault (): void\n    {\n        this.index = 0;\n\n        this.bind(false, this.default);\n    }\n\n    bind (clear: boolean = true, entry?: FramebufferStackEntry): void\n    {\n        if (!entry)\n        {\n            entry = this.current;\n        }\n\n        const { framebuffer, viewport } = entry;\n\n        if (this.active !== framebuffer)\n        {\n            gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n        }\n\n        if (clear)\n        {\n            gl.clearColor(0, 0, 0, 0);\n            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n        }\n\n        if (viewport)\n        {\n            this.renderPass.viewport.set(viewport.x, viewport.y, viewport.width, viewport.height);\n        }\n\n        this.active = framebuffer;\n    }\n\n    pop (): void\n    {\n        if (this.current.viewport)\n        {\n            this.renderPass.viewport.pop();\n        }\n\n        this.index--;\n\n        this.bind(false);\n    }\n\n    set (framebuffer: WebGLFramebuffer, clear: boolean = true, viewport?: Rectangle): void\n    {\n        const entry = this.add(framebuffer, viewport);\n\n        this.bind(clear, entry);\n    }\n\n    setDefault (framebuffer: WebGLFramebuffer = null, viewport?: Rectangle): void\n    {\n        const entry = { framebuffer, viewport };\n\n        //  The default entry always goes into index zero\n        this.stack[0] = entry;\n\n        this.index = 0;\n\n        this.default = entry;\n    }\n}\n", "import { CONFIG_DEFAULTS } from '../const';\nimport { ConfigStore } from '../ConfigStore';\n\nexport function GetBatchSize (): number\n{\n    return ConfigStore.get(CONFIG_DEFAULTS.BATCH_SIZE);\n}\n", "import { CONFIG_DEFAULTS } from '../const';\nimport { ConfigStore } from '../ConfigStore';\n\nexport function GetMaxTextures (): number\n{\n    return ConfigStore.get(CONFIG_DEFAULTS.MAX_TEXTURES);\n}\n", "import { Matrix4 } from './Matrix4';\n\n// Generates an orthogonal projection matrix with the given bounds\n\nexport function Mat4Ortho (matrix: Float32Array, left: number, right: number, bottom: number, top: number, near: number, far: number): void\n{\n    const lr = 1 / (left - right);\n    const bt = 1 / (bottom - top);\n    const nf = 1 / (near - far);\n\n    matrix.set([\n        -2 * lr,\n        0,\n        0,\n        0,\n        0,\n        -2 * bt,\n        0,\n        0,\n        0,\n        0,\n        2 * nf,\n        0,\n        (left + right) * lr,\n        (top + bottom) * bt,\n        (far + near) * nf,\n        1\n    ]);\n}\n", "export const MULTI_QUAD_FRAG =\n`#define SHADER_NAME MULTI_QUAD_FRAG\n#define numTextures %count%\n\nprecision highp float;\n\nvarying vec2 vTextureCoord;\nvarying float vTextureId;\nvarying vec4 vTintColor;\n\nuniform sampler2D uTexture[%count%];\nuniform mat4 uColorMatrix;\nuniform vec4 uColorOffset;\n\nvec4 getSampler (int index, vec2 uv)\n{\n    for (int i = 0; i < numTextures; ++i)\n    {\n        vec4 color = texture2D(uTexture[i], uv);\n\n        if (i == index)\n        {\n            return color * vec4(vTintColor.rgb * vTintColor.a, vTintColor.a);\n        }\n    }\n\n    //  Return black\n    return vec4(0);\n}\n\nvoid main (void)\n{\n    vec4 color = getSampler(int(vTextureId), vTextureCoord);\n\n    //  Un pre-mult alpha\n    if (color.a > 0.0)\n    {\n        color.rgb /= color.a;\n    }\n\n    vec4 result = color * uColorMatrix + (uColorOffset / 255.0);\n\n    //  Pre-mult alpha\n    result.rgb *= result.a;\n\n    gl_FragColor = vec4(result.rgb, result.a);\n}`;\n", "import * as GL_CONST from '../GL_CONST';\n\nimport { ShaderAttributeEntry } from './CreateAttributes';\n\nexport const DefaultQuadAttributes: Record<string, ShaderAttributeEntry> =\n{\n    aVertexPosition: { size: 2 },\n    aTextureCoord: { size: 2 },\n    aTextureId: { size: 1 },\n    aTintColor: { size: 4 }\n};\n", "const BYTE                   = 0x1400;\nconst UNSIGNED_BYTE          = 0x1401;\nconst SHORT                  = 0x1402;\nconst UNSIGNED_SHORT         = 0x1403;\nconst INT                    = 0x1404;\nconst UNSIGNED_INT           = 0x1405;\nconst FLOAT                  = 0x1406;\nconst REPEAT                 = 0x2901;  // eslint-disable-line\nconst CLAMP_TO_EDGE          = 0x812F;\nconst MIRRORED_REPEAT        = 0x8370;  // eslint-disable-line\nconst NEAREST                = 0x2600;  // eslint-disable-line\nconst LINEAR                 = 0x2601;\nconst NEAREST_MIPMAP_NEAREST = 0x2700;  // eslint-disable-line\nconst LINEAR_MIPMAP_NEAREST  = 0x2701;  // eslint-disable-line\nconst NEAREST_MIPMAP_LINEAR  = 0x2702;  // eslint-disable-line\nconst LINEAR_MIPMAP_LINEAR   = 0x2703;  // eslint-disable-line\n\nexport {\n    BYTE,\n    UNSIGNED_BYTE,\n    SHORT,\n    UNSIGNED_SHORT,\n    INT,\n    UNSIGNED_INT,\n    FLOAT,\n    REPEAT,\n    CLAMP_TO_EDGE,\n    MIRRORED_REPEAT,\n    NEAREST,\n    LINEAR,\n    NEAREST_MIPMAP_NEAREST,\n    LINEAR_MIPMAP_NEAREST,\n    NEAREST_MIPMAP_LINEAR,\n    LINEAR_MIPMAP_LINEAR\n};\n", "import * as GL_CONST from '../GL_CONST';\n\nimport { IVertexAttribPointer } from './IVertexAttribPointer';\nimport { gl } from '../GL';\n\nexport type ShaderAttributeEntry = {\n    size: number;\n    type?: number;\n    normalized?: boolean;\n    stride?: number;\n};\n\nexport function CreateAttributes (program: WebGLProgram, attribs: Record<string, ShaderAttributeEntry>): Map<string, IVertexAttribPointer>\n{\n    const attributes = new Map();\n\n    const defaultSettings: ShaderAttributeEntry =\n    {\n        size: 1,\n        type: GL_CONST.FLOAT,\n        normalized: false,\n        stride: 0\n    };\n\n    let offset = 0;\n\n    for (const [ name, entry ] of Object.entries(attribs))\n    {\n        const index = gl.getAttribLocation(program, name);\n\n        if (index !== -1)\n        {\n            gl.enableVertexAttribArray(index);\n\n            const {\n\n                size = defaultSettings.size,\n                type = defaultSettings.type,\n                normalized = defaultSettings.normalized,\n                stride = defaultSettings.stride\n\n            } = entry;\n\n            attributes.set(name, { index, size, type, normalized, stride, offset });\n\n            //  Default value as used by FLOAT, UNSIGNED_INT and INT\n            let typeSize = 4;\n\n            if (type === GL_CONST.UNSIGNED_SHORT || type === GL_CONST.SHORT)\n            {\n                typeSize = 2;\n            }\n            else if (type === GL_CONST.UNSIGNED_BYTE || type === GL_CONST.BYTE)\n            {\n                typeSize = 1;\n            }\n\n            offset += size * typeSize;\n        }\n    }\n\n    return attributes;\n}\n", "import { gl } from '../GL';\n\nexport function CreateDepthBuffer (framebuffer: WebGLFramebuffer, textureWidth: number, textureHeight: number): WebGLRenderbuffer\n{\n    gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n\n    const depthBuffer = gl.createRenderbuffer();\n\n    gl.bindRenderbuffer(gl.RENDERBUFFER, depthBuffer);\n\n    gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, textureWidth, textureHeight);\n\n    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, depthBuffer);\n\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n\n    return depthBuffer;\n}\n", "import { gl } from '../GL';\n\nexport function DeleteShaders (...shaders: WebGLShader[]): void\n{\n    shaders.forEach(shader =>\n    {\n        gl.deleteShader(shader);\n    });\n}\n", "import { DeleteShaders } from './DeleteShaders';\nimport { gl } from '../GL';\n\nexport function CreateProgram (...shaders: WebGLShader[]): WebGLProgram\n{\n    const program = gl.createProgram();\n\n    shaders.forEach(shader =>\n    {\n        gl.attachShader(program, shader);\n    });\n\n    gl.linkProgram(program);\n\n    const status = gl.getProgramParameter(program, gl.LINK_STATUS);\n\n    if (!status)\n    {\n        const info = gl.getProgramInfoLog(program);\n\n        console.error(`Error linking program: ${info}`);\n\n        gl.deleteProgram(program);\n\n        DeleteShaders(...shaders);\n\n        return null;\n    }\n\n    return program;\n}\n", "import { gl } from '../GL';\n\nexport function CreateShader (source: string, type: GLenum): WebGLShader | null\n{\n    const shader = gl.createShader(type);\n\n    gl.shaderSource(shader, source);\n\n    gl.compileShader(shader);\n\n    const status = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\n\n    if (!status)\n    {\n        const info = gl.getShaderInfoLog(shader);\n\n        //  Adding line numbers idea borrowed from Gregg Tavares!\n        const sourceLines = source.split('\\n').map((line, index) =>\n        {\n            return `${index}: ${line}`;\n        });\n\n        console.error(`Error compiling shader: ${info}`, sourceLines.join('\\n'));\n\n        gl.deleteShader(shader);\n\n        return null;\n    }\n\n    return shader;\n}\n", "import { gl } from '../GL';\n\nexport type FloatSetter = (v: number) => void;\nexport type F32Setter = (v: Float32List) => void;\nexport type I32Setter = (v: Int32List) => void;\n\nexport function CreateUniformSetter (uniform: WebGLActiveInfo, location: WebGLUniformLocation, isArray: boolean = false): FloatSetter | F32Setter | I32Setter\n{\n    switch (uniform.type)\n    {\n        case gl.INT:\n        case gl.BOOL:\n        {\n            if (isArray)\n            {\n                return (v: Int32List): void =>\n                {\n                    gl.uniform1iv(location, v);\n                };\n            }\n            else\n            {\n                return (v: number): void =>\n                {\n                    gl.uniform1i(location, v);\n                };\n            }\n        }\n\n        case gl.INT_VEC2:\n        case gl.BOOL_VEC2:\n        {\n            return (v: Int32List): void =>\n            {\n                gl.uniform2iv(location, v);\n            };\n        }\n\n        case gl.INT_VEC3:\n        case gl.BOOL_VEC3:\n        {\n            return (v: Int32List): void =>\n            {\n                gl.uniform3iv(location, v);\n            };\n        }\n\n        case gl.INT_VEC4:\n        case gl.BOOL_VEC4:\n        {\n            return (v: Int32List): void =>\n            {\n                gl.uniform4iv(location, v);\n            };\n        }\n\n        case gl.FLOAT:\n        {\n            if (isArray)\n            {\n                return (v: Float32List): void =>\n                {\n                    gl.uniform1fv(location, v);\n                };\n            }\n            else\n            {\n                return (v: number): void =>\n                {\n                    gl.uniform1f(location, v);\n                };\n            }\n        }\n\n        case gl.FLOAT_VEC2:\n        {\n            return (v: Float32List): void =>\n            {\n                gl.uniform2fv(location, v);\n            };\n        }\n\n        case gl.FLOAT_VEC3:\n        {\n            return (v: Float32List): void =>\n            {\n                gl.uniform3fv(location, v);\n            };\n        }\n\n        case gl.FLOAT_VEC4:\n        {\n            return (v: Float32List): void =>\n            {\n                gl.uniform4fv(location, v);\n            };\n        }\n\n        case gl.FLOAT_MAT2:\n        {\n            return (v: Float32List): void =>\n            {\n                gl.uniformMatrix2fv(location, false, v);\n            };\n        }\n\n        case gl.FLOAT_MAT3:\n        {\n            return (v: Float32List): void =>\n            {\n                gl.uniformMatrix3fv(location, false, v);\n            };\n        }\n\n        case gl.FLOAT_MAT4:\n        {\n            return (v: Float32List): void =>\n            {\n                gl.uniformMatrix4fv(location, false, v);\n            };\n        }\n\n        case gl.SAMPLER_2D:\n        case gl.SAMPLER_CUBE:\n        {\n            if (uniform.size > 1)\n            {\n                return (v: Int32List): void =>\n                {\n                    gl.uniform1iv(location, v);\n                };\n            }\n            else\n            {\n                return (v: number): void =>\n                {\n                    gl.uniform1i(location, v);\n                };\n            }\n        }\n    }\n}\n", "import { CreateUniformSetter } from './CreateUniformSetter';\nimport { gl } from '../GL';\n\nexport function CreateUniforms (program: WebGLProgram): Map<string, Function>\n{\n    const uniforms = new Map();\n\n    const total = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);\n\n    for (let i = 0; i < total; i++)\n    {\n        const uniform = gl.getActiveUniform(program, i);\n\n        let name = uniform.name;\n\n        if (name.startsWith('gl_') || name.startsWith('webgl_'))\n        {\n            //  Skip built-in uniforms\n            continue;\n        }\n\n        const location = gl.getUniformLocation(program, name);\n\n        if (location)\n        {\n            let isArray = false;\n\n            //  If uniform name has [0] at the end, remove it\n            if (name.endsWith('[0]'))\n            {\n                name = name.slice(0, -3);\n\n                isArray = (uniform.size > 1);\n            }\n\n            uniforms.set(name, CreateUniformSetter(uniform, location, isArray));\n        }\n    }\n\n    return uniforms;\n}\n", "export const DefaultQuadUniforms: Record<string, Number | Float32List> =\n{\n    uProjectionMatrix: new Float32Array(16),\n    uCameraMatrix: new Float32Array(16),\n    uTexture: 0,\n    uColorMatrix: new Float32Array([\n        1, 0, 0, 0,\n        0, 1, 0, 0,\n        0, 0, 1, 0,\n        0, 0, 0, 1\n    ]),\n    uColorOffset: new Float32Array(4)\n};\n", "export const SINGLE_QUAD_FRAG =\n`#define SHADER_NAME SINGLE_QUAD_FRAG\n\nprecision highp float;\n\nvarying vec2 vTextureCoord;\nvarying float vTextureId;\nvarying vec4 vTintColor;\n\nuniform sampler2D uTexture;\nuniform mat4 uColorMatrix;\nuniform vec4 uColorOffset;\n\nvoid main (void)\n{\n    vec4 color = texture2D(uTexture, vTextureCoord);\n\n    //  Un pre-mult alpha\n    if (color.a > 0.0)\n    {\n        color.rgb /= color.a;\n    }\n\n    vec4 result = color * uColorMatrix + (uColorOffset / 255.0);\n\n    //  Pre-mult alpha\n    result.rgb *= result.a;\n\n    gl_FragColor = vec4(result.rgb, result.a);\n}`;\n", "export const SINGLE_QUAD_VERT =\n`#define SHADER_NAME SINGLE_QUAD_VERT\n\nprecision highp float;\n\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute float aTextureId;\nattribute vec4 aTintColor;\n\nuniform mat4 uProjectionMatrix;\nuniform mat4 uCameraMatrix;\n\nvarying vec2 vTextureCoord;\nvarying float vTextureId;\nvarying vec4 vTintColor;\n\nvoid main (void)\n{\n    vTextureCoord = aTextureCoord;\n    vTextureId = aTextureId;\n    vTintColor = aTintColor;\n\n    gl_Position = uProjectionMatrix * uCameraMatrix * vec4(aVertexPosition, 0.0, 1.0);\n}`;\n", "export const TYPES_ENUM = {\r\n  i8: 'i8',\r\n  ui8: 'ui8',\r\n  ui8c: 'ui8c',\r\n  i16: 'i16',\r\n  ui16: 'ui16',\r\n  i32: 'i32',\r\n  ui32: 'ui32',\r\n  f32: 'f32',\r\n  f64: 'f64',\r\n  eid: 'eid',\r\n}\r\n\r\nexport const TYPES_NAMES = {\r\n  i8: 'Int8',\r\n  ui8: 'Uint8',\r\n  ui8c: 'Uint8Clamped',\r\n  i16: 'Int16',\r\n  ui16: 'Uint16',\r\n  i32: 'Int32',\r\n  ui32: 'Uint32',\r\n  eid: 'Uint32',\r\n  f32: 'Float32',\r\n  f64: 'Float64'\r\n}\r\n\r\nexport const TYPES = {\r\n  i8: Int8Array,\r\n  ui8: Uint8Array,\r\n  ui8c: Uint8ClampedArray,\r\n  i16: Int16Array,\r\n  ui16: Uint16Array,\r\n  i32: Int32Array,\r\n  ui32: Uint32Array,\r\n  f32: Float32Array,\r\n  f64: Float64Array,\r\n  eid: Uint32Array,\r\n}\r\n\r\nconst UNSIGNED_MAX = {\r\n  uint8: 2**8,\r\n  uint16: 2**16,\r\n  uint32: 2**32\r\n}\r\n\r\nconst roundToMultiple4 = x => Math.ceil(x / 4) * 4\r\n\r\nexport const $storeRef = Symbol('storeRef')\r\nexport const $storeSize = Symbol('storeSize')\r\nexport const $storeMaps = Symbol('storeMaps')\r\nexport const $storeFlattened = Symbol('storeFlattened')\r\nexport const $storeBase = Symbol('storeBase')\r\nexport const $storeType = Symbol('storeType')\r\n\r\nexport const $storeArrayCounts = Symbol('storeArrayCount')\r\nexport const $storeSubarrays = Symbol('storeSubarrays')\r\nexport const $subarrayCursors = Symbol('subarrayCursors')\r\nexport const $subarray = Symbol('subarray')\r\nexport const $subarrayFrom = Symbol('subarrayFrom')\r\nexport const $subarrayTo = Symbol('subarrayTo')\r\nexport const $parentArray = Symbol('subStore')\r\nexport const $tagStore = Symbol('tagStore')\r\n\r\nexport const $queryShadow = Symbol('queryShadow')\r\nexport const $serializeShadow = Symbol('serializeShadow')\r\n\r\nexport const $indexType = Symbol('indexType')\r\nexport const $indexBytes = Symbol('indexBytes')\r\n\r\nexport const $isEidType = Symbol('isEidType')\r\n\r\nconst stores = {}\r\n\r\nexport const resize = (ta, size) => {\r\n  const newBuffer = new ArrayBuffer(size * ta.BYTES_PER_ELEMENT)\r\n  const newTa = new ta.constructor(newBuffer)\r\n  newTa.set(ta, 0)\r\n  return newTa\r\n}\r\n\r\nexport const createShadow = (store, key) => {\r\n  if (!ArrayBuffer.isView(store)) {\r\n    const shadowStore = store[$parentArray].slice(0).fill(0)\r\n    store[key] = store.map((_,eid) => {\r\n      const from = store[eid][$subarrayFrom]\r\n      const to = store[eid][$subarrayTo]\r\n      return shadowStore.subarray(from, to)\r\n    })\r\n  } else {\r\n    store[key] = store.slice(0).fill(0)\r\n  }\r\n}\r\n\r\nconst resizeSubarray = (metadata, store, size) => {\r\n  const cursors = metadata[$subarrayCursors]\r\n  let type = store[$storeType]\r\n  const length = store[0].length\r\n  const indexType =\r\n    length <= UNSIGNED_MAX.uint8\r\n      ? 'ui8'\r\n      : length <= UNSIGNED_MAX.uint16\r\n        ? 'ui16'\r\n        : 'ui32'\r\n\r\n  const arrayCount = metadata[$storeArrayCounts][type]\r\n  const summedLength = Array(arrayCount).fill(0).reduce((a, p) => a + length, 0)\r\n  \r\n  // // for threaded impl\r\n  // // const summedBytesPerElement = Array(arrayCount).fill(0).reduce((a, p) => a + TYPES[type].BYTES_PER_ELEMENT, 0)\r\n  // // const totalBytes = roundToMultiple4(summedBytesPerElement * summedLength * size)\r\n  // // const buffer = new SharedArrayBuffer(totalBytes)\r\n\r\n  const array = new TYPES[type](roundToMultiple4(summedLength * size))\r\n\r\n  // console.log(array.length, metadata[$storeSubarrays][type].length, type)\r\n\r\n  array.set(metadata[$storeSubarrays][type])\r\n  \r\n  metadata[$storeSubarrays][type] = array\r\n  \r\n  array[$indexType] = TYPES_NAMES[indexType]\r\n  array[$indexBytes] = TYPES[indexType].BYTES_PER_ELEMENT\r\n\r\n  // create buffer for type if it does not already exist\r\n  // if (!metadata[$storeSubarrays][type]) {\r\n  //   const arrayCount = metadata[$storeArrayCounts][type]\r\n  //   const summedLength = Array(arrayCount).fill(0).reduce((a, p) => a + length, 0)\r\n\r\n  //   // for threaded impl\r\n  //   // const summedBytesPerElement = Array(arrayCount).fill(0).reduce((a, p) => a + TYPES[type].BYTES_PER_ELEMENT, 0)\r\n  //   // const totalBytes = roundToMultiple4(summedBytesPerElement * summedLength * size)\r\n  //   // const buffer = new SharedArrayBuffer(totalBytes)\r\n\r\n  //   const array = new TYPES[type](roundToMultiple4(summedLength * size))\r\n\r\n  //   // console.log(`array of type ${type} has size of ${array.length}`)\r\n\r\n  //   metadata[$storeSubarrays][type] = array\r\n\r\n  //   array[$indexType] = TYPES_NAMES[indexType]\r\n  //   array[$indexBytes] = TYPES[indexType].BYTES_PER_ELEMENT\r\n  // }\r\n\r\n  const start = cursors[type]\r\n  let end = 0\r\n  for (let eid = 0; eid < size; eid++) {\r\n    const from = cursors[type] + (eid * length)\r\n    const to = from + length\r\n\r\n    store[eid] = metadata[$storeSubarrays][type].subarray(from, to)\r\n    \r\n    store[eid][$subarrayFrom] = from\r\n    store[eid][$subarrayTo] = to\r\n    store[eid][$subarray] = true\r\n    store[eid][$indexType] = TYPES_NAMES[indexType]\r\n    store[eid][$indexBytes] = TYPES[indexType].BYTES_PER_ELEMENT\r\n    \r\n    end = to\r\n  }\r\n\r\n  cursors[type] = end\r\n\r\n  store[$parentArray] = metadata[$storeSubarrays][type].subarray(start, end)\r\n}\r\n\r\nconst resizeRecursive = (metadata, store, size) => {\r\n  Object.keys(store).forEach(key => {\r\n    const ta = store[key]\r\n    if (Array.isArray(ta)) {\r\n      // store[$storeSubarrays] = {}\r\n      // store[$subarrayCursors] = Object.keys(TYPES).reduce((a, type) => ({ ...a, [type]: 0 }), {})\r\n      resizeSubarray(metadata, ta, size)\r\n      store[$storeFlattened].push(ta)\r\n    } else if (ArrayBuffer.isView(ta)) {\r\n      store[key] = resize(ta, size)\r\n      store[$storeFlattened].push(store[key])\r\n    } else if (typeof ta === 'object') {\r\n      resizeRecursive(metadata, store[key], size)\r\n    }\r\n  })\r\n}\r\n\r\nexport const resizeStore = (store, size) => {\r\n  if (store[$tagStore]) return\r\n  store[$storeSize] = size\r\n  store[$storeFlattened].length = 0\r\n  Object.keys(store[$subarrayCursors]).forEach(k => {\r\n    store[$subarrayCursors][k] = 0\r\n  })\r\n  resizeRecursive(store, store, size)\r\n}\r\n\r\nexport const resetStore = store => {\r\n  if (store[$storeFlattened]) {\r\n    store[$storeFlattened].forEach(ta => {\r\n      ta.fill(0)\r\n    })\r\n    Object.keys(store[$storeSubarrays]).forEach(key => {\r\n      store[$storeSubarrays][key].fill(0)\r\n    })\r\n  }\r\n}\r\n\r\nexport const resetStoreFor = (store, eid) => {\r\n  if (store[$storeFlattened]) {\r\n    store[$storeFlattened].forEach(ta => {\r\n      if (ArrayBuffer.isView(ta)) ta[eid] = 0\r\n      else ta[eid].fill(0)\r\n    })\r\n  }\r\n}\r\n\r\nconst createTypeStore = (type, length) => {\r\n  const totalBytes = length * TYPES[type].BYTES_PER_ELEMENT\r\n  const buffer = new ArrayBuffer(totalBytes)\r\n  const store = new TYPES[type](buffer)\r\n  store[$isEidType] = type === TYPES_ENUM.eid\r\n  return store\r\n}\r\n\r\nexport const parentArray = store => store[$parentArray]\r\n\r\nconst createArrayStore = (metadata, type, length) => {\r\n  const size = metadata[$storeSize]\r\n  const store = Array(size).fill(0)\r\n  store[$storeType] = type\r\n  store[$isEidType] = type === TYPES_ENUM.eid\r\n\r\n  const cursors = metadata[$subarrayCursors]\r\n  const indexType =\r\n    length < UNSIGNED_MAX.uint8\r\n      ? 'ui8'\r\n      : length < UNSIGNED_MAX.uint16\r\n        ? 'ui16'\r\n        : 'ui32'\r\n\r\n  if (!length) throw new Error('bitECS - Must define component array length')\r\n  if (!TYPES[type]) throw new Error(`bitECS - Invalid component array property type ${type}`)\r\n\r\n  // create buffer for type if it does not already exist\r\n  if (!metadata[$storeSubarrays][type]) {\r\n    const arrayCount = metadata[$storeArrayCounts][type]\r\n    const summedLength = Array(arrayCount).fill(0).reduce((a, p) => a + length, 0)\r\n    \r\n    // for threaded impl\r\n    // const summedBytesPerElement = Array(arrayCount).fill(0).reduce((a, p) => a + TYPES[type].BYTES_PER_ELEMENT, 0)\r\n    // const totalBytes = roundToMultiple4(summedBytesPerElement * summedLength * size)\r\n    // const buffer = new SharedArrayBuffer(totalBytes)\r\n\r\n    const array = new TYPES[type](roundToMultiple4(summedLength * size))\r\n\r\n    // console.log(`array of type ${type} has size of ${array.length}`)\r\n\r\n    metadata[$storeSubarrays][type] = array\r\n    \r\n    array[$indexType] = TYPES_NAMES[indexType]\r\n    array[$indexBytes] = TYPES[indexType].BYTES_PER_ELEMENT\r\n  }\r\n\r\n  // pre-generate subarrays for each eid\r\n  const start = cursors[type]\r\n  let end = 0\r\n  for (let eid = 0; eid < size; eid++) {\r\n    const from = cursors[type] + (eid * length)\r\n    const to = from + length\r\n\r\n    store[eid] = metadata[$storeSubarrays][type].subarray(from, to)\r\n    \r\n    store[eid][$subarrayFrom] = from\r\n    store[eid][$subarrayTo] = to\r\n    store[eid][$subarray] = true\r\n    store[eid][$indexType] = TYPES_NAMES[indexType]\r\n    store[eid][$indexBytes] = TYPES[indexType].BYTES_PER_ELEMENT\r\n    \r\n    end = to\r\n  }\r\n\r\n  cursors[type] = end\r\n\r\n  store[$parentArray] = metadata[$storeSubarrays][type].subarray(start, end)\r\n\r\n  return store\r\n}\r\n\r\nconst isArrayType = x => Array.isArray(x) && typeof x[0] === 'string' && typeof x[1] === 'number'\r\n\r\nexport const createStore = (schema, size) => {\r\n  const $store = Symbol('store')\r\n\r\n  if (!schema || !Object.keys(schema).length) {\r\n    // tag component\r\n    stores[$store] = {\r\n      [$storeSize]: size,\r\n      [$tagStore]: true,\r\n      [$storeBase]: () => stores[$store]\r\n    }\r\n    return stores[$store]\r\n  }\r\n\r\n  schema = JSON.parse(JSON.stringify(schema))\r\n\r\n  const arrayCounts = {}\r\n  const collectArrayCounts = s => {\r\n    const keys = Object.keys(s)\r\n    for (const k of keys) {\r\n      if (isArrayType(s[k])) {\r\n        if (!arrayCounts[s[k][0]]) arrayCounts[s[k][0]] = 0\r\n        arrayCounts[s[k][0]]++\r\n      } else if (s[k] instanceof Object) {\r\n        collectArrayCounts(s[k])\r\n      }\r\n    }\r\n  }\r\n  collectArrayCounts(schema)\r\n\r\n  const metadata = {\r\n    [$storeSize]: size,\r\n    [$storeMaps]: {},\r\n    [$storeSubarrays]: {},\r\n    [$storeRef]: $store,\r\n    [$subarrayCursors]: Object.keys(TYPES).reduce((a, type) => ({ ...a, [type]: 0 }), {}),\r\n    [$storeFlattened]: [],\r\n    [$storeArrayCounts]: arrayCounts\r\n  }\r\n\r\n  if (schema instanceof Object && Object.keys(schema).length) {\r\n\r\n    const recursiveTransform = (a, k) => {\r\n\r\n      if (typeof a[k] === 'string') {\r\n\r\n        a[k] = createTypeStore(a[k], size)\r\n        a[k][$storeBase] = () => stores[$store]\r\n        metadata[$storeFlattened].push(a[k])\r\n\r\n      } else if (isArrayType(a[k])) {\r\n        \r\n        const [type, length] = a[k]\r\n        a[k] = createArrayStore(metadata, type, length)\r\n        a[k][$storeBase] = () => stores[$store]\r\n        metadata[$storeFlattened].push(a[k])\r\n        // Object.seal(a[k])\r\n\r\n      } else if (a[k] instanceof Object) {\r\n        \r\n        a[k] = Object.keys(a[k]).reduce(recursiveTransform, a[k])\r\n        // Object.seal(a[k])\r\n        \r\n      }\r\n\r\n      return a\r\n    }\r\n\r\n    stores[$store] = Object.assign(Object.keys(schema).reduce(recursiveTransform, schema), metadata)\r\n    stores[$store][$storeBase] = () => stores[$store]\r\n\r\n    // Object.seal(stores[$store])\r\n\r\n    return stores[$store]\r\n\r\n  }\r\n}\r\n\r\nexport const free = (store) => {\r\n  delete stores[store[$storeRef]]\r\n}", "export const Uint32SparseSet = (length) => {\r\n  const dense = new Uint32Array(length)\r\n  const sparse = new Uint32Array(length)\r\n\r\n  let cursor = 0\r\n  dense.count = () => cursor + 1\r\n\r\n  const has = val => dense[sparse[val]] === val\r\n\r\n  const add = val => {\r\n    if (has(val)) return\r\n    sparse[val] = cursor\r\n    dense[cursor] = val\r\n\r\n    cursor++\r\n  }\r\n\r\n  const remove = val => {\r\n    if (!has(val)) return\r\n    const index = sparse[val]\r\n    const swapped = dense[cursor]\r\n    if (swapped !== val) {\r\n      dense[index] = swapped\r\n      sparse[swapped] = index\r\n    }\r\n\r\n    cursor--\r\n  }\r\n\r\n  return {\r\n    add,\r\n    remove,\r\n    has,\r\n    sparse,\r\n    dense,\r\n  }\r\n}\r\n\r\nexport const SparseSet = () => {\r\n  const dense = []\r\n  const sparse = []\r\n\r\n  dense.sort = function (comparator) {\r\n    const result = Array.prototype.sort.call(this, comparator)\r\n\r\n    for(let i = 0; i < dense.length; i++) {\r\n      sparse[dense[i]] = i\r\n    }\r\n    \r\n    return result\r\n  }\r\n\r\n  const has = val => dense[sparse[val]] === val\r\n\r\n  const add = val => {\r\n    if (has(val)) return\r\n    sparse[val] = dense.push(val) - 1\r\n  }\r\n\r\n  const remove = val => {\r\n    if (!has(val)) return\r\n    const index = sparse[val]\r\n    const swapped = dense.pop()\r\n    if (swapped !== val) {\r\n      dense[index] = swapped\r\n      sparse[swapped] = index\r\n    }\r\n  }\r\n\r\n  return {\r\n    add,\r\n    remove,\r\n    has,\r\n    sparse,\r\n    dense,\r\n  }\r\n}", "import { $indexBytes, $indexType, $isEidType, $serializeShadow, $storeBase, $storeFlattened, $tagStore, createShadow } from \"./Storage.js\"\r\nimport { $componentMap, addComponent, hasComponent } from \"./Component.js\"\r\nimport { $entityArray, $entitySparseSet, addEntity, eidToWorld } from \"./Entity.js\"\r\nimport { $localEntities } from \"./World.js\"\r\n\r\nexport const DESERIALIZE_MODE = {\r\n  REPLACE: 0,\r\n  APPEND: 1,\r\n  MAP: 2\r\n}\r\n\r\nlet resized = false\r\n\r\nexport const setSerializationResized = v => { resized = v }\r\n\r\nconst canonicalize = (target) => {\r\n  let componentProps = []\r\n  let changedProps = new Map()\r\n  if (Array.isArray(target)) {\r\n    componentProps = target\r\n      .map(p => {\r\n        if (!p) throw new Error('bitECS - Cannot serialize undefined component')\r\n        if (typeof p === 'function' && p.name === 'QueryChanged') {\r\n          p()[$storeFlattened].forEach(prop => {\r\n            const $ = Symbol()\r\n            createShadow(prop, $)\r\n            changedProps.set(prop, $)\r\n          })\r\n          return p()[$storeFlattened]\r\n        }\r\n        if (Object.getOwnPropertySymbols(p).includes($storeFlattened)) {\r\n          return p[$storeFlattened]\r\n        }\r\n        if (Object.getOwnPropertySymbols(p).includes($storeBase)) {\r\n          return p\r\n        }\r\n      })\r\n      .reduce((a,v) => a.concat(v), [])\r\n  }\r\n  return [componentProps, changedProps]\r\n}\r\n\r\n/**\r\n * Defines a new serializer which targets the given components to serialize the data of when called on a world or array of EIDs.\r\n *\r\n * @param {object|array} target\r\n * @param {number} [maxBytes=20000000]\r\n * @returns {function} serializer\r\n */\r\nexport const defineSerializer = (target, maxBytes = 20000000) => {\r\n  const isWorld = Object.getOwnPropertySymbols(target).includes($componentMap)\r\n\r\n  let [componentProps, changedProps] = canonicalize(target)\r\n\r\n  // TODO: calculate max bytes based on target & recalc upon resize\r\n\r\n  const buffer = new ArrayBuffer(maxBytes)\r\n  const view = new DataView(buffer)\r\n\r\n  return (ents) => {\r\n\r\n    if (resized) {\r\n      [componentProps, changedProps] = canonicalize(target)\r\n      resized = false\r\n    }\r\n\r\n    if (isWorld) {\r\n      componentProps = []\r\n      target[$componentMap].forEach((c, component) => {\r\n        if (component[$storeFlattened])\r\n          componentProps.push(...component[$storeFlattened])\r\n        else componentProps.push(component)\r\n      })\r\n    }\r\n    \r\n    let world\r\n    if (Object.getOwnPropertySymbols(ents).includes($componentMap)) {\r\n      world = ents\r\n      ents = ents[$entityArray]\r\n    } else {\r\n      world = eidToWorld.get(ents[0])\r\n    }\r\n\r\n    if (!ents.length) return\r\n\r\n    let where = 0\r\n\r\n    // iterate over component props\r\n    for (let pid = 0; pid < componentProps.length; pid++) {\r\n      const prop = componentProps[pid]\r\n      const $diff = changedProps.get(prop)\r\n      \r\n      // write pid\r\n      view.setUint8(where, pid)\r\n      where += 1\r\n\r\n      // save space for entity count\r\n      const countWhere = where\r\n      where += 4\r\n      \r\n      let count = 0\r\n      // write eid,val\r\n      for (let i = 0; i < ents.length; i++) {\r\n        const eid = ents[i]\r\n\r\n        // skip if entity doesn't have this component\r\n        if (!hasComponent(world, prop[$storeBase](), eid)) {\r\n          continue\r\n        }\r\n\r\n        // skip if diffing and no change\r\n        // TODO: optimize array diff\r\n        if ($diff) {\r\n          if (ArrayBuffer.isView(prop[eid])) {\r\n            let dirty = false\r\n            for (let i = 0; i < prop[eid].length; i++) {\r\n              if(prop[eid][i] !== prop[eid][$diff][i]) {\r\n                dirty = true\r\n                break\r\n              }\r\n            }\r\n            if (dirty) continue\r\n          } else if (prop[eid] === prop[$diff][eid]) continue\r\n        }\r\n\r\n        count++\r\n\r\n        // write eid\r\n        view.setUint32(where, eid)\r\n        where += 4\r\n\r\n        if (prop[$tagStore]) {\r\n          continue\r\n        }\r\n\r\n        // if property is an array\r\n        if (ArrayBuffer.isView(prop[eid])) {\r\n          const type = prop[eid].constructor.name.replace('Array', '')\r\n          const indexType = prop[eid][$indexType]\r\n          const indexBytes = prop[eid][$indexBytes]\r\n\r\n          // add space for count of dirty array elements\r\n          const countWhere2 = where\r\n          where += 1\r\n\r\n          let count2 = 0\r\n\r\n          // write index,value\r\n          for (let i = 0; i < prop[eid].length; i++) {\r\n            const value = prop[eid][i]\r\n\r\n            if ($diff && prop[eid][i] === prop[eid][$diff][i]) {\r\n              continue\r\n            }\r\n\r\n            // write array index\r\n            view[`set${indexType}`](where, i)\r\n            where += indexBytes\r\n\r\n            // write value at that index\r\n            view[`set${type}`](where, value)\r\n            where += prop[eid].BYTES_PER_ELEMENT\r\n            count2++\r\n          }\r\n\r\n          // write total element count\r\n          view[`set${indexType}`](countWhere2, count2)\r\n\r\n        } else {\r\n          // regular property values\r\n          const type = prop.constructor.name.replace('Array', '')\r\n          // set value next [type] bytes\r\n          view[`set${type}`](where, prop[eid])\r\n          where += prop.BYTES_PER_ELEMENT\r\n\r\n          // sync shadow state\r\n          if (prop[$diff]) prop[$diff][eid] = prop[eid]\r\n        }\r\n      }\r\n\r\n      view.setUint32(countWhere, count)\r\n    }\r\n    return buffer.slice(0, where)\r\n  }\r\n}\r\n\r\nconst newEntities = new Map()\r\n\r\n/**\r\n * Defines a new deserializer which targets the given components to deserialize onto a given world.\r\n *\r\n * @param {object|array} target\r\n * @returns {function} deserializer\r\n */\r\nexport const defineDeserializer = (target) => {\r\n  const isWorld = Object.getOwnPropertySymbols(target).includes($componentMap)\r\n  let [componentProps] = canonicalize(target)\r\n\r\n\r\n  return (world, packet, mode=0) => {\r\n\r\n    newEntities.clear()\r\n    \r\n    if (resized) {\r\n      [componentProps] = canonicalize(target)\r\n      resized = false\r\n    }\r\n\r\n    if (isWorld) {\r\n      componentProps = []\r\n      target[$componentMap].forEach((c, component) => {\r\n        if (component[$storeFlattened])\r\n          componentProps.push(...component[$storeFlattened])\r\n        else componentProps.push(component)\r\n      })\r\n    }\r\n\r\n    const localEntities = world[$localEntities]\r\n\r\n    const view = new DataView(packet)\r\n    let where = 0\r\n\r\n    while (where < packet.byteLength) {\r\n\r\n      // pid\r\n      const pid = view.getUint8(where)\r\n      where += 1\r\n\r\n      // entity count\r\n      const entityCount = view.getUint32(where)\r\n      where += 4\r\n\r\n      // component property\r\n      const prop = componentProps[pid]\r\n\r\n      // Get the entities and set their prop values\r\n      for (let i = 0; i < entityCount; i++) {\r\n        let eid = view.getUint32(where)\r\n        where += 4\r\n\r\n        if (mode === DESERIALIZE_MODE.MAP) {\r\n\r\n          if (localEntities.has(eid)) {\r\n            eid = localEntities.get(eid)\r\n          } else if (newEntities.has(eid)) {\r\n            eid = newEntities.get(eid)\r\n          } else {\r\n            const newEid = addEntity(world)\r\n            localEntities.set(eid, newEid)\r\n            newEntities.set(eid, newEid)\r\n            eid = newEid\r\n          }\r\n        }\r\n\r\n        if (mode === DESERIALIZE_MODE.APPEND ||  \r\n          mode === DESERIALIZE_MODE.REPLACE && !world[$entitySparseSet].has(eid)\r\n        ) {\r\n          const newEid = newEntities.get(eid) || addEntity(world)\r\n          newEntities.set(eid, newEid)\r\n          eid = newEid\r\n        }\r\n\r\n        const component = prop[$storeBase]()\r\n        if (!hasComponent(world, component, eid)) {\r\n          addComponent(world, component, eid)\r\n        }\r\n\r\n        if (component[$tagStore]) {\r\n          continue\r\n        }\r\n        \r\n        if (ArrayBuffer.isView(prop[eid])) {\r\n          const array = prop[eid]\r\n          const count = view[`get${array[$indexType]}`](where)\r\n          where += array[$indexBytes]\r\n\r\n          // iterate over count\r\n          for (let i = 0; i < count; i++) {\r\n            const index = view[`get${array[$indexType]}`](where)\r\n            where += array[$indexBytes]\r\n\r\n            const value = view[`get${array.constructor.name.replace('Array', '')}`](where)\r\n            where += array.BYTES_PER_ELEMENT\r\n            if (prop[$isEidType]) {\r\n              prop[eid][index] = localEntities.get(value)\r\n            } else prop[eid][index] = value\r\n          }\r\n        } else {\r\n          const value = view[`get${prop.constructor.name.replace('Array', '')}`](where)\r\n          where += prop.BYTES_PER_ELEMENT\r\n\r\n          if (prop[$isEidType]) {\r\n            prop[eid] = localEntities.get(value)\r\n          } else prop[eid] = value\r\n        }\r\n      }\r\n    }\r\n  }\r\n}", "import { resizeComponents } from './Component.js'\r\nimport { $notQueries, $queries, queryAddEntity, queryCheckEntity, queryRemoveEntity } from './Query.js'\r\nimport { resizeWorlds } from './World.js'\r\nimport { setSerializationResized } from './Serialize.js'\r\n\r\nexport const $entityMasks = Symbol('entityMasks')\r\nexport const $entityComponents = Symbol('entityMasks')\r\nexport const $entitySparseSet = Symbol('entitySparseSet')\r\nexport const $entityArray = Symbol('entityArray')\r\nexport const $entityIndices = Symbol('entityIndices')\r\nexport const $removedEntities = Symbol('removedEntities')\r\n\r\nlet defaultSize = 100000\r\n\r\n// need a global EID cursor which all worlds and all components know about\r\n// so that world entities can posess entire rows spanning all component tables\r\nlet globalEntityCursor = 0\r\nlet globalSize = defaultSize\r\nlet resizeThreshold = () => globalSize - (globalSize / 5)\r\n\r\nexport const getGlobalSize = () => globalSize\r\n\r\n// removed eids should also be global to prevent memory leaks\r\nconst removed = []\r\n\r\nexport const resetGlobals = () => {\r\n  globalSize = defaultSize\r\n  globalEntityCursor = 0\r\n  removed.length = 0\r\n}\r\n\r\nexport const getDefaultSize = () => defaultSize\r\n\r\n/**\r\n * Sets the default maximum number of entities for worlds and component stores.\r\n *\r\n * @param {number} size\r\n */\r\nexport const setDefaultSize = size => { \r\n  defaultSize = size\r\n  resetGlobals()\r\n}\r\n\r\nexport const getEntityCursor = () => globalEntityCursor\r\nexport const getRemovedEntities = () => removed\r\n\r\nexport const eidToWorld = new Map()\r\n\r\n/**\r\n * Adds a new entity to the specified world.\r\n *\r\n * @param {World} world\r\n * @returns {number} eid\r\n */\r\nexport const addEntity = (world) => {\r\n  \r\n  const eid = removed.length > 0 ? removed.shift() : globalEntityCursor++\r\n  world[$entitySparseSet].add(eid)\r\n  eidToWorld.set(eid, world)\r\n\r\n  if (globalEntityCursor >= defaultSize) {\r\n    console.error(`bitECS - max entities of ${defaultSize} reached, increase with setDefaultSize function.`)\r\n  }\r\n  // if data stores are 80% full\r\n  // if (globalEntityCursor >= resizeThreshold()) {\r\n  //   // grow by half the original size rounded up to a multiple of 4\r\n  //   const size = globalSize\r\n  //   const amount = Math.ceil((size/2) / 4) * 4\r\n  //   const newSize = size + amount\r\n  //   globalSize = newSize\r\n  //   resizeWorlds(newSize)\r\n  //   resizeComponents(newSize)\r\n  //   setSerializationResized(true)\r\n  //   console.info(`\uD83D\uDC7E bitECS - resizing all data stores from ${size} to ${size+amount}`)\r\n  // }\r\n\r\n  world[$notQueries].forEach(q => {\r\n    const match = queryCheckEntity(world, q, eid)\r\n    if (match) queryAddEntity(q, eid)\r\n  })\r\n\r\n  world[$entityComponents].set(eid, new Set())\r\n\r\n  return eid\r\n}\r\n\r\n/**\r\n * Removes an existing entity from the specified world.\r\n *\r\n * @param {World} world\r\n * @param {number} eid\r\n */\r\nexport const removeEntity = (world, eid) => {\r\n  // Check if entity is already removed\r\n  if (!world[$entitySparseSet].has(eid)) return\r\n\r\n  // Remove entity from all queries\r\n  // TODO: archetype graph\r\n  world[$queries].forEach(q => {\r\n    queryRemoveEntity(world, q, eid)\r\n  })\r\n\r\n  // Free the entity\r\n  removed.push(eid)\r\n\r\n  // remove all eid state from world\r\n  world[$entitySparseSet].remove(eid)\r\n  world[$entityComponents].delete(eid)\r\n\r\n  // Clear entity bitmasks\r\n  for (let i = 0; i < world[$entityMasks].length; i++) world[$entityMasks][i][eid] = 0\r\n}\r\n\r\n/**\r\n *  Returns an array of components that an entity possesses.\r\n *\r\n * @param {*} world\r\n * @param {*} eid\r\n */\r\nexport const getEntityComponents = (world, eid) => Array.from(world[$entityComponents].get(eid))", "import { SparseSet } from './Util.js'\r\nimport { $queryShadow, $storeFlattened, $tagStore, createShadow } from './Storage.js'\r\nimport { $componentMap, registerComponent } from './Component.js'\r\nimport { $entityMasks, $entityArray, getEntityCursor, $entitySparseSet } from './Entity.js'\r\n\r\nexport function Not(c) { return function QueryNot() { return c } }\r\nexport function Or(c) { return function QueryOr() { return c } }\r\nexport function Changed(c) { return function QueryChanged() { return c } }\r\n\r\nexport function Any(...comps) { return function QueryAny() { return comps }}\r\nexport function All(...comps) { return function QueryAll() { return comps }}\r\nexport function None(...comps) { return function QueryNone() { return comps }}\r\n\r\nexport const $queries = Symbol('queries')\r\nexport const $notQueries = Symbol('notQueries')\r\n\r\nexport const $queryAny = Symbol('queryAny')\r\nexport const $queryAll = Symbol('queryAll')\r\nexport const $queryNone = Symbol('queryNone')\r\n\r\nexport const $queryMap = Symbol('queryMap')\r\nexport const $dirtyQueries = Symbol('$dirtyQueries')\r\nexport const $queryComponents = Symbol('queryComponents')\r\nexport const $enterQuery = Symbol('enterQuery')\r\nexport const $exitQuery = Symbol('exitQuery')\r\n\r\n/**\r\n * Given an existing query, returns a new function which returns entities who have been added to the given query since the last call of the function.\r\n *\r\n * @param {function} query\r\n * @returns {function} enteredQuery\r\n */\r\nexport const enterQuery = query => world => {\r\n  if (!world[$queryMap].has(query)) registerQuery(world, query)\r\n  const q = world[$queryMap].get(query)\r\n  return q.entered.splice(0)\r\n}\r\n\r\n/**\r\n * Given an existing query, returns a new function which returns entities who have been removed from the given query since the last call of the function.\r\n *\r\n * @param {function} query\r\n * @returns {function} enteredQuery\r\n */\r\nexport const exitQuery = query => world => {\r\n  if (!world[$queryMap].has(query)) registerQuery(world, query)\r\n  const q = world[$queryMap].get(query)\r\n  return q.exited.splice(0)\r\n}\r\n\r\nexport const registerQuery = (world, query) => {\r\n\r\n  const components = []\r\n  const notComponents = []\r\n  const changedComponents = []\r\n\r\n  query[$queryComponents].forEach(c => {\r\n    if (typeof c === 'function') {\r\n      const comp = c()\r\n      if (!world[$componentMap].has(comp)) registerComponent(world, comp)\r\n      if (c.name === 'QueryNot') {\r\n        notComponents.push(comp)\r\n      }\r\n      if (c.name === 'QueryChanged') {\r\n        changedComponents.push(comp)\r\n        components.push(comp)\r\n      }\r\n    } else {\r\n      if (!world[$componentMap].has(c)) registerComponent(world, c)\r\n      components.push(c)\r\n    }\r\n  })\r\n\r\n\r\n  const mapComponents = c => world[$componentMap].get(c)\r\n\r\n  const allComponents = components.concat(notComponents).map(mapComponents)\r\n\r\n  // const sparseSet = Uint32SparseSet(getGlobalSize())\r\n  const sparseSet = SparseSet()\r\n\r\n  const archetypes = []\r\n  // const changed = SparseSet()\r\n  const changed = []\r\n  const toRemove = []\r\n  const entered = []\r\n  const exited = []\r\n\r\n  const generations = allComponents\r\n    .map(c => c.generationId)\r\n    .reduce((a,v) => {\r\n      if (a.includes(v)) return a\r\n      a.push(v)\r\n      return a\r\n    }, [])\r\n\r\n  const reduceBitflags = (a,c) => {\r\n    if (!a[c.generationId]) a[c.generationId] = 0\r\n    a[c.generationId] |= c.bitflag\r\n    return a\r\n  }\r\n  const masks = components\r\n    .map(mapComponents)\r\n    .reduce(reduceBitflags, {})\r\n\r\n  const notMasks = notComponents\r\n    .map(mapComponents)\r\n    .reduce(reduceBitflags, {})\r\n\r\n  // const orMasks = orComponents\r\n  //   .map(mapComponents)\r\n  //   .reduce(reduceBitmasks, {})\r\n\r\n  const hasMasks = allComponents\r\n    .reduce(reduceBitflags, {})\r\n\r\n  const flatProps = components\r\n    .filter(c => !c[$tagStore])\r\n    .map(c => Object.getOwnPropertySymbols(c).includes($storeFlattened) ? c[$storeFlattened] : [c])\r\n    .reduce((a,v) => a.concat(v), [])\r\n\r\n  const shadows = flatProps.map(prop => {\r\n      const $ = Symbol()\r\n      createShadow(prop, $)\r\n      return prop[$]\r\n  }, [])\r\n\r\n  const q = Object.assign(sparseSet, {\r\n    archetypes,\r\n    changed,\r\n    components,\r\n    notComponents,\r\n    changedComponents,\r\n    masks,\r\n    notMasks,\r\n    // orMasks,\r\n    hasMasks,\r\n    generations,\r\n    flatProps,\r\n    toRemove,\r\n    entered,\r\n    exited,\r\n    shadows,\r\n  })\r\n  \r\n  world[$queryMap].set(query, q)\r\n  world[$queries].add(q)\r\n  \r\n  allComponents.forEach(c => {\r\n    c.queries.add(q)\r\n  })\r\n\r\n  if (notComponents.length) world[$notQueries].add(q)\r\n\r\n  for (let eid = 0; eid < getEntityCursor(); eid++) {\r\n    if (!world[$entitySparseSet].has(eid)) continue\r\n    if (queryCheckEntity(world, q, eid)) {\r\n      queryAddEntity(q, eid)\r\n    }\r\n  }\r\n}\r\n\r\nconst diff = (q, clearDiff) => {\r\n  if (clearDiff) q.changed = []\r\n  const { flatProps, shadows } = q\r\n  for (let i = 0; i < q.dense.length; i++) {\r\n    const eid = q.dense[i]\r\n    let dirty = false\r\n    for (let pid = 0; pid < flatProps.length; pid++) {\r\n      const prop = flatProps[pid]\r\n      const shadow = shadows[pid]\r\n      // console.log('hi', shadow)\r\n      if (ArrayBuffer.isView(prop[eid])) {\r\n        for (let i = 0; i < prop[eid].length; i++) {\r\n          if (prop[eid][i] !== shadow[eid][i]) {\r\n            dirty = true\r\n            shadow[eid][i] = prop[eid][i]\r\n            break\r\n          }\r\n        }\r\n      } else {\r\n        if (prop[eid] !== shadow[eid]) {\r\n          dirty = true\r\n          shadow[eid] = prop[eid]\r\n        }\r\n      }\r\n    }\r\n    if (dirty) q.changed.push(eid)\r\n  }\r\n  return q.changed\r\n}\r\n\r\n// const queryEntityChanged = (q, eid) => {\r\n//   if (q.changed.has(eid)) return\r\n//   q.changed.add(eid)\r\n// }\r\n\r\n// export const entityChanged = (world, component, eid) => {\r\n//   const { changedQueries } = world[$componentMap].get(component)\r\n//   changedQueries.forEach(q => {\r\n//     const match = queryCheckEntity(world, q, eid)\r\n//     if (match) queryEntityChanged(q, eid)\r\n//   })\r\n// }\r\n\r\nconst flatten = (a,v) => a.concat(v)\r\n\r\nconst aggregateComponentsFor = mod => x => x.filter(f => f.name === mod().constructor.name).reduce(flatten)\r\n\r\nconst getAnyComponents = aggregateComponentsFor(Any)\r\nconst getAllComponents = aggregateComponentsFor(All)\r\nconst getNoneComponents = aggregateComponentsFor(None)\r\n\r\n/**\r\n * Defines a query function which returns a matching set of entities when called on a world.\r\n *\r\n * @param {array} components\r\n * @returns {function} query\r\n */\r\n\r\nexport const defineQuery = (...args) => {\r\n  let components\r\n  let any, all, none\r\n  if (Array.isArray(args[0])) {\r\n    components = args[0]\r\n  } else {\r\n    any = getAnyComponents(args)\r\n    all = getAllComponents(args)\r\n    none = getNoneComponents(args)\r\n  }\r\n  \r\n\r\n  if (components === undefined || components[$componentMap] !== undefined) {\r\n    return world => world ? world[$entityArray] : components[$entityArray]\r\n  }\r\n\r\n  const query = function (world, clearDiff=true) {\r\n    if (!world[$queryMap].has(query)) registerQuery(world, query)\r\n\r\n    const q = world[$queryMap].get(query)\r\n\r\n    commitRemovals(world)\r\n\r\n    if (q.changedComponents.length) return diff(q, clearDiff)\r\n    // if (q.changedComponents.length) return q.changed.dense\r\n\r\n    return q.dense\r\n  }\r\n\r\n  query[$queryComponents] = components\r\n  query[$queryAny] = any\r\n  query[$queryAll] = all\r\n  query[$queryNone] = none\r\n\r\n  return query\r\n}\r\n\r\n// TODO: archetype graph\r\nexport const queryCheckEntity = (world, q, eid) => {\r\n  const { masks, notMasks, generations } = q\r\n  let or = 0\r\n  for (let i = 0; i < generations.length; i++) {\r\n    const generationId = generations[i]\r\n    const qMask = masks[generationId]\r\n    const qNotMask = notMasks[generationId]\r\n    // const qOrMask = orMasks[generationId]\r\n    const eMask = world[$entityMasks][generationId][eid]\r\n    \r\n    // any\r\n    // if (qOrMask && (eMask & qOrMask) !== qOrMask) {\r\n    //   continue\r\n    // }\r\n    // none\r\n    if (qNotMask && (eMask & qNotMask) === qNotMask) {\r\n      return false\r\n    }\r\n    // all\r\n    if (qMask && (eMask & qMask) !== qMask) {\r\n      return false\r\n    }\r\n  }\r\n  return true\r\n}\r\n\r\nexport const queryCheckComponent = (q, c) => {\r\n  const { generationId, bitflag } = c\r\n  const { hasMasks } = q\r\n  const mask = hasMasks[generationId]\r\n  return (mask & bitflag) === bitflag\r\n}\r\n\r\nexport const queryAddEntity = (q, eid) => {\r\n  if (q.has(eid)) return\r\n  q.add(eid)\r\n  q.entered.push(eid)\r\n}\r\n\r\nconst queryCommitRemovals = (q) => {\r\n  while (q.toRemove.length) {\r\n    q.remove(q.toRemove.pop())\r\n  }\r\n}\r\n\r\nexport const commitRemovals = (world) => {\r\n  world[$dirtyQueries].forEach(queryCommitRemovals)\r\n  world[$dirtyQueries].clear()\r\n}\r\n\r\nexport const queryRemoveEntity = (world, q, eid) => {\r\n  if (!q.has(eid)) return\r\n  q.toRemove.push(eid)\r\n  world[$dirtyQueries].add(q)\r\n  q.exited.push(eid)\r\n}\r\n\r\n\r\n/**\r\n * Resets a Changed-based query, clearing the underlying list of changed entities.\r\n *\r\n * @param {World} world\r\n * @param {function} query\r\n */\r\nexport const resetChangedQuery = (world, query) => {\r\n  const q = world[$queryMap].get(query)\r\n  q.changed = []\r\n}\r\n\r\n/**\r\n * Removes a query from a world.\r\n *\r\n * @param {World} world\r\n * @param {function} query\r\n */\r\nexport const removeQuery = (world, query) => {\r\n  const q = world[$queryMap].get(query)\r\n  world[$queries].delete(q)\r\n  world[$queryMap].delete(query)\r\n}", "import { $storeSize, createStore, resetStoreFor, resizeStore } from './Storage.js'\r\nimport { $queries, queryAddEntity, queryRemoveEntity, queryCheckEntity } from './Query.js'\r\nimport { $bitflag, $size } from './World.js'\r\nimport { $entityMasks, getDefaultSize, eidToWorld, $entityComponents } from './Entity.js'\r\n\r\nexport const $componentMap = Symbol('componentMap')\r\n\r\nexport const components = []\r\n\r\nexport const resizeComponents = (size) => {\r\n  components.forEach(component => resizeStore(component, size))\r\n}\r\n\r\n\r\n/**\r\n * Defines a new component store.\r\n *\r\n * @param {object} schema\r\n * @returns {object}\r\n */\r\nexport const defineComponent = (schema) => {\r\n  const component = createStore(schema, getDefaultSize())\r\n  if (schema && Object.keys(schema).length) components.push(component)\r\n  return component\r\n}\r\n\r\nexport const incrementBitflag = (world) => {\r\n  world[$bitflag] *= 2\r\n  if (world[$bitflag] >= 2**31) {\r\n    world[$bitflag] = 1\r\n    world[$entityMasks].push(new Uint32Array(world[$size]))\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * Registers a component with a world.\r\n *\r\n * @param {World} world\r\n * @param {Component} component\r\n */\r\nexport const registerComponent = (world, component) => {\r\n  if (!component) throw new Error(`bitECS - Cannot register null or undefined component`)\r\n\r\n  const queries = new Set()\r\n  const notQueries = new Set()\r\n  const changedQueries = new Set()\r\n\r\n  world[$queries].forEach(q => {\r\n    if (q.components.includes(component)) {\r\n      queries.add(q)\r\n    }\r\n  })\r\n\r\n  world[$componentMap].set(component, { \r\n    generationId: world[$entityMasks].length - 1,\r\n    bitflag: world[$bitflag],\r\n    store: component,\r\n    queries,\r\n    notQueries,\r\n    changedQueries,\r\n  })\r\n\r\n  if (component[$storeSize] < world[$size]) {\r\n    resizeStore(component, world[$size])\r\n  }\r\n\r\n  incrementBitflag(world)\r\n}\r\n\r\n/**\r\n * Registers multiple components with a world.\r\n *\r\n * @param {World} world\r\n * @param {Component} components\r\n */\r\nexport const registerComponents = (world, components) => {\r\n  components.forEach(c => registerComponent(world, c))\r\n}\r\n\r\n/**\r\n * Checks if an entity has a component.\r\n *\r\n * @param {World} world\r\n * @param {Component} component\r\n * @param {number} eid\r\n * @returns {boolean}\r\n */\r\nexport const hasComponent = (world, component, eid) => {\r\n  const registeredComponent = world[$componentMap].get(component)\r\n  if (!registeredComponent) return\r\n  const { generationId, bitflag } = registeredComponent\r\n  const mask = world[$entityMasks][generationId][eid]\r\n  return (mask & bitflag) === bitflag\r\n}\r\n\r\n/**\r\n * Adds a component to an entity\r\n *\r\n * @param {World} world\r\n * @param {Component} component\r\n * @param {number} eid\r\n * @param {boolean} [reset=false]\r\n */\r\nexport const addComponent = (world, component, eid, reset=false) => {\r\n  if (!world[$componentMap].has(component)) registerComponent(world, component)\r\n  if (hasComponent(world, component, eid)) return\r\n\r\n  const c = world[$componentMap].get(component)\r\n  const { generationId, bitflag, queries, notQueries } = c\r\n  \r\n  // Add bitflag to entity bitmask\r\n  world[$entityMasks][generationId][eid] |= bitflag\r\n  \r\n  // todo: archetype graph\r\n  queries.forEach(q => {\r\n    const match = queryCheckEntity(world, q, eid)\r\n    if (match) queryAddEntity(q, eid)\r\n    else queryRemoveEntity(world, q, eid)\r\n  })\r\n\r\n  world[$entityComponents].get(eid).add(component)\r\n\r\n  // Zero out each property value\r\n  if (reset) resetStoreFor(component, eid)\r\n}\r\n\r\n/**\r\n * Removes a component from an entity and resets component state unless otherwise specified.\r\n *\r\n * @param {World} world\r\n * @param {Component} component\r\n * @param {number} eid\r\n * @param {boolean} [reset=true]\r\n */\r\nexport const removeComponent = (world, component, eid, reset=true) => {\r\n  const c = world[$componentMap].get(component)\r\n  const { generationId, bitflag, queries, notQueries } = c\r\n\r\n  if (!(world[$entityMasks][generationId][eid] & bitflag)) return\r\n\r\n\r\n  // Remove flag from entity bitmask\r\n  world[$entityMasks][generationId][eid] &= ~bitflag\r\n  \r\n  queries.forEach(q => {\r\n    const match = queryCheckEntity(world, q, eid)\r\n    if (match) queryAddEntity(q, eid)\r\n    else queryRemoveEntity(world, q, eid)\r\n  })\r\n  \r\n  world[$entityComponents].get(eid).delete(component)\r\n\r\n  // Zero out each property value\r\n  if (reset) resetStoreFor(component, eid)\r\n}\r\n", "import { $componentMap } from './Component.js'\r\nimport { $queryMap, $queries, $dirtyQueries, $notQueries } from './Query.js'\r\nimport { $entityArray, $entityComponents, $entityMasks, $entitySparseSet, getGlobalSize, removeEntity } from './Entity.js'\r\nimport { resize } from './Storage.js'\r\nimport { SparseSet } from './Util.js'\r\n\r\nexport const $size = Symbol('size')\r\nexport const $resizeThreshold = Symbol('resizeThreshold')\r\nexport const $bitflag = Symbol('bitflag')\r\nexport const $archetypes = Symbol('archetypes')\r\nexport const $localEntities = Symbol('localEntities')\r\n\r\nexport const worlds = []\r\n\r\nexport const resizeWorlds = (size) => {\r\n  worlds.forEach(world => {\r\n    world[$size] = size\r\n\r\n    for (let i = 0; i < world[$entityMasks].length; i++) {\r\n      const masks = world[$entityMasks][i];\r\n      world[$entityMasks][i] = resize(masks, size)\r\n    }\r\n    \r\n    world[$resizeThreshold] = world[$size] - (world[$size] / 5)\r\n  })\r\n}\r\n\r\n/**\r\n * Creates a new world.\r\n *\r\n * @returns {object}\r\n */\r\nexport const createWorld = () => {\r\n  const world = {}\r\n  resetWorld(world)\r\n  worlds.push(world)\r\n  return world\r\n}\r\n\r\n/**\r\n * Resets a world.\r\n *\r\n * @param {World} world\r\n * @returns {object}\r\n */\r\nexport const resetWorld = (world) => {\r\n  const size = getGlobalSize()\r\n  world[$size] = size\r\n\r\n  if (world[$entityArray]) world[$entityArray].forEach(eid => removeEntity(world, eid))\r\n\r\n  world[$entityMasks] = [new Uint32Array(size)]\r\n  world[$entityComponents] = new Map()\r\n  world[$archetypes] = []\r\n\r\n  world[$entitySparseSet] = SparseSet()\r\n  world[$entityArray] = world[$entitySparseSet].dense\r\n\r\n  world[$bitflag] = 1\r\n\r\n  world[$componentMap] = new Map()\r\n\r\n  world[$queryMap] = new Map()\r\n  world[$queries] = new Set()\r\n  world[$notQueries] = new Set()\r\n  world[$dirtyQueries] = new Set()\r\n\r\n  world[$localEntities] = new Map()\r\n\r\n  return world\r\n}\r\n\r\n/**\r\n * Deletes a world.\r\n *\r\n * @param {World} world\r\n */\r\nexport const deleteWorld = (world) => {\r\n  Object.getOwnPropertySymbols(world).forEach($ => { delete world[$] })\r\n  Object.keys(world).forEach(key => { delete world[key] })\r\n  worlds.splice(worlds.indexOf(world), 1)\r\n}\r\n", "import { commitRemovals } from './Query.js'\r\n\r\n/**\r\n * Defines a new system function.\r\n *\r\n * @param {function} update\r\n * @returns {function}\r\n */\r\nexport const defineSystem = (fn1, fn2) => {\r\n  const update = fn2 !== undefined ? fn2 : fn1\r\n  const create = fn2 !== undefined ? fn1 : undefined\r\n  const init = new Set()\r\n  const system = (world, ...args) => {\r\n    if (create && !init.has(world)) {\r\n      create(world, ...args)\r\n      init.add(world)\r\n    }\r\n    update(world, ...args)\r\n    commitRemovals(world)\r\n    return world\r\n  }\r\n\r\n  Object.defineProperty(system, 'name', {\r\n    value: (update.name || \"AnonymousSystem\") + \"_internal\",\r\n    configurable: true,\r\n  })\r\n\r\n  return system\r\n}", "import { createWorld, resetWorld, deleteWorld } from './World.js'\r\nimport { addEntity, removeEntity, setDefaultSize, getEntityComponents} from './Entity.js'\r\nimport { defineComponent, registerComponent, registerComponents, hasComponent, addComponent, removeComponent } from './Component.js'\r\nimport { defineSystem } from './System.js'\r\nimport { defineQuery, enterQuery, exitQuery, Changed, Not, commitRemovals, resetChangedQuery, removeQuery } from './Query.js'\r\nimport { defineSerializer, defineDeserializer, DESERIALIZE_MODE } from './Serialize.js'\r\nimport { TYPES_ENUM, parentArray } from './Storage.js'\r\n// import { defineProxy } from './Proxy.js'\r\n\r\nexport const pipe = (...fns) => (...args) => {\r\n  const input = Array.isArray(args[0]) ? args[0] : args\r\n  if (!input || input.length === 0) return\r\n  fns = Array.isArray(fns[0]) ? fns[0] : fns\r\n  let tmp = input\r\n  for (let i = 0; i < fns.length; i++) {\r\n    const fn = fns[i]\r\n    if (Array.isArray(tmp)) {\r\n      // tmp = tmp.reduce((a,v) => a.concat(fn(v)),[])\r\n      tmp = fn(...tmp)\r\n    } else {\r\n      tmp = fn(tmp)\r\n    }\r\n  }\r\n  return tmp\r\n}\r\n\r\nexport const Types = TYPES_ENUM\r\n\r\nexport {\r\n\r\n  setDefaultSize,\r\n  createWorld,\r\n  resetWorld,\r\n  deleteWorld,\r\n  addEntity,\r\n  removeEntity,\r\n\r\n  registerComponent,\r\n  registerComponents,\r\n  defineComponent,\r\n  addComponent,\r\n  removeComponent,\r\n  hasComponent,\r\n  getEntityComponents,\r\n  // entityChanged,\r\n\r\n  // defineProxy,\r\n\r\n  defineQuery,\r\n  Changed,\r\n  Not,\r\n  // Or,\r\n  enterQuery,\r\n  exitQuery,\r\n  commitRemovals,\r\n  resetChangedQuery,\r\n  removeQuery,\r\n\r\n  defineSystem,\r\n  \r\n  defineSerializer,\r\n  defineDeserializer,\r\n  DESERIALIZE_MODE,\r\n\r\n  parentArray,\r\n\r\n}\r\n", "import { Types, defineComponent } from 'bitecs';\n\nconst Extent2D = defineComponent({\n    x: Types.f32,\n    y: Types.f32,\n    width: Types.f32,\n    height: Types.f32,\n    right: Types.f32,\n    bottom: Types.f32\n});\n\nexport const Extent2DComponent = Extent2D;\n", "import { Types, defineComponent } from 'bitecs';\n\nconst Dirty = defineComponent({\n    child: Types.ui8,\n    childCache: Types.ui8,\n    displayList: Types.ui8,\n    transform: Types.ui8,\n    color: Types.ui8\n});\n\nexport const DirtyComponent = Dirty;\n", "import { DirtyComponent } from './DirtyComponent';\n\nexport function SetDirtyTransform (id: number): void\n{\n    DirtyComponent.transform[id] = 1;\n}\n", "import { Extent2DComponent } from './Extent2DComponent';\nimport { SetDirtyTransform } from '../dirty/SetDirtyTransform';\n\n//  The area covered by this transform component + origin + size (usually from a Frame)\n\nexport function SetExtent (id: number, x: number, y: number, width: number, height: number): void\n{\n    Extent2DComponent.x[id] = x;\n    Extent2DComponent.y[id] = y;\n    Extent2DComponent.width[id] = width;\n    Extent2DComponent.height[id] = height;\n    Extent2DComponent.right[id] = x + width;\n    Extent2DComponent.bottom[id] = y + height;\n\n    SetDirtyTransform(id);\n}\n", "import { Types, defineComponent } from 'bitecs';\n\n/**\n * Buffer Structure:\n *\n * Triangle 1:\n *\n * Top Left Vert\n *\n * 0 - x position\n * 1 - y position\n * 2 - u0\n * 3 - v0\n * 4 - Texture Index\n * 5 - Red Component\n * 6 - Green Component\n * 7 - Blue Component\n * 8 - Alpha Component\n *\n * Bottom Left Vert\n *\n * 9 - x position\n * 10 - y position\n * 11 - u0\n * 12 - v1\n * 13 - Texture Index\n * 14 - Red Component\n * 15 - Green Component\n * 16 - Blue Component\n * 17 - Alpha Component\n *\n * Bottom Right Vert\n *\n * 18 - x position\n * 19 - y position\n * 20 - u1\n * 21 - v1\n * 22 - Texture Index\n * 23 - Red Component\n * 24 - Green Component\n * 25 - Blue Component\n * 26 - Alpha Component\n *\n * Triangle 2:\n *\n * Top Left Vert\n *\n * 27 - x position\n * 28 - y position\n * 29 - u0\n * 30 - v0\n * 31 - Texture Index\n * 32 - Red Component\n * 33 - Green Component\n * 34 - Blue Component\n * 35 - Alpha Component\n *\n * Bottom Right Vert\n *\n * 36 - x position\n * 37 - y position\n * 38 - u1\n * 39 - v1\n * 40 - Texture Index\n * 41 - Red Component\n * 42 - Green Component\n * 43 - Blue Component\n * 44 - Alpha Component\n *\n * Top Right Vert\n *\n * 45 - x position\n * 46 - y position\n * 47 - u1\n * 48 - v0\n * 49 - Texture Index\n * 50 - Red Component\n * 51 - Green Component\n * 52 - Blue Component\n * 53 - Alpha Component\n */\n\nexport const QuadVertexComponent = defineComponent({\n    values: [ Types.f32, 54 ]\n});\n", "import { QuadVertexComponent } from './QuadVertexComponent';\n\nexport function SetUV (id: number, u0: number, v0: number, u1: number, v1: number): void\n{\n    const data = QuadVertexComponent.values[id];\n\n    data[2] = u0;\n    data[3] = v0;\n\n    data[11] = u0;\n    data[12] = v1;\n\n    data[20] = u1;\n    data[21] = v1;\n\n    data[29] = u0;\n    data[30] = v0;\n\n    data[38] = u1;\n    data[39] = v1;\n\n    data[47] = u1;\n    data[48] = v0;\n}\n", "import { IContainer } from '../gameobjects/container/IContainer';\nimport { IFrame } from './IFrame';\nimport { SetExtent } from '../components/transform/SetExtent';\nimport { SetUV } from '../components/vertices/SetUV';\nimport { Texture } from './Texture';\n\nexport class Frame implements IFrame\n{\n    texture: Texture;\n    key: string | number;\n\n    //  This is the actual area of the texture to draw to canvas / webgl, including any extruded data.\n    //  This is the same as the 'trimmed' + 'extruded' area from an atlas.\n    x: number;\n    y: number;\n    width: number;\n    height: number;\n\n    trimmed: boolean = false;\n\n    //  Original size of the image before being trimmed or added to an atlas (which can add extrude data to it).\n    sourceSizeWidth: number;\n    sourceSizeHeight: number;\n\n    //  The size of the image having been trimmed, before being added to the atlas (i.e. doesn't have any extrusion values in it)\n    spriteSourceSizeX: number;\n    spriteSourceSizeY: number;\n    spriteSourceSizeWidth: number;\n    spriteSourceSizeHeight: number;\n\n    pivot: { x: number; y: number };\n\n    u0: number;\n    v0: number;\n    u1: number;\n    v1: number;\n\n    constructor (texture: Texture, key: string | number, x: number, y: number, width: number, height: number)\n    {\n        this.texture = texture;\n        this.key = key;\n\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n\n        this.sourceSizeWidth = width;\n        this.sourceSizeHeight = height;\n\n        this.updateUVs();\n    }\n\n    setPivot (x: number, y: number): void\n    {\n        this.pivot = { x, y };\n    }\n\n    setSize (width: number, height: number): void\n    {\n        this.width = width;\n        this.height = height;\n        this.sourceSizeWidth = width;\n        this.sourceSizeHeight = height;\n\n        this.updateUVs();\n    }\n\n    setSourceSize (width: number, height: number): void\n    {\n        this.sourceSizeWidth = width;\n        this.sourceSizeHeight = height;\n    }\n\n    setTrim (width: number, height: number, x: number, y: number, w: number, h: number): void\n    {\n        this.trimmed = true;\n\n        this.sourceSizeWidth = width;\n        this.sourceSizeHeight = height;\n\n        this.spriteSourceSizeX = x;\n        this.spriteSourceSizeY = y;\n        this.spriteSourceSizeWidth = w;\n        this.spriteSourceSizeHeight = h;\n    }\n\n    getExtent (originX: number, originY: number): { left: number; right: number; top: number; bottom: number }\n    {\n        const sourceSizeWidth = this.sourceSizeWidth;\n        const sourceSizeHeight = this.sourceSizeHeight;\n\n        let left: number;\n        let right: number;\n        let top: number;\n        let bottom: number;\n\n        if (this.trimmed)\n        {\n            left = this.spriteSourceSizeX - (originX * sourceSizeWidth);\n            right = left + this.spriteSourceSizeWidth;\n\n            top = this.spriteSourceSizeY - (originY * sourceSizeHeight);\n            bottom = top + this.spriteSourceSizeHeight;\n        }\n        else\n        {\n            left = -originX * sourceSizeWidth;\n            right = left + sourceSizeWidth;\n\n            top = -originY * sourceSizeHeight;\n            bottom = top + sourceSizeHeight;\n        }\n\n        return { left, right, top, bottom };\n    }\n\n    copyToExtent (child: IContainer): this\n    {\n        const originX = child.origin.x;\n        const originY = child.origin.y;\n\n        const sourceSizeWidth = this.sourceSizeWidth;\n        const sourceSizeHeight = this.sourceSizeHeight;\n\n        let x: number;\n        let y: number;\n        let width: number;\n        let height: number;\n\n        if (this.trimmed)\n        {\n            x = this.spriteSourceSizeX - (originX * sourceSizeWidth);\n            y = this.spriteSourceSizeY - (originY * sourceSizeHeight);\n\n            width = this.spriteSourceSizeWidth;\n            height = this.spriteSourceSizeHeight;\n        }\n        else\n        {\n            x = -originX * sourceSizeWidth;\n            y = -originY * sourceSizeHeight;\n\n            width = sourceSizeWidth;\n            height = sourceSizeHeight;\n        }\n\n        SetExtent(child.id, x, y, width, height);\n\n        return this;\n    }\n\n    copyToVertices (id: number): this\n    {\n        SetUV(id, this.u0, this.v0, this.u1, this.v1);\n\n        return this;\n    }\n\n    updateUVs (): void\n    {\n        const { x, y, width, height } = this;\n\n        const baseTextureWidth = this.texture.width;\n        const baseTextureHeight = this.texture.height;\n\n        this.u0 = x / baseTextureWidth;\n        this.v0 = y / baseTextureHeight;\n\n        this.u1 = (x + width) / baseTextureWidth;\n        this.v1 = (y + height) / baseTextureHeight;\n    }\n\n    destroy (): void\n    {\n        this.texture = null;\n    }\n}\n", "import { BindingQueue } from '../renderer/BindingQueue';\nimport { Frame } from './Frame';\nimport { IGLTextureBinding } from '../renderer/webgl1/textures/IGLTextureBinding';\nimport { IGLTextureBindingConfig } from '../renderer/webgl1/textures/IGLTextureBindingConfig';\nimport { ITexture } from './ITexture';\n\nexport class Texture implements ITexture\n{\n    //  Unique identifier of this Texture, if stored in the Texture Manager\n    key: string = '';\n\n    locked: boolean = true;\n\n    width: number;\n    height: number;\n\n    image: TexImageSource;\n\n    binding: IGLTextureBinding;\n\n    firstFrame: Frame;\n\n    frames: Map<string | number, Frame>;\n\n    data: unknown;\n\n    constructor (image?: TexImageSource, width?: number, height?: number, glConfig?: IGLTextureBindingConfig)\n    {\n        if (image)\n        {\n            width = image.width;\n            height = image.height;\n        }\n\n        this.image = image;\n\n        this.width = width;\n        this.height = height;\n\n        this.frames = new Map();\n\n        this.data = {};\n\n        this.addFrame('__BASE', 0, 0, width, height);\n\n        BindingQueue.add(this, glConfig);\n    }\n\n    addFrame (key: string | number, x: number, y: number, width: number, height: number): Frame\n    {\n        if (this.frames.has(key))\n        {\n            return null;\n        }\n\n        const frame = new Frame(this, key, x, y, width, height);\n\n        this.frames.set(key, frame);\n\n        if (!this.firstFrame || this.firstFrame.key === '__BASE')\n        {\n            this.firstFrame = frame;\n        }\n\n        return frame;\n    }\n\n    getFrame (key?: string | number | Frame): Frame\n    {\n        //  null, undefined, empty string, zero\n        if (!key)\n        {\n            return this.firstFrame;\n        }\n\n        if (key instanceof Frame)\n        {\n            key = key.key;\n        }\n\n        let frame: Frame = this.frames.get(key);\n\n        if (!frame)\n        {\n            console.warn(`Frame missing: ${key}`);\n\n            frame = this.firstFrame;\n        }\n\n        return frame;\n    }\n\n    setSize (width: number, height: number): void\n    {\n        this.width = width;\n        this.height = height;\n\n        const frame = this.frames.get('__BASE');\n\n        frame.setSize(width, height);\n    }\n\n    update (image: TexImageSource, glConfig?: IGLTextureBindingConfig): void\n    {\n        this.image = image;\n\n        this.setSize(image.width, image.height);\n\n        BindingQueue.add(this, glConfig);\n    }\n\n    destroy (): void\n    {\n        if (this.binding)\n        {\n            this.binding.destroy();\n        }\n\n        this.frames.clear();\n\n        this.binding = null;\n        this.data = null;\n        this.image = null;\n        this.firstFrame = null;\n    }\n}\n", "import { CreateAttributes } from './CreateAttributes';\nimport { CreateDepthBuffer } from '../fbo/CreateDepthBuffer';\nimport { CreateFramebuffer } from '../fbo/CreateFramebuffer';\nimport { CreateProgram } from './CreateProgram';\nimport { CreateShader } from './CreateShader';\nimport { CreateUniforms } from './CreateUniforms';\nimport { DefaultQuadAttributes } from './DefaultQuadAttributes';\nimport { DefaultQuadUniforms } from './DefaultQuadUniforms';\nimport { DeleteFramebuffer } from '../fbo/DeleteFramebuffer';\nimport { DeleteGLTexture } from '../textures/DeleteGLTexture';\nimport { DeleteShaders } from './DeleteShaders';\nimport { GLTextureBinding } from '../textures/GLTextureBinding';\nimport { GetHeight } from '../../../config/size/GetHeight';\nimport { GetResolution } from '../../../config/size/GetResolution';\nimport { GetWidth } from '../../../config/size/GetWidth';\nimport { IRenderPass } from '../renderpass/IRenderPass';\nimport { IShader } from './IShader';\nimport { IShaderConfig } from './IShaderConfig';\nimport { IVertexAttribPointer } from './IVertexAttribPointer';\nimport { SINGLE_QUAD_FRAG } from '../glsl/SINGLE_QUAD_FRAG';\nimport { SINGLE_QUAD_VERT } from '../glsl/SINGLE_QUAD_VERT';\nimport { Texture } from '../../../textures/Texture';\nimport { gl } from '../GL';\n\nexport class Shader implements IShader\n{\n    program: WebGLProgram;\n\n    attributes: Map<string, IVertexAttribPointer>;\n\n    uniforms: Map<string, unknown>;\n\n    uniformSetters: Map<string, Function>;\n\n    texture: Texture;\n\n    framebuffer: WebGLFramebuffer;\n\n    renderToFramebuffer: boolean = false;\n\n    renderToDepthbuffer: boolean = false;\n\n    isActive: boolean = false;\n\n    constructor (config?: IShaderConfig)\n    {\n        if (config)\n        {\n            this.fromConfig(config);\n        }\n    }\n\n    fromConfig (config: IShaderConfig): void\n    {\n        const {\n            attributes = DefaultQuadAttributes,\n            fragmentShader = SINGLE_QUAD_FRAG,\n            height = GetHeight(),\n            renderToFramebuffer = false,\n            renderToDepthbuffer = false,\n            resolution = GetResolution(),\n            vertexShader = SINGLE_QUAD_VERT,\n            width = GetWidth(),\n            uniforms = DefaultQuadUniforms\n        } = config;\n\n        this.create(fragmentShader, vertexShader, uniforms, attributes);\n\n        if (renderToFramebuffer)\n        {\n            this.renderToFramebuffer = true;\n\n            const texture = new Texture(null, width * resolution, height * resolution);\n            const binding = new GLTextureBinding(texture);\n\n            binding.framebuffer = CreateFramebuffer(binding.texture);\n\n            if (renderToDepthbuffer)\n            {\n                this.renderToDepthbuffer = true;\n\n                binding.depthbuffer = CreateDepthBuffer(binding.framebuffer, texture.width, texture.height);\n            }\n\n            this.texture = texture;\n            this.framebuffer = binding.framebuffer;\n        }\n    }\n\n    create (fragmentShaderSource: string, vertexShaderSource: string, uniforms: {}, attribs: {}): void\n    {\n        const fragmentShader = CreateShader(fragmentShaderSource, gl.FRAGMENT_SHADER);\n        const vertexShader = CreateShader(vertexShaderSource, gl.VERTEX_SHADER);\n\n        if (!fragmentShader || !vertexShader)\n        {\n            return;\n        }\n\n        const program = CreateProgram(fragmentShader, vertexShader);\n\n        if (!program)\n        {\n            return;\n        }\n\n        const currentProgram = gl.getParameter(gl.CURRENT_PROGRAM);\n\n        gl.useProgram(program);\n\n        this.program = program;\n\n        this.uniformSetters = CreateUniforms(program);\n\n        this.uniforms = new Map();\n\n        //  Copy starting values from the config object to the uniforms map but only if a setter exists\n        for (const [ key, value ] of Object.entries(uniforms))\n        {\n            if (this.uniformSetters.has(key))\n            {\n                this.uniforms.set(key, value);\n            }\n        }\n\n        this.attributes = CreateAttributes(program, attribs);\n\n        gl.useProgram(currentProgram);\n\n        this.isActive = false;\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    updateUniforms (renderPass: IRenderPass): void\n    {\n        //  Use this to set any extra uniform values prior to the bind\n    }\n\n    bind (renderPass: IRenderPass): boolean\n    {\n        const uniforms = this.uniforms;\n\n        uniforms.set('uProjectionMatrix', renderPass.projectionMatrix);\n        uniforms.set('uCameraMatrix', renderPass.cameraMatrix);\n\n        this.updateUniforms(renderPass);\n\n        return this.setUniforms(renderPass);\n    }\n\n    setUniform (key: string, value: unknown): void\n    {\n        const uniforms = this.uniforms;\n\n        if (uniforms.has(key))\n        {\n            uniforms.set(key, value);\n\n            const setter = this.uniformSetters.get(key);\n\n            setter(value);\n        }\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    setUniforms (renderPass: IRenderPass): boolean\n    {\n        if (!this.program)\n        {\n            return false;\n        }\n\n        gl.useProgram(this.program);\n\n        this.isActive = true;\n\n        const uniforms = this.uniforms;\n\n        for (const [ name, setter ] of this.uniformSetters.entries())\n        {\n            setter(uniforms.get(name));\n        }\n\n        return true;\n    }\n\n    //  stride = vertexByteSize\n    setAttributes (renderPass: IRenderPass): void\n    {\n        if (this.program)\n        {\n            const stride = renderPass.vertexbuffer.current.vertexByteSize;\n\n            this.attributes.forEach(attrib =>\n            {\n                gl.vertexAttribPointer(attrib.index, attrib.size, attrib.type, attrib.normalized, stride, attrib.offset);\n            });\n        }\n    }\n\n    destroy (): void\n    {\n        DeleteShaders(this.program);\n        DeleteGLTexture(this.texture);\n        DeleteFramebuffer(this.framebuffer);\n\n        this.uniforms.clear();\n        this.uniformSetters.clear();\n        this.attributes.clear();\n\n        this.program = null;\n        this.texture = null;\n        this.framebuffer = null;\n    }\n}\n", "import { DefaultQuadAttributes } from './DefaultQuadAttributes';\nimport { IShader } from './IShader';\nimport { IShaderConfig } from './IShaderConfig';\nimport { Shader } from './Shader';\n\n//  Do we even need this class? As Shader defaults to this anyway :)\n\nexport class QuadShader extends Shader implements IShader\n{\n    constructor (config: IShaderConfig = {})\n    {\n        config.attributes = config?.attributes || DefaultQuadAttributes;\n\n        super(config);\n    }\n}\n", "import { GetMaxTextures } from '../../../config/maxtextures/GetMaxTextures';\nimport { IRenderPass } from '../renderpass/IRenderPass';\nimport { IShaderConfig } from './IShaderConfig';\nimport { MULTI_QUAD_FRAG } from '../glsl/MULTI_QUAD_FRAG';\nimport { QuadShader } from './QuadShader';\n\nexport class MultiTextureQuadShader extends QuadShader\n{\n    constructor (config: IShaderConfig = {})\n    {\n        config.fragmentShader = config?.fragmentShader || MULTI_QUAD_FRAG;\n\n        super(config);\n    }\n\n    create (fragmentShaderSource: string, vertexShaderSource: string, uniforms: {}, attribs: {}): void\n    {\n        const maxTextures = GetMaxTextures();\n\n        fragmentShaderSource = fragmentShaderSource.replace(/%count%/gi, `${maxTextures}`);\n\n        super.create(fragmentShaderSource, vertexShaderSource, uniforms, attribs);\n    }\n\n    bind (renderPass: IRenderPass): boolean\n    {\n        this.uniforms.set('uTexture', renderPass.textures.textureIndex);\n\n        return super.bind(renderPass);\n    }\n}\n", "import { IRenderPass } from './IRenderPass';\nimport { IShader } from '../shaders/IShader';\n\nexport type ShaderStackEntry = {\n    shader: IShader;\n    textureID?: number;\n};\n\nexport class ShaderStack\n{\n    renderPass: IRenderPass;\n\n    stack: ShaderStackEntry[];\n    active: IShader;\n    default: ShaderStackEntry;\n    index: number;\n\n    constructor (renderPass: IRenderPass)\n    {\n        this.renderPass = renderPass;\n        this.stack = [];\n    }\n\n    get current (): ShaderStackEntry\n    {\n        return this.stack[this.index];\n    }\n\n    add (shader: IShader, textureID?: number): ShaderStackEntry\n    {\n        const entry = { shader, textureID };\n\n        this.index++;\n\n        //  cursor already at the end of the stack, so we need to grow it\n        if (this.index === this.stack.length)\n        {\n            this.stack.push(entry);\n        }\n        else\n        {\n            this.stack[this.index] = entry;\n        }\n\n        return entry;\n    }\n\n    bindDefault (): void\n    {\n        this.index = 0;\n\n        this.bind(this.default);\n    }\n\n    bind (entry?: ShaderStackEntry): void\n    {\n        if (!entry)\n        {\n            entry = this.current;\n        }\n\n        if (!entry.shader.isActive)\n        {\n            const success = entry.shader.bind(this.renderPass, entry.textureID);\n\n            if (success)\n            {\n                entry.shader.setAttributes(this.renderPass);\n\n                if (this.active && this.active !== entry.shader)\n                {\n                    this.active.isActive = false;\n                }\n\n                this.active = entry.shader;\n            }\n        }\n    }\n\n    pop (): void\n    {\n        this.index--;\n\n        this.bind();\n    }\n\n    set (shader: IShader, textureID?: number): void\n    {\n        const entry = this.add(shader, textureID);\n\n        this.bind(entry);\n    }\n\n    setDefault (shader: IShader, textureID?: number): void\n    {\n        const entry = { shader, textureID };\n\n        //  The default entry always goes into index zero\n        this.stack[0] = entry;\n\n        this.index = 0;\n\n        this.default = entry;\n    }\n}\n", "import { Types, defineComponent } from 'bitecs';\n\n//  Array structure:\n//  x, y, right, bottom\n\n//  local = bounds of Game Object in local space (calculated dynamically, on request)\n//  global = bounds of Game Object in global space (calcuated in UpdatedVertexPositionSystem)\n//  world = bounds of Game Object, factoring in all children, in global space (calculated in BaseWorld)\n\nconst Bounds = defineComponent({\n    local: [ Types.f32, 4 ],\n    global: [ Types.f32, 4 ],\n    world: [ Types.f32, 4 ]\n});\n\nexport const BoundsComponent = Bounds;\n", "import { createWorld, setDefaultSize } from 'bitecs';\n\n// setDefaultSize(100000);\n// setDefaultSize(150000);\n// setDefaultSize(200000);\nsetDefaultSize(250000);\n// setDefaultSize(500000);\n\nconst world = createWorld();\n\nexport const GameObjectWorld = world;\n", "import { BoundsComponent } from './BoundsComponent';\nimport { GameObjectWorld } from '../../GameObjectWorld';\nimport { addComponent } from 'bitecs';\n\nexport function AddBoundsComponent (id: number): void\n{\n    addComponent(GameObjectWorld, BoundsComponent, id);\n}\n", "import { Types, defineComponent } from 'bitecs';\n\nexport const Matrix4Component = defineComponent({\n    data: [ Types.f32, 16 ]\n});\n", "import { GameObjectWorld } from '../../GameObjectWorld';\nimport { Matrix4Component } from './Matrix4Component';\nimport { addComponent } from 'bitecs';\n\nexport function AddMatrix4Component (id: number): void\n{\n    addComponent(GameObjectWorld, Matrix4Component, id);\n\n    const data = Matrix4Component.data[id];\n\n    data[0] = 1;\n    data[5] = 1;\n    data[10] = 1;\n    data[15] = 1;\n}\n", "import { addEntity, removeComponent, removeEntity } from 'bitecs';\n\nimport { AddBoundsComponent } from '../components/bounds/AddBoundsComponent';\nimport { AddMatrix4Component } from '../math/mat4/AddMatrix4Component';\nimport { BoundsComponent } from '../components/bounds/BoundsComponent';\nimport { GameObjectWorld } from '../GameObjectWorld';\nimport { IStaticCamera } from './IStaticCamera';\nimport { Matrix4Component } from '../math/mat4/Matrix4Component';\n\nexport class StaticCamera implements IStaticCamera\n{\n    readonly id: number = addEntity(GameObjectWorld);\n\n    readonly type: string = 'StaticCamera';\n\n    //  User defined name. Never used internally.\n    name: string = '';\n\n    constructor (width: number, height: number)\n    {\n        const id = this.id;\n\n        AddMatrix4Component(id);\n        AddBoundsComponent(id);\n\n        this.reset(width, height);\n    }\n\n    getBounds (): Float32Array\n    {\n        return BoundsComponent.global[this.id];\n    }\n\n    getMatrix (): Float32Array\n    {\n        return Matrix4Component.data[this.id];\n    }\n\n    update (): boolean\n    {\n        return false;\n    }\n\n    reset (width: number, height: number): void\n    {\n        BoundsComponent.global[this.id].set([ 0, 0, width, height ]);\n    }\n\n    destroy (): void\n    {\n        const id = this.id;\n\n        removeComponent(GameObjectWorld, Matrix4Component, id);\n        removeComponent(GameObjectWorld, BoundsComponent, id);\n\n        removeEntity(GameObjectWorld, id);\n    }\n}\n", "import { GetMaxTextures } from '../../../config/maxtextures/GetMaxTextures';\nimport { SetMaxTextures } from '../../../config/maxtextures/SetMaxTextures';\nimport { gl } from '../GL';\n\n//  As per the WebGL spec, the browser should always support at least 8 texture units\n//  However, the user can set this to any value they like (lower than this)\n\nexport function CreateTempTextures (): Array<[ number, WebGLTexture ]>\n{\n    //  Note: This is the maximum number of TIUs that a _fragment_ shader supports\n    //  https://www.khronos.org/opengl/wiki/Common_Mistakes#Texture_Unit\n    let maxGPUTextures: number = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);\n    let maxCombinedGPUTextures: number = gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);\n\n    console.log('MAX GPU', maxGPUTextures, 'MAX COMBINED', maxCombinedGPUTextures);\n\n    const maxConfigTextures = GetMaxTextures();\n\n    if (maxConfigTextures === 0 || maxConfigTextures > maxGPUTextures)\n    {\n        //  Insert gpu limit into config value\n        SetMaxTextures(maxGPUTextures);\n    }\n    else\n    {\n        maxGPUTextures = maxConfigTextures;\n    }\n\n    const textures: Array<[ number, WebGLTexture ]> = [];\n\n    //  Create temp textures to stop WebGL errors on mac os\n    for (let i: number = 0; i < maxGPUTextures; i++)\n    {\n        const tempTexture = gl.createTexture();\n\n        gl.activeTexture(gl.TEXTURE0 + i);\n\n        gl.bindTexture(gl.TEXTURE_2D, tempTexture);\n\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([ 0, 0, 255, 255 ]));\n\n        textures.push([ i, tempTexture ]);\n    }\n\n    return textures;\n}\n", "import { Texture } from './Texture';\n\nlet instance: Texture;\n\nexport const WhiteTexture =\n{\n    get: (): Texture =>\n    {\n        return instance;\n    },\n\n    set: (texture: Texture): void =>\n    {\n        instance = texture;\n    }\n};\n", "import { CreateTempTextures } from './CreateTempTextures';\nimport { Flush } from './Flush';\nimport { IRenderPass } from './IRenderPass';\nimport { ITexture } from '../../../textures/ITexture';\nimport { Texture } from '../../../textures/Texture';\nimport { WhiteTexture } from '../../../textures/WhiteTexture';\nimport { gl } from '../GL';\n\nexport class TextureStack\n{\n    renderPass: IRenderPass;\n\n    textures: Map<number, ITexture>;\n    tempTextures: Map<number, WebGLTexture>;\n    textureIndex: number[];\n\n    maxTextures: number;\n\n    constructor (renderPass: IRenderPass)\n    {\n        this.renderPass = renderPass;\n    }\n\n    //  directly bind a texture to an index slot\n    bind (texture: Texture, index: number = 0): void\n    {\n        const binding = texture.binding;\n\n        binding.bind(index);\n\n        gl.activeTexture(gl.TEXTURE0 + index);\n        gl.bindTexture(gl.TEXTURE_2D, binding.texture);\n    }\n\n    unbind (index: number = 0): void\n    {\n        gl.activeTexture(gl.TEXTURE0 + index);\n        gl.bindTexture(gl.TEXTURE_2D, this.tempTextures[ index ]);\n    }\n\n    setWhite (): number\n    {\n        return this.set(WhiteTexture.get());\n    }\n\n    //  request the next available texture and bind it\n    //  returns the new ID\n    set (texture: ITexture): number\n    {\n        if (!texture.binding)\n        {\n            return -1;\n        }\n\n        const binding = texture.binding;\n        const textures = this.textures;\n\n        //  Make sure texture isn't already bound\n        if (!binding.isBound)\n        {\n            //  Is the current texture Map full? If so, flush it all\n            if (textures.size === this.maxTextures)\n            {\n                Flush(this.renderPass);\n\n                this.clear();\n            }\n\n            // Add texture to the map\n            const textureUnit = textures.size;\n\n            gl.activeTexture(gl.TEXTURE0 + textureUnit);\n            gl.bindTexture(gl.TEXTURE_2D, binding.texture);\n\n            textures.set(textureUnit, texture);\n\n            binding.bind(textureUnit);\n        }\n\n        return binding.textureUnit;\n    }\n\n    setDefault (): void\n    {\n        if (this.textures)\n        {\n            this.reset();\n        }\n\n        const tempTextures = CreateTempTextures();\n\n        this.maxTextures = tempTextures.length;\n\n        this.tempTextures = new Map(tempTextures);\n        this.textures = new Map();\n\n        this.textureIndex = [];\n\n        this.tempTextures.forEach((texture, index) =>\n        {\n            this.textureIndex.push(index);\n        });\n    }\n\n    clear (): void\n    {\n        this.textures.forEach(texture => texture.binding.unbind());\n\n        this.textures.clear();\n    }\n\n    reset (): void\n    {\n        this.tempTextures.forEach((texture, index) =>\n        {\n            gl.activeTexture(gl.TEXTURE0 + index);\n\n            gl.bindTexture(gl.TEXTURE_2D, texture);\n        });\n\n        this.clear();\n    }\n}\n", "import { gl } from '../GL';\n\nexport function DeleteGLBuffer (buffer: WebGLBuffer): void\n{\n    if (gl.isBuffer(buffer))\n    {\n        gl.deleteBuffer(buffer);\n    }\n}\n", "import { DeleteGLBuffer } from './DeleteGLBuffer';\nimport { IVertexBuffer } from './IVertexBuffer';\nimport { IVertexBufferConfig } from './IVertexBufferConfig';\nimport { gl } from '../GL';\n\nexport class VertexBuffer implements IVertexBuffer\n{\n    //  Handy for debug tracing\n    name: string;\n\n    /**\n     * Maximum number of entries per batch before a flush takes place.\n     * For a Mesh, this is the number of triangles / faces in the vertex buffer.\n     * Typically each face consists of 3 verts.\n     *\n     * @type {number}\n     */\n    batchSize: number;\n\n    /**\n     * The size, in bytes, per entry in the array buffer.\n     *\n     * @type {number}\n     */\n    dataSize: number;\n\n    /**\n     * The amount of elements / floats a single vertex consists of.\n     *\n     * The default is 9:\n     *\n     * position (x,y - 2 floats)\n     * texture coord (x,y - 2 floats)\n     * texture index (uint)\n     * red channel (float)\n     * green channel (float)\n     * blue channel (float)\n     * alpha channel (float)\n     *\n     * @type {number}\n     */\n    vertexElementSize: number;\n\n    /**\n     * The size, in bytes, of a single vertex in the array buffer.\n     *\n     * This is `vertexElementSize * dataSize`.\n     *\n     * @type {number}\n     */\n    vertexByteSize: number;\n\n    /**\n     * The size, in bytes, of a single entry in the array buffer.\n     *\n     * This is `vertexByteSize * elementsPerEntry` for a quad.\n     *\n     * @type {number}\n     */\n    entryByteSize: number;\n\n    /**\n     * The size, in bytes, of the Array Buffer.\n     *\n     * This is `batchSize * entryByteSize`\n     *\n     * @type {number}\n     */\n    bufferByteSize: number;\n\n    /**\n     * The Array Buffer.\n     *\n     * @type {ArrayBuffer}\n     */\n    data: ArrayBuffer;\n\n    /**\n     * Float32 View of the Array Buffer.\n     *\n     * @type {Float32Array}\n     */\n    vertexViewF32: Float32Array;\n\n    /**\n     * The data array buffer.\n     *\n     * @type {WebGLBuffer}\n     */\n    vertexBuffer: WebGLBuffer;\n\n    /**\n     * The size, in quantity of elements, of a single entry in the element index array.\n     *\n     * This is `vertexElementSize * elementsPerEntry`\n     *\n     * @type {number}\n     */\n    entryElementSize: number;\n\n    indexed: boolean = false;\n\n    isDynamic: boolean = false;\n\n    /**\n     * The total number of entries added to the buffer so far, or reserved to be added.\n     *\n     * This is the total number of indices / verticies, not faces.\n     * Typically there are 3 verts per face, so this value is usually batchSize x 3 for a Mesh.\n     *\n     * @type {number}\n     */\n    count: number = 0;\n\n    /**\n     * The current buffer offset.\n     *\n     * @type {number}\n     */\n    offset: number = 0;\n\n    /**\n     * The number of elements per entry in the buffer.\n     *\n     * This is 3 for a tri and 4 for a quad in an indexed buffer.\n     *\n     * @type {number}\n     */\n    elementsPerEntry: number;\n\n    isBound: boolean = false;\n\n    constructor (config: IVertexBufferConfig = {})\n    {\n        const {\n            name = 'VBO',\n            batchSize = 1,\n            dataSize = 4,\n            isDynamic = true,\n            elementsPerEntry = 3,\n            vertexElementSize = 9\n        } = config;\n\n        this.name = name;\n        this.batchSize = batchSize;\n        this.dataSize = dataSize;\n        this.vertexElementSize = vertexElementSize;\n        this.isDynamic = isDynamic;\n        this.elementsPerEntry = elementsPerEntry;\n\n        //  Derive the remaining values\n        this.vertexByteSize = vertexElementSize * dataSize;\n        this.entryByteSize = this.vertexByteSize * elementsPerEntry;\n        this.bufferByteSize = batchSize * this.entryByteSize;\n        this.entryElementSize = this.vertexElementSize * this.elementsPerEntry;\n\n        this.create();\n    }\n\n    resize (batchSize: number): void\n    {\n        this.batchSize = batchSize;\n        this.bufferByteSize = batchSize * this.entryByteSize;\n\n        if (this.vertexBuffer)\n        {\n            DeleteGLBuffer(this.vertexBuffer);\n        }\n\n        this.create();\n    }\n\n    create (): void\n    {\n        const data = new ArrayBuffer(this.bufferByteSize);\n\n        this.data = data;\n\n        this.vertexViewF32 = new Float32Array(data);\n\n        this.vertexBuffer = gl.createBuffer();\n\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n\n        const type = (this.isDynamic) ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;\n\n        gl.bufferData(gl.ARRAY_BUFFER, data, type);\n\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\n\n        this.isBound = false;\n    }\n\n    add (count: number): void\n    {\n        this.count += count;\n        this.offset += (this.vertexElementSize * count);\n    }\n\n    reset (): void\n    {\n        this.count = 0;\n        this.offset = 0;\n    }\n\n    canContain (count: number): boolean\n    {\n        return ((this.count + count) <= this.batchSize);\n    }\n\n    free (): number\n    {\n        return Math.max(0, 1 - (this.count / this.batchSize));\n    }\n\n    bind (): void\n    {\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n    }\n\n    destroy (): void\n    {\n        DeleteGLBuffer(this.vertexBuffer);\n\n        this.data = null;\n        this.vertexViewF32 = null;\n        this.vertexBuffer = null;\n    }\n}\n", "import { IRenderPass } from './IRenderPass';\nimport { IVertexBuffer } from '../buffers/IVertexBuffer';\nimport { gl } from '../GL';\n\nexport class VertexBufferStack\n{\n    renderPass: IRenderPass;\n\n    stack: IVertexBuffer[];\n    active: IVertexBuffer;\n    default: IVertexBuffer;\n    index: number;\n\n    constructor (renderPass: IRenderPass)\n    {\n        this.renderPass = renderPass;\n        this.stack = [];\n    }\n\n    get current (): IVertexBuffer\n    {\n        return this.stack[this.index];\n    }\n\n    add (buffer: IVertexBuffer): IVertexBuffer\n    {\n        this.index++;\n\n        //  cursor already at the end of the stack, so we need to grow it\n        if (this.index === this.stack.length)\n        {\n            this.stack.push(buffer);\n        }\n        else\n        {\n            this.stack[this.index] = buffer;\n        }\n\n        return buffer;\n    }\n\n    bindDefault (): void\n    {\n        this.index = 0;\n\n        this.bind(this.default);\n    }\n\n    bind (buffer?: IVertexBuffer): void\n    {\n        if (!buffer)\n        {\n            buffer = this.current;\n        }\n\n        if (!buffer.isBound)\n        {\n            const indexBuffer = (buffer.indexed) ? buffer.indexBuffer : null;\n\n            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);\n\n            gl.bindBuffer(gl.ARRAY_BUFFER, buffer.vertexBuffer);\n\n            buffer.isBound = true;\n\n            if (this.active && this.active !== buffer)\n            {\n                this.active.isBound = false;\n            }\n\n            this.active = buffer;\n        }\n    }\n\n    pop (): void\n    {\n        this.index--;\n\n        this.bind();\n    }\n\n    set (buffer: IVertexBuffer): void\n    {\n        const entry = this.add(buffer);\n\n        this.bind(entry);\n    }\n\n    setDefault (buffer: IVertexBuffer): void\n    {\n        //  The default entry always goes into index zero\n        this.stack[0] = buffer;\n\n        this.index = 0;\n\n        this.default = buffer;\n    }\n}\n", "/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\nimport { IRectangle } from './IRectangle';\n\n/**\n * Checks if a given point is inside a Rectangle's bounds.\n */\nexport function RectangleContains (rect: IRectangle, x: number, y: number): boolean\n{\n    if (rect.width <= 0 || rect.height <= 0)\n    {\n        return false;\n    }\n\n    return (rect.x <= x && rect.x + rect.width >= x && rect.y <= y && rect.y + rect.height >= y);\n}\n", "/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\nimport { RectangleContains } from './RectangleContains';\n\nexport class Rectangle\n{\n    x: number;\n    y: number;\n    width: number;\n    height: number;\n\n    constructor (x: number = 0, y: number = 0, width: number = 0, height: number = 0)\n    {\n        this.set(x, y, width, height);\n    }\n\n    set (x: number = 0, y: number = 0, width: number = 0, height: number = 0): this\n    {\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n\n        return this;\n    }\n\n    contains (x: number, y: number): boolean\n    {\n        return RectangleContains(this, x, y);\n    }\n\n    set right (value: number)\n    {\n        if (value <= this.x)\n        {\n            this.width = 0;\n        }\n        else\n        {\n            this.width = value - this.x;\n        }\n    }\n\n    get right (): number\n    {\n        return this.x + this.width;\n    }\n\n    set bottom (value: number)\n    {\n        if (value <= this.y)\n        {\n            this.height = 0;\n        }\n        else\n        {\n            this.height = value - this.y;\n        }\n    }\n\n    get bottom (): number\n    {\n        return this.y + this.height;\n    }\n}\n", "/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\nimport { IRectangle } from './IRectangle';\n\n/**\n * Compares the `x`, `y`, `width` and `height` properties of two rectangles.\n */\nexport function RectangleEquals (rect: IRectangle, toCompare: IRectangle): boolean\n{\n    return (\n        rect.x === toCompare.x &&\n        rect.y === toCompare.y &&\n        rect.width === toCompare.width &&\n        rect.height === toCompare.height\n    );\n}\n", "import { IRenderPass } from './IRenderPass';\nimport { Rectangle } from '../../../geom/rectangle/Rectangle';\nimport { RectangleEquals } from '../../../geom/rectangle/RectangleEquals';\nimport { gl } from '../GL';\n\nexport class ViewportStack\n{\n    renderPass: IRenderPass;\n\n    stack: Rectangle[];\n    active: Rectangle;\n    default: Rectangle;\n    index: number;\n\n    constructor (renderPass: IRenderPass)\n    {\n        this.renderPass = renderPass;\n        this.stack = [];\n    }\n\n    get current (): Rectangle\n    {\n        return this.stack[this.index];\n    }\n\n    add (x: number = 0, y: number = 0, width: number = 0, height: number = 0): Rectangle\n    {\n        const entry = new Rectangle(x, y, width, height);\n\n        this.index++;\n\n        //  cursor already at the end of the stack, so we need to grow it\n        if (this.index === this.stack.length)\n        {\n            this.stack.push(entry);\n        }\n        else\n        {\n            this.stack[this.index] = entry;\n        }\n\n        return entry;\n    }\n\n    bindDefault (): void\n    {\n        this.index = 0;\n\n        this.bind(this.default);\n    }\n\n    bind (viewport?: Rectangle): void\n    {\n        if (!viewport)\n        {\n            viewport = this.current;\n        }\n\n        if (!this.active || !RectangleEquals(this.active, viewport))\n        {\n            gl.viewport(viewport.x, viewport.y, viewport.width, viewport.height);\n\n            this.active = viewport;\n        }\n    }\n\n    pop (): void\n    {\n        this.index--;\n\n        this.bind();\n    }\n\n    set (x: number = 0, y: number = 0, width: number = 0, height: number = 0): void\n    {\n        const entry = this.add(x, y, width, height);\n\n        this.bind(entry);\n    }\n\n    setDefault (x: number = 0, y: number = 0, width: number = 0, height: number = 0): void\n    {\n        const entry = new Rectangle(x, y, width, height);\n\n        //  The default entry always goes into index zero\n        this.stack[0] = entry;\n\n        this.index = 0;\n\n        this.default = entry;\n    }\n}\n", "import { DEFAULT_COLOR_MATRIX, DEFAULT_COLOR_OFFSET } from '../../../colormatrix/const';\n\nimport { BlendModeStack } from './BlendModeStack';\nimport { ColorMatrixStack } from './ColorMatrixStack';\nimport { FramebufferStack } from './FramebufferStack';\nimport { GetBatchSize } from '../../../config/batchsize/GetBatchSize';\nimport { GetMaxTextures } from '../../../config/maxtextures/GetMaxTextures';\nimport { IBaseCamera } from '../../../camera/IBaseCamera';\nimport { IRenderPass } from './IRenderPass';\nimport { IShader } from '../shaders/IShader';\nimport { IWebGLRenderer } from '../IWebGLRenderer';\nimport { Mat4Ortho } from '../../../math/mat4/Mat4Ortho';\nimport { MultiTextureQuadShader } from '../shaders/MultiTextureQuadShader';\nimport { QuadShader } from '../shaders/QuadShader';\nimport { ShaderStack } from './ShaderStack';\nimport { StaticCamera } from '../../../camera/StaticCamera';\nimport { TextureStack } from './TextureStack';\nimport { VertexBuffer } from '../buffers/VertexBuffer';\nimport { VertexBufferStack } from './VertexBufferStack';\nimport { ViewportStack } from './ViewportStack';\n\nexport class RenderPass implements IRenderPass\n{\n    renderer: IWebGLRenderer;\n\n    projectionMatrix: Float32Array;\n    cameraMatrix: Float32Array;\n\n    count: number = 0;\n    prevCount: number = 0;\n    flushTotal: number = 0;\n\n    //  Stacks\n    framebuffer: FramebufferStack;\n    vertexbuffer: VertexBufferStack;\n    blendMode: BlendModeStack;\n    shader: ShaderStack;\n    viewport: ViewportStack;\n    textures: TextureStack;\n    colorMatrix: ColorMatrixStack;\n\n    //  Single Texture Quad Shader + Camera\n    quadShader: IShader;\n    quadCamera: IBaseCamera;\n\n    //  Current 2D Camera\n    current2DCamera: IBaseCamera;\n\n    constructor (renderer: IWebGLRenderer)\n    {\n        this.renderer = renderer;\n\n        this.projectionMatrix = new Float32Array(16);\n\n        this.framebuffer = new FramebufferStack(this);\n        this.vertexbuffer = new VertexBufferStack(this);\n        this.blendMode = new BlendModeStack(this);\n        this.shader = new ShaderStack(this);\n        this.viewport = new ViewportStack(this);\n        this.textures = new TextureStack(this);\n        this.colorMatrix = new ColorMatrixStack(this);\n\n        this.reset();\n    }\n\n    getCurrentShader (): IShader\n    {\n        return this.shader.current.shader;\n    }\n\n    flush (): void\n    {\n        this.prevCount = this.count;\n\n        this.count = 0;\n\n        this.flushTotal++;\n    }\n\n    //  TODO - Call when context is lost and restored\n    //  TODO - If already created, delete shaders / buffers first (i.e. during context loss)\n    reset (): void\n    {\n        const gl = this.renderer.gl;\n\n        //  Default QuadShader (for FBO drawing)\n\n        this.quadShader = new QuadShader();\n        this.quadCamera = new StaticCamera(this.renderer.width, this.renderer.height);\n\n        //  Default settings\n\n        this.textures.setDefault();\n        this.framebuffer.setDefault();\n        this.blendMode.setDefault(true, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n        this.colorMatrix.setDefault(DEFAULT_COLOR_MATRIX, DEFAULT_COLOR_OFFSET);\n        this.vertexbuffer.setDefault(new VertexBuffer({ batchSize: GetBatchSize() }));\n        this.shader.setDefault((GetMaxTextures() === 1) ? new QuadShader() : new MultiTextureQuadShader());\n    }\n\n    resize (width: number, height: number): void\n    {\n        //  TODO - -1 to 1?\n        Mat4Ortho(this.projectionMatrix, 0, width, height, 0, -1000, 1000);\n\n        this.quadCamera.reset(width, height);\n\n        this.viewport.setDefault(0, 0, width, height);\n    }\n}\n", "import { IRenderPass } from './IRenderPass';\n\nexport function Start (renderPass: IRenderPass): IRenderPass\n{\n    if (!renderPass.current2DCamera)\n    {\n        renderPass.current2DCamera = renderPass.quadCamera;\n        renderPass.cameraMatrix = renderPass.quadCamera.getMatrix();\n    }\n\n    renderPass.count = 0;\n    renderPass.flushTotal = 0;\n\n    renderPass.framebuffer.bindDefault();\n    renderPass.blendMode.bindDefault();\n    renderPass.viewport.bindDefault();\n    renderPass.vertexbuffer.bindDefault();\n    renderPass.shader.bindDefault();\n    renderPass.colorMatrix.bindDefault();\n\n    return renderPass;\n}\n", "import { IRenderer } from './IRenderer';\n\nexport let instance: IRenderer;\n\nexport const RendererInstance =\n{\n    get: (): IRenderer =>\n    {\n        return instance;\n    },\n\n    set: (renderer: IRenderer | undefined): void =>\n    {\n        instance = renderer;\n    }\n};\n", "import { RendererInstance } from '../RendererInstance';\nimport { WebGLRenderer } from './WebGLRenderer';\n\nexport let instance: WebGLRenderer;\n\nexport const WebGLRendererInstance =\n{\n    get: (): WebGLRenderer =>\n    {\n        return instance;\n    },\n\n    set: (renderer: WebGLRenderer | undefined): void =>\n    {\n        instance = renderer;\n        RendererInstance.set(renderer);\n    }\n};\n", "import { End } from './renderpass/End';\nimport { GL } from './GL';\nimport { GetBackgroundColor } from '../../config/backgroundcolor/GetBackgroundColor';\nimport { GetCompressedTextures } from './textures/GetCompressedTextures';\nimport { GetHeight } from '../../config/size/GetHeight';\nimport { GetRGBArray } from './colors/GetRGBArray';\nimport { GetResolution } from '../../config/size/GetResolution';\nimport { GetWebGLContext } from '../../config/webglcontext/GetWebGLContext';\nimport { GetWidth } from '../../config/size/GetWidth';\nimport { ICompressedTextures } from './textures/ICompressedTextures';\nimport { IRenderPass } from './renderpass/IRenderPass';\nimport { ProcessBindingQueue } from './renderpass/ProcessBindingQueue';\nimport { RenderPass } from './renderpass/RenderPass';\nimport { Start } from './renderpass/Start';\nimport { WebGLRendererInstance } from './WebGLRendererInstance';\n\nexport class WebGLRenderer\n{\n    canvas: HTMLCanvasElement;\n    gl: WebGLRenderingContext;\n\n    renderPass: IRenderPass;\n\n    clearColor = [ 0, 0, 0, 1 ];\n\n    width: number;\n    height: number;\n    resolution: number;\n\n    clearBeforeRender: boolean = true;\n    optimizeRedraw: boolean = true;\n    autoResize: boolean = true;\n\n    contextLost: boolean = false;\n\n    compression: ICompressedTextures;\n\n    constructor ()\n    {\n        this.width = GetWidth();\n        this.height = GetHeight();\n        this.resolution = GetResolution();\n\n        this.setBackgroundColor(GetBackgroundColor());\n\n        const canvas = document.createElement('canvas');\n\n        canvas.addEventListener('webglcontextlost', (event) => this.onContextLost(event), false);\n        canvas.addEventListener('webglcontextrestored', () => this.onContextRestored(), false);\n\n        this.canvas = canvas;\n\n        this.initContext();\n\n        //  By this stage the context is available\n        WebGLRendererInstance.set(this);\n\n        this.renderPass = new RenderPass(this);\n\n        this.resize(this.width, this.height, this.resolution);\n\n        //  Process default textures from the Texture Manager\n        ProcessBindingQueue();\n    }\n\n    initContext (): void\n    {\n        const gl = this.canvas.getContext('webgl', GetWebGLContext());\n\n        GL.set(gl);\n\n        this.gl = gl;\n\n        this.compression = GetCompressedTextures(gl);\n\n        gl.disable(gl.DEPTH_TEST);\n        gl.disable(gl.CULL_FACE);\n    }\n\n    resize (width: number, height: number, resolution: number = 1): void\n    {\n        const calcWidth = width * resolution;\n        const calcHeight = height * resolution;\n\n        this.width = calcWidth;\n        this.height = calcHeight;\n        this.resolution = resolution;\n\n        const canvas = this.canvas;\n\n        canvas.width = calcWidth;\n        canvas.height = calcHeight;\n\n        if (this.autoResize)\n        {\n            canvas.style.width = width.toString() + 'px';\n            canvas.style.height = height.toString() + 'px';\n        }\n\n        this.renderPass.resize(calcWidth, calcHeight);\n    }\n\n    onContextLost (event: Event): void\n    {\n        event.preventDefault();\n\n        this.contextLost = true;\n    }\n\n    onContextRestored (): void\n    {\n        this.contextLost = false;\n\n        this.initContext();\n    }\n\n    setBackgroundColor (color: number): this\n    {\n        GetRGBArray(color, this.clearColor);\n\n        return this;\n    }\n\n    //  TODO - Remove?\n    reset (): void\n    {\n        // this.renderPass.reset();\n    }\n\n    begin (willRedraw: boolean): IRenderPass\n    {\n        if (this.contextLost)\n        {\n            return;\n        }\n\n        const gl = this.gl;\n\n        //  This is only here because if we don't do _something_ with the context,\n        //  GL Spector can't see it!\n        gl.getContextAttributes();\n\n        ProcessBindingQueue();\n\n        //  Nothing dirty? Display the previous frame\n        if (this.optimizeRedraw && !willRedraw)\n        {\n            // return;\n        }\n\n        if (this.clearBeforeRender)\n        {\n            const cls = this.clearColor;\n\n            gl.clearColor(cls[0], cls[1], cls[2], cls[3]);\n            gl.clear(gl.COLOR_BUFFER_BIT);\n        }\n\n        return Start(this.renderPass);\n    }\n\n    end (): void\n    {\n        End(this.renderPass);\n\n        // eslint-disable-next-line no-debugger\n        // debugger;\n    }\n\n    destroy (): void\n    {\n        WebGLRendererInstance.set(undefined);\n    }\n}\n", "import { SetRenderer } from '../renderer/SetRenderer';\nimport { WebGLRenderer } from '../../renderer/webgl1/WebGLRenderer';\n\nexport function WebGL (): () => void\n{\n    return (): void =>\n    {\n        SetRenderer(WebGLRenderer);\n    };\n}\n", "import { CONFIG_DEFAULTS } from '../const';\nimport { ConfigStore } from '../ConfigStore';\n\nexport function SetWebGLContext (contextAttributes: WebGLContextAttributes): void\n{\n    ConfigStore.set(CONFIG_DEFAULTS.WEBGL_CONTEXT, contextAttributes);\n}\n", "import { CONFIG_DEFAULTS } from '../const';\nimport { ConfigStore } from '../ConfigStore';\n\n//  Set the maximum width and depth a single World can be.\n//  These values  are the total number of Game Objects allowed per width and the total depth of nesting they can have.\n//  It is NOT the pixel size of the world.\n\nexport function SetWorldSize (width: number = 17592186, height: number = 512): void\n{\n    if (width * height > 9007199254)\n    {\n        throw new Error('Invalid world size');\n    }\n\n    ConfigStore.set(CONFIG_DEFAULTS.WORLD_WIDTH, width);\n    ConfigStore.set(CONFIG_DEFAULTS.WORLD_HEIGHT, height);\n    ConfigStore.set(CONFIG_DEFAULTS.WORLD_SIZE, width * height);\n}\n", "import { IEventEmitter } from './IEventEmitter';\nimport { IEventInstance } from './IEventInstance';\n\nexport function Emit (emitter: IEventEmitter, event: string, ...args: unknown[]): boolean\n{\n    if (emitter.events.size === 0 || !emitter.events.has(event))\n    {\n        return false;\n    }\n\n    const listeners: Set<IEventInstance> = emitter.events.get(event);\n\n    //  Convert to an array so the callbacks cannot impact what we're iterating\n    //  It works, but generates gc\n    const handlers = [ ...listeners ];\n\n    for (const ee of handlers)\n    {\n        ee.callback.apply(ee.context, args);\n\n        if (ee.once)\n        {\n            listeners.delete(ee);\n        }\n    }\n\n    if (listeners.size === 0)\n    {\n        emitter.events.delete(event);\n    }\n\n    return true;\n}\n", "import { Emit } from '../../events/Emit';\nimport { IEventInstance } from '../../events/IEventInstance';\nimport { IKey } from './IKey';\n\nexport class Key implements IKey\n{\n    //  The KeyEvent.key identifier\n    readonly value: string;\n\n    events: Map<string, Set<IEventInstance>>;\n\n    //  Will it invoke preventDefault?\n    capture: boolean = true;\n\n    //  Is it currently down?\n    isDown: boolean = false;\n\n    //  Process this key?\n    enabled: boolean = true;\n\n    //  rate of repeats in ms\n    repeatRate: number = 0;\n\n    //  Can this key repeat, or do you have to release it before pressing again\n    canRepeat: boolean = true;\n\n    //  The game time this key was last pressed down\n    timeDown: number = 0;\n\n    //  The game time this key was last updated (i.e. if down and repeating)\n    timeUpdated: number = 0;\n\n    //  The game time this key was last released\n    timeUp: number = 0;\n\n    shiftKey: boolean;\n    ctrlKey: boolean;\n    altKey: boolean;\n\n    downCallback: (key: IKey) => void;\n    upCallback: (key: IKey) => void;\n\n    constructor (value: string)\n    {\n        this.value = value;\n        this.events = new Map();\n    }\n\n    getValue (): string\n    {\n        return this.value;\n    }\n\n    down (event: KeyboardEvent): void\n    {\n        if (!this.enabled)\n        {\n            return;\n        }\n\n        if (this.capture)\n        {\n            event.preventDefault();\n        }\n\n        this.shiftKey = event.shiftKey;\n        this.ctrlKey = event.ctrlKey;\n        this.altKey = event.altKey;\n\n        if (this.isDown && this.canRepeat)\n        {\n            this.timeUpdated = event.timeStamp;\n\n            const delay = this.timeUpdated - this.timeDown;\n\n            //  Key is repeating\n            if (delay >= this.repeatRate)\n            {\n                Emit(this, 'keydown', this);\n\n                if (this.downCallback)\n                {\n                    this.downCallback(this);\n                }\n            }\n        }\n        else\n        {\n            //  Key is first down\n            this.isDown = true;\n\n            this.timeDown = event.timeStamp;\n            this.timeUpdated = event.timeStamp;\n\n            Emit(this, 'keydown', this);\n\n            if (this.downCallback)\n            {\n                this.downCallback(this);\n            }\n        }\n    }\n\n    up (event: KeyboardEvent): void\n    {\n        if (!this.enabled)\n        {\n            return;\n        }\n\n        if (this.capture)\n        {\n            event.preventDefault();\n        }\n\n        this.shiftKey = event.shiftKey;\n        this.ctrlKey = event.ctrlKey;\n        this.altKey = event.altKey;\n\n        if (this.isDown)\n        {\n            //  Key is up\n            this.isDown = false;\n            this.timeUp = event.timeStamp;\n            this.timeUpdated = event.timeStamp;\n\n            Emit(this, 'keyup', this);\n\n            if (this.upCallback)\n            {\n                this.upCallback(this);\n            }\n        }\n    }\n\n    reset (): void\n    {\n        this.isDown = false;\n        this.timeUpdated = this.timeDown;\n        this.timeUp = this.timeDown;\n    }\n\n    destroy (): void\n    {\n        this.downCallback = null;\n        this.upCallback = null;\n\n        this.events.clear();\n    }\n}\n", "import { Key } from '../Key';\n\nexport class DownKey extends Key\n{\n    constructor ()\n    {\n        super('ArrowDown');\n    }\n}\n", "import { Key } from '../Key';\n\nexport class LeftKey extends Key\n{\n    constructor ()\n    {\n        super('ArrowLeft');\n    }\n}\n", "import { Key } from '../Key';\n\nexport class RightKey extends Key\n{\n    constructor ()\n    {\n        super('ArrowRight');\n    }\n}\n", "import { Key } from '../Key';\n\nexport class UpKey extends Key\n{\n    constructor ()\n    {\n        super('ArrowUp');\n    }\n}\n", "import { Types, defineComponent } from 'bitecs';\n\n//  world = The ID of the World entity the owner of this component belongs to\n//  parent = The ID of the Parent entity. If it has no parent, will match the world ID\n//  index = The position of this entity compared to its siblings, i.e. index 0 is at the back, index 1 above that, etc\n//  next = The ID of the next entity in the display list (horizontally, the next sibling)\n//  prev = The ID of the previous entity in the display list (horizontally, the previous sibling)\n//  first = The ID of the left-most (first) child entity of this parent\n//  last = The ID of the right-most (last) child entity of this parent\n//  numChildren = The number of direct descendants this entity has\n//  depth = Reserved to allow for per-child depth sorting outside of the display list index\n\nconst Hierarchy = defineComponent({\n    world: Types.ui32,\n    parent: Types.ui32,\n    index: Types.ui32,\n    next: Types.ui32,\n    prev: Types.ui32,\n    first: Types.ui32,\n    last: Types.ui32,\n    numChildren: Types.ui32,\n    depth: Types.ui32\n});\n\nexport const HierarchyComponent = Hierarchy;\n", "import { HierarchyComponent } from './HierarchyComponent';\n\nexport function ClearHierarchyComponent (id: number): void\n{\n    HierarchyComponent.world[id] = 0;\n    HierarchyComponent.parent[id] = 0;\n    HierarchyComponent.index[id] = 0;\n    HierarchyComponent.next[id] = 0;\n    HierarchyComponent.prev[id] = 0;\n    HierarchyComponent.first[id] = 0;\n    HierarchyComponent.last[id] = 0;\n    HierarchyComponent.numChildren[id] = 0;\n}\n", "import { HierarchyComponent } from './HierarchyComponent';\n\nexport function GetLastChildID (id: number): number\n{\n    return HierarchyComponent.last[id];\n}\n", "import { HierarchyComponent } from './HierarchyComponent';\n\nexport function GetNumChildren (id: number): number\n{\n    return HierarchyComponent.numChildren[id];\n}\n", "import { IGameObject } from './IGameObject';\n\nexport const GameObjectCache = {\n\n    local: <IGameObject[]>[],\n\n    set: function (index: number, object: IGameObject): void\n    {\n        this.local[index] = object;\n    },\n\n    get: function (index: number): IGameObject\n    {\n        return this.local[index];\n    },\n\n    clear: function (): void\n    {\n        this.local.length = 0;\n    },\n\n    remove: function (index: number): void\n    {\n        this.local[index] = null;\n    }\n};\n", "import { HierarchyComponent } from './HierarchyComponent';\n\nexport function GetWorldID (id: number): number\n{\n    return HierarchyComponent.world[id];\n}\n", "import { GameObjectCache } from '../../gameobjects/GameObjectCache';\nimport { GetWorldID } from './GetWorldID';\nimport { IBaseWorld } from '../../world/IBaseWorld';\n\nexport function GetWorldFromParentID (parentID: number): IBaseWorld | undefined\n{\n    const worldID = GetWorldID(parentID);\n\n    return GameObjectCache.get(worldID) as IBaseWorld;\n}\n", "import { HierarchyComponent } from './HierarchyComponent';\n\nexport function GetParentID (id: number): number\n{\n    return HierarchyComponent.parent[id];\n}\n", "import { GetParentID } from '../components/hierarchy/GetParentID';\nimport { IGameObject } from '../gameobjects/IGameObject';\n\nexport function IsValidParent <P extends IGameObject, C extends IGameObject> (parent: P, child: C): boolean\n{\n    //  It's not a valid parent if the ID matches the parent, or it's already the child's parent\n    return !(child.id === parent.id || parent.id === GetParentID(child.id));\n}\n", "import { GetParentID } from './GetParentID';\n\nexport function GetParents (id: number): number[]\n{\n    const results = [];\n\n    let currentParent = GetParentID(id);\n\n    while (currentParent)\n    {\n        results.push(currentParent);\n\n        currentParent = GetParentID(currentParent);\n    }\n\n    return results;\n}\n", "import { DirtyComponent } from './DirtyComponent';\n\nexport function SetDirtyChild (id: number): void\n{\n    DirtyComponent.child[id] = 1;\n}\n", "import { DirtyComponent } from './DirtyComponent';\n\nexport function SetDirtyChildCache (id: number): void\n{\n    DirtyComponent.childCache[id] = 1;\n}\n", "import { Types, defineComponent } from 'bitecs';\n\nconst Permissions = defineComponent({\n    visible: Types.ui8,\n    visibleChildren: Types.ui8,\n    willUpdate: Types.ui8,\n    willUpdateChildren: Types.ui8,\n    willRender: Types.ui8,\n    willRenderChildren: Types.ui8,\n    willCacheChildren: Types.ui8,\n    willTransformChildren: Types.ui8,\n    willColorChildren: Types.ui8\n});\n\nexport const PermissionsComponent = Permissions;\n", "import { PermissionsComponent } from './PermissionsComponent';\n\nexport function WillCacheChildren (id: number): boolean\n{\n    return Boolean(PermissionsComponent.willCacheChildren[id]);\n}\n", "import { PermissionsComponent } from './PermissionsComponent';\n\nexport function WillTransformChildren (id: number): boolean\n{\n    return Boolean(PermissionsComponent.willTransformChildren[id]);\n}\n", "import { GetParents } from '../hierarchy/GetParents';\nimport { SetDirtyChild } from './SetDirtyChild';\nimport { SetDirtyChildCache } from './SetDirtyChildCache';\nimport { SetDirtyTransform } from './SetDirtyTransform';\nimport { WillCacheChildren } from '../permissions/WillCacheChildren';\nimport { WillTransformChildren } from '../permissions/WillTransformChildren';\n\nexport function SetDirtyParents (childID: number): void\n{\n    const parents = GetParents(childID);\n\n    parents.forEach(id =>\n    {\n        SetDirtyChild(id);\n\n        if (WillTransformChildren(id))\n        {\n            SetDirtyTransform(id);\n        }\n\n        if (WillCacheChildren(id))\n        {\n            SetDirtyChildCache(id);\n        }\n    });\n}\n", "import { HierarchyComponent } from './HierarchyComponent';\n\nexport function SetFirstChildID (parentID: number, childID: number): void\n{\n    HierarchyComponent.first[parentID] = childID;\n}\n", "import { HierarchyComponent } from './HierarchyComponent';\n\nexport function SetIndex (id: number, index: number): void\n{\n    HierarchyComponent.index[id] = index;\n}\n", "import { HierarchyComponent } from './HierarchyComponent';\n\nexport function SetLastChildID (parentID: number, childID: number): void\n{\n    HierarchyComponent.last[parentID] = childID;\n}\n", "import { HierarchyComponent } from './HierarchyComponent';\n\nexport function SetNextSiblingID (parentID: number, childID: number): void\n{\n    HierarchyComponent.next[parentID] = childID;\n}\n", "import { GameObjectTree } from '../../gameobjects/GameObjectTree';\nimport { HierarchyComponent } from './HierarchyComponent';\n\nexport function SetNumChildren (parentID: number, total: number): void\n{\n    // HierarchyComponent.numChildren[id] = GameObjectTree.get(id).length;\n    HierarchyComponent.numChildren[parentID] = total;\n}\n", "import { HierarchyComponent } from './HierarchyComponent';\n\nexport function SetParentID (childID: number, parentID: number): void\n{\n    HierarchyComponent.parent[childID] = parentID;\n}\n", "import { HierarchyComponent } from './HierarchyComponent';\n\nexport function SetPreviousSiblingID (parentID: number, childID: number): void\n{\n    HierarchyComponent.prev[parentID] = childID;\n}\n", "import { DirtyComponent } from './DirtyComponent';\n\nexport function SetDirtyDisplayList (id: number): void\n{\n    DirtyComponent.displayList[id] = 1;\n}\n", "import { GameObjectCache } from '../gameobjects/GameObjectCache';\nimport { GameObjectWorld } from '../GameObjectWorld';\nimport { HierarchyComponent } from '../components/hierarchy/HierarchyComponent';\nimport { IBaseWorld } from '../world/IBaseWorld';\nimport { SetDirtyDisplayList } from '../components/dirty/SetDirtyDisplayList';\nimport { removeComponent } from 'bitecs';\n\nexport function ClearWorld (childID: number): void\n{\n    const worldID = HierarchyComponent.world[childID];\n\n    const world = GameObjectCache.get(worldID) as IBaseWorld;\n\n    removeComponent(GameObjectWorld, world.tag, childID);\n\n    HierarchyComponent.world[childID] = 0;\n\n    SetDirtyDisplayList(worldID);\n}\n", "import { HierarchyComponent } from './HierarchyComponent';\n\nexport function GetFirstChildID (id: number): number\n{\n    return HierarchyComponent.first[id];\n}\n", "import { HierarchyComponent } from './HierarchyComponent';\n\nexport function GetNextSiblingID (id: number): number\n{\n    return HierarchyComponent.next[id];\n}\n", "import { GetFirstChildID } from './GetFirstChildID';\nimport { GetNextSiblingID } from './GetNextSiblingID';\nimport { GetParentID } from './GetParentID';\n\nexport function MoveNext (id: number, rootID: number): number\n{\n    //  Does 'id' have any children of its own?\n    const firstChild = GetFirstChildID(id);\n\n    if (firstChild > 0)\n    {\n        return firstChild;\n    }\n    else\n    {\n        const sibling = GetNextSiblingID(id);\n\n        if (sibling === 0)\n        {\n            //  No more children, how about from the parent?\n            const parent = GetParentID(id);\n\n            if (parent === rootID)\n            {\n                //  We're at the end of the list\n                return 0;\n            }\n            else\n            {\n                return GetNextSiblingID(parent);\n            }\n        }\n        else\n        {\n            return sibling;\n        }\n    }\n}\n", "import { GameObjectTree } from '../../gameobjects/GameObjectTree';\nimport { GetFirstChildID } from './GetFirstChildID';\nimport { MoveNext } from './MoveNext';\n\n//  Returns ALL child IDs based on the given Parent, to any depth\n\nexport function DepthFirstSearchFromParentID (parentID: number, removeParent: boolean = true): number[]\n{\n    const output: number[] = [ parentID ];\n\n    let next = GetFirstChildID(parentID);\n\n    while (next > 0)\n    {\n        output.push(next);\n\n        next = MoveNext(next, parentID);\n    }\n\n    /*\n    while (stack.length > 0)\n    {\n        const node = stack.shift();\n\n        output.push(node);\n\n        const nodeChildren = GameObjectTree.get(node);\n\n        const numChildren = nodeChildren.length;\n\n        if (numChildren > 0)\n        {\n            for (let i = numChildren - 1; i >= 0; i--)\n            {\n                stack.unshift(nodeChildren[i]);\n            }\n        }\n    }\n    */\n\n    //  Remove the parent from the results\n    if (removeParent)\n    {\n        output.shift();\n    }\n\n    return output;\n}\n", "import { ClearWorld } from './ClearWorld';\nimport { DepthFirstSearchFromParentID } from '../components/hierarchy/DepthFirstSearchFromParentID';\nimport { GameObjectWorld } from '../GameObjectWorld';\nimport { HierarchyComponent } from '../components/hierarchy/HierarchyComponent';\nimport { IBaseWorld } from '../world/IBaseWorld';\nimport { IGameObject } from '../gameobjects/IGameObject';\nimport { SetDirtyDisplayList } from '../components/dirty/SetDirtyDisplayList';\nimport { addComponent } from 'bitecs';\n\nexport function SetWorld <W extends IBaseWorld> (world: W, ...entries: IGameObject[]): IGameObject[]\n{\n    const worldID = world.id;\n    const worldTag = world.tag;\n\n    entries.forEach(entry =>\n    {\n        const children = DepthFirstSearchFromParentID(entry.id, false);\n\n        children.map(id =>\n        {\n            const currentWorldID = HierarchyComponent.world[id];\n\n            if (currentWorldID > 0 && currentWorldID !== worldID)\n            {\n                //  Remove from existing world\n                ClearWorld(id);\n            }\n\n            if (currentWorldID !== worldID)\n            {\n                addComponent(GameObjectWorld, worldTag, id);\n\n                HierarchyComponent.world[id] = worldID;\n            }\n        });\n    });\n\n    SetDirtyDisplayList(worldID);\n\n    return entries;\n}\n", "import { ClearHierarchyComponent } from '../components/hierarchy/ClearHierarchyComponent';\nimport { GetLastChildID } from '../components/hierarchy/GetLastChildID';\nimport { GetNumChildren } from '../components/hierarchy/GetNumChildren';\nimport { GetWorldFromParentID } from '../components/hierarchy/GetWorldFromParentID';\nimport { IGameObject } from '../gameobjects/IGameObject';\nimport { IsValidParent } from './IsValidParent';\nimport { SetDirtyParents } from '../components/dirty/SetDirtyParents';\nimport { SetDirtyTransform } from '../components/dirty/SetDirtyTransform';\nimport { SetFirstChildID } from '../components/hierarchy/SetFirstChildID';\nimport { SetIndex } from '../components/hierarchy/SetIndex';\nimport { SetLastChildID } from '../components/hierarchy/SetLastChildID';\nimport { SetNextSiblingID } from '../components/hierarchy/SetNextSiblingID';\nimport { SetNumChildren } from '../components/hierarchy/SetNumChildren';\nimport { SetParentID } from '../components/hierarchy/SetParentID';\nimport { SetPreviousSiblingID } from '../components/hierarchy/SetPreviousSiblingID';\nimport { SetWorld } from './SetWorld';\n\nexport function AddChild <P extends IGameObject, C extends IGameObject> (parent: P, child: C): C\n{\n    if (IsValidParent(parent, child))\n    {\n        const childID = child.id;\n        const parentID = parent.id;\n        const numChildren = GetNumChildren(parentID);\n        const world = GetWorldFromParentID(parentID);\n\n        ClearHierarchyComponent(childID);\n\n        //  RemoveChild from previous parent (if any)\n\n        if (numChildren === 0)\n        {\n            SetIndex(childID, 0);\n            SetFirstChildID(parentID, childID);\n        }\n        else\n        {\n            const lastChild = GetLastChildID(parentID);\n\n            SetNextSiblingID(lastChild, childID);\n            SetPreviousSiblingID(childID, lastChild);\n            SetIndex(childID, numChildren);\n        }\n\n        SetParentID(childID, parentID);\n        SetDirtyTransform(childID);\n        SetDirtyParents(childID);\n\n        SetLastChildID(parentID, childID);\n        SetNumChildren(parentID, numChildren + 1);\n\n        if (world)\n        {\n            SetWorld(world, child);\n        }\n    }\n\n    return child;\n}\n", "import { ClearHierarchyComponent } from '../components/hierarchy/ClearHierarchyComponent';\nimport { GameObjectTree } from '../gameobjects/GameObjectTree';\nimport { GetLastChildID } from '../components/hierarchy/GetLastChildID';\nimport { GetNumChildren } from '../components/hierarchy/GetNumChildren';\nimport { GetWorldFromParentID } from '../components/hierarchy/GetWorldFromParentID';\nimport { IGameObject } from '../gameobjects/IGameObject';\nimport { IsValidParent } from './IsValidParent';\nimport { RemoveChild } from './RemoveChild';\nimport { SetDirtyParents } from '../components/dirty/SetDirtyParents';\nimport { SetDirtyTransform } from '../components/dirty/SetDirtyTransform';\nimport { SetFirstChildID } from '../components/hierarchy/SetFirstChildID';\nimport { SetIndex } from '../components/hierarchy/SetIndex';\nimport { SetLastChildID } from '../components/hierarchy/SetLastChildID';\nimport { SetNextSiblingID } from '../components/hierarchy/SetNextSiblingID';\nimport { SetNumChildren } from '../components/hierarchy/SetNumChildren';\nimport { SetParentID } from '../components/hierarchy/SetParentID';\nimport { SetPreviousSiblingID } from '../components/hierarchy/SetPreviousSiblingID';\nimport { SetWorld } from './SetWorld';\nimport { UpdateIndexes } from '../components/hierarchy/UpdateIndexes';\n\nexport function AddChildAt <P extends IGameObject, C extends IGameObject> (parent: P, child: C, index: number): C\n{\n    if (IsValidParent(parent, child))\n    {\n        const childID = child.id;\n        const parentID = parent.id;\n        const numChildren = GetNumChildren(parentID);\n        const world = GetWorldFromParentID(parentID);\n\n        ClearHierarchyComponent(childID);\n\n        //  Adding to the right-most part of the parent\n        if (index === -1)\n        {\n            if (numChildren === 0)\n            {\n                SetIndex(childID, 0);\n                SetFirstChildID(parentID, childID);\n                SetLastChildID(parentID, childID);\n            }\n            else\n            {\n                const lastChild = GetLastChildID(parentID);\n\n                SetNextSiblingID(lastChild, childID);\n                SetPreviousSiblingID(childID, lastChild);\n                SetIndex(childID, numChildren);\n                SetLastChildID(parentID, childID);\n            }\n\n            SetParentID(childID, parentID);\n            SetNumChildren(parentID, numChildren + 1);\n            SetDirtyTransform(childID);\n        }\n        else\n        {\n            //  TODO\n        }\n\n        SetDirtyParents(childID);\n\n        if (world)\n        {\n            SetWorld(world, child);\n        }\n\n        /*\n        const children = GameObjectTree.get(parentID);\n\n        if (index === -1)\n        {\n            index = children.length;\n        }\n\n        if (index >= 0 && index <= children.length)\n        {\n            RemoveChild(child.getParent(), child);\n\n            //  Always modify the array before calling SetParentID\n            children.splice(index, 0, childID);\n\n            SetParentID(childID, parentID);\n\n            UpdateIndexes(childID);\n\n            SetDirtyParents(childID);\n\n            if (world)\n            {\n                SetWorld(world, child);\n            }\n        }\n        */\n    }\n\n    return child;\n}\n", "import { HierarchyComponent } from '../components/hierarchy/HierarchyComponent';\nimport { IGameObject } from '../gameobjects/IGameObject';\n\nexport function GetChildIndex <T extends IGameObject> (child: T): number\n{\n    return HierarchyComponent.index[child.id];\n}\n", "export const GameObjectTree = {\n\n    local: <Array<number[]>>[],\n\n    set: function (index: number, object: number[]): void\n    {\n        this.local[index] = object;\n    },\n\n    get: function (index: number): number[]\n    {\n        return this.local[index];\n    },\n\n    clear: function (): void\n    {\n        this.local.length = 0;\n    },\n\n    remove: function (index: number): void\n    {\n        this.local[index] = null;\n    }\n};\n", "import { DirtyComponent } from './DirtyComponent';\nimport { HierarchyComponent } from '../hierarchy/HierarchyComponent';\n\nexport function SetDirtyWorldDisplayList (id: number): void\n{\n    const worldID = HierarchyComponent.world[id];\n\n    DirtyComponent.displayList[worldID] = 1;\n}\n", "import { GameObjectCache } from '../../gameobjects/GameObjectCache';\nimport { GameObjectTree } from '../../gameobjects/GameObjectTree';\nimport { IGameObject } from '../../gameobjects/IGameObject';\n\nexport function GetChildrenFromParentID (id: number): IGameObject[]\n{\n    const out: IGameObject[] = [];\n\n    GameObjectTree.get(id).forEach(childID =>\n    {\n        out.push(GameObjectCache.get(childID));\n    });\n\n    return out;\n}\n", "import { GameObjectTree } from '../../gameobjects/GameObjectTree';\nimport { HierarchyComponent } from './HierarchyComponent';\n\nexport function UpdateNumChildren (id: number): void\n{\n    HierarchyComponent.numChildren[id] = GameObjectTree.get(id).length;\n}\n", "import { hasComponent, removeComponent } from 'bitecs';\n\nimport { GameObjectCache } from '../../gameobjects/GameObjectCache';\nimport { GameObjectWorld } from '../../GameObjectWorld';\nimport { GetParentID } from './GetParentID';\nimport { GetWorldID } from './GetWorldID';\nimport { HierarchyComponent } from './HierarchyComponent';\nimport { IBaseWorld } from '../../world/IBaseWorld';\nimport { SetDirtyParents } from '../dirty/SetDirtyParents';\nimport { UpdateNumChildren } from './UpdateNumChildren';\n\nexport function ClearWorldAndParentID (id: number): void\n{\n    const worldID = GetWorldID(id);\n    const parentID = GetParentID(id);\n    const world = GameObjectCache.get(worldID) as IBaseWorld;\n\n    HierarchyComponent.world[id] = 0;\n    HierarchyComponent.parent[id] = 0;\n\n    if (world && hasComponent(GameObjectWorld, world.tag, id))\n    {\n        removeComponent(GameObjectWorld, world.tag, id);\n    }\n\n    UpdateNumChildren(parentID);\n\n    SetDirtyParents(id);\n}\n", "import { GameObjectTree } from '../../gameobjects/GameObjectTree';\nimport { SetIndex } from './SetIndex';\n\nexport function UpdateChildIndexes (parentID: number): void\n{\n    const children = GameObjectTree.get(parentID);\n\n    for (let i = 0; i < children.length; i++)\n    {\n        SetIndex(children[i], i);\n    }\n}\n", "import { ClearWorldAndParentID } from '../components/hierarchy/ClearWorldAndParentID';\nimport { GameObjectCache } from '../gameobjects/GameObjectCache';\nimport { GameObjectTree } from '../gameobjects/GameObjectTree';\nimport { IGameObject } from '../gameobjects/IGameObject';\nimport { UpdateChildIndexes } from '../components/hierarchy/UpdateChildIndexes';\n\nexport function RemoveChildrenBetween <P extends IGameObject> (parent: P, beginIndex: number = 0, endIndex?: number): IGameObject[]\n{\n    const parentID = parent.id;\n\n    const children = GameObjectTree.get(parentID);\n\n    if (endIndex === undefined)\n    {\n        endIndex = children.length;\n    }\n\n    const range = endIndex - beginIndex;\n\n    if (range > 0 && range <= endIndex)\n    {\n        const removed = children.splice(beginIndex, range);\n\n        removed.forEach(childID =>\n        {\n            ClearWorldAndParentID(childID);\n        });\n\n        UpdateChildIndexes(parentID);\n\n        return removed.map(id => GameObjectCache.get(id));\n    }\n    else\n    {\n        return [];\n    }\n}\n", "import { IGameObject } from '../gameobjects/IGameObject';\nimport { RemoveChildrenBetween } from './RemoveChildrenBetween';\nimport { SetDirtyWorldDisplayList } from '../components/dirty/SetDirtyWorldDisplayList';\nimport { UpdateChildIndexes } from '../components/hierarchy/UpdateChildIndexes';\n\nexport function DestroyChildren <T extends IGameObject> (parent: T, beginIndex: number = 0, endIndex?: number): void\n{\n    const removed = RemoveChildrenBetween(parent, beginIndex, endIndex);\n\n    removed.forEach(child =>\n    {\n        child.destroy();\n    });\n\n    UpdateChildIndexes(parent.id);\n\n    SetDirtyWorldDisplayList(parent.id);\n}\n", "import { Types, defineComponent } from 'bitecs';\n\nexport const Transform2DComponent = defineComponent({\n    x: Types.f32,\n    y: Types.f32,\n    rotation: Types.f32,\n    scaleX: Types.f32,\n    scaleY: Types.f32,\n    skewX: Types.f32,\n    skewY: Types.f32,\n    originX: Types.f32,\n    originY: Types.f32,\n    local: [ Types.f32, 6 ],\n    world: [ Types.f32, 6 ]\n});\n", "import { Extent2DComponent } from './Extent2DComponent';\nimport { GameObjectWorld } from '../../GameObjectWorld';\nimport { Transform2DComponent } from './Transform2DComponent';\nimport { addComponent } from 'bitecs';\n\n//  The 'local' and 'world' arrays are Matrix2Ds and contains\n//  six elements in a short-form of the 3x3 Matrix, with the last column ignored:\n\n//  |----|----|----|\n//  | a  | b  | 0  |\n//  |----|----|----|\n//  | c  | d  | 0  |\n//  |----|----|----|\n//  | tx | ty | 1  |\n//  |----|----|----|\n\n//  [0] = a - X scale\n//  [1] = b - X skew\n//  [2] = c - Y skew\n//  [3] = d - Y scale\n//  [4] = tx - X translation\n//  [5] = ty - Y translation\n\nexport function AddTransform2DComponent (id: number, x: number = 0, y: number = 0, originX: number = 0, originY: number = 0): void\n{\n    addComponent(GameObjectWorld, Transform2DComponent, id);\n    addComponent(GameObjectWorld, Extent2DComponent, id);\n\n    //  Component defaults to zero, so we only need to set the other values\n\n    Transform2DComponent.x[id] = x;\n    Transform2DComponent.y[id] = y;\n    Transform2DComponent.scaleX[id] = 1;\n    Transform2DComponent.scaleY[id] = 1;\n    Transform2DComponent.originX[id] = originX;\n    Transform2DComponent.originY[id] = originY;\n\n    Transform2DComponent.local[id].set([ 1, 0, 0, 1, x, y ]);\n    Transform2DComponent.world[id].set([ 1, 0, 0, 1, x, y ]);\n}\n", "import { Types, defineComponent } from 'bitecs';\n\nconst Color = defineComponent({\n    r: Types.ui8c,\n    g: Types.ui8c,\n    b: Types.ui8c,\n    a: Types.f32,\n    colorMatrix: [ Types.f32, 16 ],\n    colorOffset: [ Types.f32, 4 ]\n});\n\nexport const ColorComponent = Color;\n", "import { ColorComponent } from './ColorComponent';\nimport { DEFAULT_COLOR_MATRIX } from '../../colormatrix/const';\nimport { GameObjectWorld } from '../../GameObjectWorld';\nimport { addComponent } from 'bitecs';\n\nexport function AddColorComponent (id: number): void\n{\n    addComponent(GameObjectWorld, ColorComponent, id);\n\n    ColorComponent.r[id] = 255;\n    ColorComponent.g[id] = 255;\n    ColorComponent.b[id] = 255;\n    ColorComponent.a[id] = 1;\n    ColorComponent.colorMatrix[id].set(DEFAULT_COLOR_MATRIX);\n}\n", "import { DirtyComponent } from './DirtyComponent';\n\nexport function SetDirtyColor (id: number): void\n{\n    DirtyComponent.color[id] = 1;\n}\n", "import { DirtyComponent } from './DirtyComponent';\nimport { GameObjectWorld } from '../../GameObjectWorld';\nimport { SetDirtyColor } from './SetDirtyColor';\nimport { SetDirtyTransform } from './SetDirtyTransform';\nimport { addComponent } from 'bitecs';\n\nexport function AddDirtyComponent (id: number): void\n{\n    addComponent(GameObjectWorld, DirtyComponent, id);\n\n    SetDirtyTransform(id);\n    SetDirtyColor(id);\n}\n", "import { DirtyComponent } from './DirtyComponent';\n\nexport function ClearDirtyChild (id: number): void\n{\n    DirtyComponent.child[id] = 0;\n}\n", "import { DirtyComponent } from './DirtyComponent';\n\nexport function ClearDirtyColor (id: number): void\n{\n    DirtyComponent.color[id] = 0;\n}\n", "import { DirtyComponent } from './DirtyComponent';\n\nexport function ClearDirtyDisplayList (id: number): void\n{\n    DirtyComponent.displayList[id] = 0;\n}\n", "import { DirtyComponent } from './DirtyComponent';\n\nexport function ClearDirtyTransform (id: number): void\n{\n    DirtyComponent.transform[id] = 0;\n}\n", "import { DirtyComponent } from './DirtyComponent';\n\nexport function HasDirtyChildCache (id: number): boolean\n{\n    return Boolean(DirtyComponent.childCache[id]);\n}\n", "import { DirtyComponent } from './DirtyComponent';\n\nexport function HasDirtyColor (id: number): boolean\n{\n    return Boolean(DirtyComponent.color[id]);\n}\n", "import { DirtyComponent } from './DirtyComponent';\n\nexport function HasDirtyDisplayList (id: number): boolean\n{\n    return Boolean(DirtyComponent.displayList[id]);\n}\n", "import { DirtyComponent } from './DirtyComponent';\n\nexport function HasDirtyTransform (id: number): boolean\n{\n    return Boolean(DirtyComponent.transform[id]);\n}\n", "import { AddColorComponent } from './AddColorComponent';\nimport { ColorComponent } from './ColorComponent';\nimport { PermissionsComponent } from '../permissions/PermissionsComponent';\nimport { SetDirtyColor } from '../dirty';\n\n//  red, green, blue in the range 0-255\n//  alpha in the range 0-1\n//  colorMatrix Float32Array of length 16, values are 0 to 1\n//  colorOffset Float32Array of length 4, values are integer\n\nexport class Color\n{\n    private id: number;\n\n    colorMatrixEnabled: boolean = false;\n\n    constructor (id: number, red: number = 255, green: number = 255, blue: number = 255, alpha: number = 1)\n    {\n        AddColorComponent(id);\n\n        this.id = id;\n\n        this.set(red, green, blue, alpha);\n    }\n\n    set (red: number, green: number, blue: number, alpha: number): void\n    {\n        this.red = red;\n        this.green = green;\n        this.blue = blue;\n        this.alpha = alpha;\n    }\n\n    //  In the range 0x000000 to 0xffffff (alpha is ignored)\n    set tint (value: number)\n    {\n        this.red = (value >> 16) & 0xff;\n        this.green = (value >> 8) & 0xff;\n        this.blue = value & 0xff;\n    }\n\n    get tint (): number\n    {\n        return this.red << 16 | this.green << 8 | this.blue;\n    }\n\n    set willColorChildren (value: boolean)\n    {\n        PermissionsComponent.willColorChildren[this.id] = Number(value);\n    }\n\n    get willColorChildren (): boolean\n    {\n        return Boolean(PermissionsComponent.willColorChildren[this.id]);\n    }\n\n    //  16 element array (4x4)\n    set colorMatrix (value: Float32List)\n    {\n        ColorComponent.colorMatrix[this.id].set(value);\n\n        SetDirtyColor(this.id);\n\n        this.colorMatrixEnabled = true;\n    }\n\n    get colorMatrix (): Float32Array\n    {\n        return ColorComponent.colorMatrix[this.id];\n    }\n\n    //  4 element array (vec4)\n    set colorOffset (value: Float32List)\n    {\n        ColorComponent.colorOffset[this.id].set(value);\n\n        SetDirtyColor(this.id);\n    }\n\n    get colorOffset (): Float32Array\n    {\n        return ColorComponent.colorOffset[this.id];\n    }\n\n    //  All in the range 0-255 or 0x00-0xFF\n    set red (value: number)\n    {\n        ColorComponent.r[this.id] = value;\n\n        SetDirtyColor(this.id);\n    }\n\n    get red (): number\n    {\n        return ColorComponent.r[this.id];\n    }\n\n    set green (value: number)\n    {\n        ColorComponent.g[this.id] = value;\n\n        SetDirtyColor(this.id);\n    }\n\n    get green (): number\n    {\n        return ColorComponent.g[this.id];\n    }\n\n    set blue (value: number)\n    {\n        ColorComponent.b[this.id] = value;\n\n        SetDirtyColor(this.id);\n    }\n\n    get blue (): number\n    {\n        return ColorComponent.b[this.id];\n    }\n\n    set alpha (value: number)\n    {\n        ColorComponent.a[this.id] = value;\n\n        SetDirtyColor(this.id);\n    }\n\n    get alpha (): number\n    {\n        return ColorComponent.a[this.id];\n    }\n}\n", "import { GameObjectWorld } from '../../GameObjectWorld';\nimport { HierarchyComponent } from './HierarchyComponent';\nimport { addComponent } from 'bitecs';\n\nexport function AddHierarchyComponent (id: number): void\n{\n    addComponent(GameObjectWorld, HierarchyComponent, id);\n}\n", "import { GameObjectWorld } from '../../GameObjectWorld';\nimport { PermissionsComponent } from './PermissionsComponent';\nimport { addComponent } from 'bitecs';\n\nexport function AddPermissionsComponent (id: number): void\n{\n    addComponent(GameObjectWorld, PermissionsComponent, id);\n\n    PermissionsComponent.visible[id] = 1;\n    PermissionsComponent.visibleChildren[id] = 1;\n    PermissionsComponent.willUpdate[id] = 1;\n    PermissionsComponent.willUpdateChildren[id] = 1;\n    PermissionsComponent.willRender[id] = 1;\n    PermissionsComponent.willRenderChildren[id] = 1;\n    PermissionsComponent.willCacheChildren[id] = 0;\n    PermissionsComponent.willTransformChildren[id] = 1;\n    PermissionsComponent.willColorChildren[id] = 1;\n}\n", "import { IGameObject } from '../IGameObject';\n\nexport const DestroyEvent: string = 'destroy';\n\nexport type DestroyEventHandler = <T extends IGameObject> (child: T) => void;\n", "import { GameObjectCache } from '../../gameobjects/GameObjectCache';\nimport { HierarchyComponent } from './HierarchyComponent';\nimport { IGameObject } from '../../gameobjects/IGameObject';\n\nexport function GetParentGameObject (id: number): IGameObject\n{\n    return GameObjectCache.get(HierarchyComponent.parent[id]);\n}\n", "import { PermissionsComponent } from './PermissionsComponent';\n\nexport function GetVisible (id: number): boolean\n{\n    return Boolean(PermissionsComponent.visible[id]);\n}\n", "import { PermissionsComponent } from './PermissionsComponent';\n\nexport function GetVisibleChildren (id: number): boolean\n{\n    return Boolean(PermissionsComponent.visibleChildren[id]);\n}\n", "import { AddChildAt } from './AddChildAt';\nimport { IGameObject } from '../gameobjects/IGameObject';\n\n//  Adds all of the children to the given parent\n//  If already a child of the parent, it is skipped\n//  If already child of another parent, it is removed from it first\n\nexport function SetParent <P extends IGameObject> (parent: P, ...children: IGameObject[]): IGameObject[]\n{\n    children.forEach(child =>\n    {\n        AddChildAt(parent, child);\n    });\n\n    return children;\n}\n", "import { IGameObject } from '../gameobjects/IGameObject';\nimport { RemoveChildrenBetween } from './RemoveChildrenBetween';\nimport { SetParent } from './SetParent';\n\nexport function ReparentChildren <P extends IGameObject, T extends IGameObject> (parent: P, newParent: T, beginIndex: number = 0, endIndex?: number): IGameObject[]\n{\n    const moved = RemoveChildrenBetween(parent, beginIndex, endIndex);\n\n    SetParent(newParent, ...moved);\n\n    return moved;\n}\n", "import { GetWorldID } from '../hierarchy/GetWorldID';\nimport { PermissionsComponent } from './PermissionsComponent';\nimport { SetDirtyDisplayList } from '../dirty/SetDirtyDisplayList';\nimport { SetDirtyParents } from '../dirty/SetDirtyParents';\n\nexport function SetVisible (value: boolean, id: number): void\n{\n    PermissionsComponent.visible[id] = Number(value);\n\n    SetDirtyParents(id);\n    SetDirtyDisplayList(GetWorldID(id));\n}\n", "import { GetWorldID } from '../hierarchy/GetWorldID';\nimport { PermissionsComponent } from './PermissionsComponent';\nimport { SetDirtyDisplayList } from '../dirty/SetDirtyDisplayList';\nimport { SetDirtyParents } from '../dirty/SetDirtyParents';\n\nexport function SetVisibleChildren (value: boolean, id: number): void\n{\n    PermissionsComponent.visibleChildren[id] = Number(value);\n\n    SetDirtyParents(id);\n    SetDirtyDisplayList(GetWorldID(id));\n}\n", "import { PermissionsComponent } from './PermissionsComponent';\n\nexport function WillRender (id: number): boolean\n{\n    return Boolean(PermissionsComponent.visible[id]) && Boolean(PermissionsComponent.willRender[id]);\n}\n", "import { AddDirtyComponent } from '../components/dirty/AddDirtyComponent';\nimport { AddHierarchyComponent } from '../components/hierarchy/AddHierarchyComponent';\nimport { AddPermissionsComponent } from '../components/permissions/AddPermissionsComponent';\nimport { DestroyChildren } from '../display/DestroyChildren';\nimport { DestroyEvent } from './events/DestroyEvent';\nimport { Emit } from '../events/Emit';\nimport { GameObjectCache } from './GameObjectCache';\nimport { GameObjectTree } from './GameObjectTree';\nimport { GameObjectWorld } from '../GameObjectWorld';\nimport { GetChildrenFromParentID } from '../components/hierarchy/GetChildrenFromParentID';\nimport { GetNumChildren } from '../components/hierarchy/GetNumChildren';\nimport { GetParentGameObject } from '../components/hierarchy/GetParentGameObject';\nimport { GetVisible } from '../components/permissions/GetVisible';\nimport { GetVisibleChildren } from '../components/permissions/GetVisibleChildren';\nimport { HierarchyComponent } from '../components/hierarchy/HierarchyComponent';\nimport { ICanvasRenderer } from '../renderer/canvas/ICanvasRenderer';\nimport { IEventInstance } from '../events/IEventInstance';\nimport { IGameObject } from './IGameObject';\nimport { IRenderPass } from '../renderer/webgl1/renderpass/IRenderPass';\nimport { ReparentChildren } from '../display/ReparentChildren';\nimport { SetVisible } from '../components/permissions/SetVisible';\nimport { SetVisibleChildren } from '../components/permissions/SetVisibleChildren';\nimport { WillRender } from '../components/permissions/WillRender';\nimport { WillUpdate } from '../components/permissions/WillUpdate';\nimport { WillUpdateChildren } from '../components/permissions/WillUpdateChildren';\nimport { addEntity } from 'bitecs';\n\nexport class GameObject implements IGameObject\n{\n    readonly id: number = addEntity(GameObjectWorld);\n\n    readonly type: string = 'GameObject';\n\n    //  User defined name. Never used internally.\n    name: string = '';\n\n    events: Map<string, Set<IEventInstance>>;\n\n    constructor ()\n    {\n        const id = this.id;\n\n        AddHierarchyComponent(id);\n        AddPermissionsComponent(id);\n        AddDirtyComponent(id);\n\n        GameObjectCache.set(id, this);\n\n        this.events = new Map();\n    }\n\n    isRenderable (): boolean\n    {\n        return WillRender(this.id);\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    beforeUpdate (delta: number, time: number): void\n    {\n        //  Empty for parent classes to use.\n        //  Called before this GameObject and all of its children have been updated.\n    }\n\n    update (delta: number, time: number): void\n    {\n        /*\n        this.beforeUpdate(delta, time);\n\n        if (WillUpdateChildren(this.id))\n        {\n            const children = GameObjectTree.get(this.id);\n\n            for (let i = 0; i < children.length; i++)\n            {\n                const childID = children[i];\n\n                if (WillUpdate(childID))\n                {\n                    GameObjectCache.get(childID).update(delta, time);\n                }\n            }\n        }\n\n        this.afterUpdate(delta, time);\n        */\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    afterUpdate (delta: number, time: number): void\n    {\n        //  Empty for parent classes to use.\n        //  Called after this GameObject and all of its children have been updated.\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    preRenderGL <T extends IRenderPass> (renderPass: T): void\n    {\n        //  Called before this GameObject and all of its children have been rendered.\n        //  If this Game Object won't render, this method is never called.\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    renderGL <T extends IRenderPass> (renderPass: T): void\n    {\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    renderCanvas <T extends ICanvasRenderer> (renderer: T): void\n    {\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    postRenderGL <T extends IRenderPass> (renderPass: T): void\n    {\n        //  Called after this GameObject and all of its children have been rendered.\n        //  If this Game Object won't render, this method is never called.\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    postRenderCanvas <T extends ICanvasRenderer> (renderer: T): void\n    {\n        //  Called after this GameObject and all of its children have been rendered.\n        //  If this Game Object won't render, this method is never called.\n    }\n\n    set visible (value: boolean)\n    {\n        SetVisible(value, this.id);\n    }\n\n    get visible (): boolean\n    {\n        return GetVisible(this.id);\n    }\n\n    set visibleChildren (value: boolean)\n    {\n        SetVisibleChildren(value, this.id);\n    }\n\n    get visibleChildren (): boolean\n    {\n        return GetVisibleChildren(this.id);\n    }\n\n    set depth (value: number)\n    {\n        HierarchyComponent.depth[this.id] = value;\n    }\n\n    get depth (): number\n    {\n        return HierarchyComponent.depth[this.id];\n    }\n\n    hasParent (id?: number): boolean\n    {\n        if (id)\n        {\n            return (HierarchyComponent.parent[this.id] === id);\n        }\n        else\n        {\n            return (HierarchyComponent.parent[this.id] > 0);\n        }\n    }\n\n    getParent (): IGameObject | undefined\n    {\n        return GetParentGameObject(this.id);\n    }\n\n    getChildren (): IGameObject[]\n    {\n        return GetChildrenFromParentID(this.id);\n    }\n\n    getNumChildren (): number\n    {\n        return GetNumChildren(this.id);\n    }\n\n    //#ifdef GET_DISPLAY_DATA\n    getDisplayData (): { id: number, index: number, parent: number, world: number, worldDepth: number, numChildren: number, children: number[] }\n    {\n        const id = this.id;\n\n        return {\n            id,\n            index: HierarchyComponent.index[id],\n            parent: HierarchyComponent.parent[id],\n            world: HierarchyComponent.world[id],\n            worldDepth: HierarchyComponent.worldDepth[id],\n            numChildren: HierarchyComponent.numChildren[id],\n            children: GameObjectTree.get(id)\n        };\n    }\n    //#endif\n\n    toString (): string\n    {\n        return `${this.type} id=\"${this.id}\" name=\"${this.name}\"`;\n    }\n\n    destroy <P extends IGameObject> (reparentChildren?: P): void\n    {\n        if (reparentChildren)\n        {\n            ReparentChildren(this, reparentChildren);\n        }\n        else\n        {\n            DestroyChildren(this);\n        }\n\n        Emit(this, DestroyEvent, this);\n\n        this.events.clear();\n\n        this.events = null;\n\n        //  TODO - Destroy process, remove from Cache, Tree, etc.\n    }\n}\n", "import { CONFIG_DEFAULTS } from '../const';\nimport { ConfigStore } from '../ConfigStore';\n\nexport function GetDefaultOriginX (): number\n{\n    return ConfigStore.get(CONFIG_DEFAULTS.DEFAULT_ORIGIN).x;\n}\n", "import { CONFIG_DEFAULTS } from '../const';\nimport { ConfigStore } from '../ConfigStore';\n\nexport function GetDefaultOriginY (): number\n{\n    return ConfigStore.get(CONFIG_DEFAULTS.DEFAULT_ORIGIN).y;\n}\n", "import { Extent2DComponent } from './Extent2DComponent';\nimport { SetDirtyTransform } from '../dirty/SetDirtyTransform';\nimport { Transform2DComponent } from './Transform2DComponent';\n\nexport function UpdateExtent (id: number, width: number, height: number): void\n{\n    const x = -(Transform2DComponent.originX[id]) * width;\n    const y = -(Transform2DComponent.originY[id]) * height;\n\n    Extent2DComponent.x[id] = x;\n    Extent2DComponent.y[id] = y;\n    Extent2DComponent.width[id] = width;\n    Extent2DComponent.height[id] = height;\n    Extent2DComponent.right[id] = x + width;\n    Extent2DComponent.bottom[id] = y + height;\n\n    SetDirtyTransform(id);\n}\n", "import { Extent2DComponent } from './Extent2DComponent';\nimport { IVec2 } from '../../math/vec2/IVec2';\nimport { Transform2DComponent } from './Transform2DComponent';\nimport { UpdateExtent } from './UpdateExtent';\n\nexport class Origin implements IVec2\n{\n    private id: number;\n\n    constructor (id: number, x: number = 0, y: number = 0)\n    {\n        this.id = id;\n\n        this.x = x;\n        this.y = y;\n    }\n\n    set (x: number, y: number = x): this\n    {\n        const id = this.id;\n\n        Transform2DComponent.originX[id] = x;\n        Transform2DComponent.originY[id] = y;\n\n        UpdateExtent(id, Extent2DComponent.width[id], Extent2DComponent.height[id]);\n\n        return this;\n    }\n\n    set x (value: number)\n    {\n        const id = this.id;\n\n        Transform2DComponent.originX[id] = value;\n\n        UpdateExtent(id, Extent2DComponent.width[id], Extent2DComponent.height[id]);\n    }\n\n    get x (): number\n    {\n        return Transform2DComponent.originX[this.id];\n    }\n\n    set y (value: number)\n    {\n        const id = this.id;\n\n        Transform2DComponent.originY[id] = value;\n\n        UpdateExtent(id, Extent2DComponent.width[id], Extent2DComponent.height[id]);\n    }\n\n    get y (): number\n    {\n        return Transform2DComponent.originY[this.id];\n    }\n}\n", "import { Color } from '../../../components/color/Color';\nimport { IRenderPass } from './IRenderPass';\n\nexport function PopColor <T extends IRenderPass> (renderPass: T, color: Color): void\n{\n    if (color.colorMatrixEnabled && color.willColorChildren)\n    {\n        renderPass.colorMatrix.pop();\n    }\n}\n", "import { IVec2 } from '../../math/vec2/IVec2';\nimport { SetDirtyTransform } from '../dirty';\nimport { Transform2DComponent } from './Transform2DComponent';\n\nexport class Position implements IVec2\n{\n    private id: number;\n\n    constructor (id: number, x: number = 0, y: number = 0)\n    {\n        this.id = id;\n\n        this.x = x;\n        this.y = y;\n    }\n\n    set (x: number, y: number = x): this\n    {\n        this.x = x;\n        this.y = y;\n\n        return this;\n    }\n\n    set x (value: number)\n    {\n        Transform2DComponent.x[this.id] = value;\n        SetDirtyTransform(this.id);\n    }\n\n    get x (): number\n    {\n        return Transform2DComponent.x[this.id];\n    }\n\n    set y (value: number)\n    {\n        Transform2DComponent.y[this.id] = value;\n        SetDirtyTransform(this.id);\n    }\n\n    get y (): number\n    {\n        return Transform2DComponent.y[this.id];\n    }\n}\n", "import { IVec2 } from '../../math/vec2/IVec2';\nimport { SetDirtyTransform } from '../dirty';\nimport { Transform2DComponent } from './Transform2DComponent';\n\nexport class Scale implements IVec2\n{\n    private id: number;\n\n    constructor (id: number, x: number = 1, y: number = 1)\n    {\n        this.id = id;\n\n        this.x = x;\n        this.y = y;\n    }\n\n    set (x: number, y: number = x): this\n    {\n        this.x = x;\n        this.y = y;\n\n        return this;\n    }\n\n    set x (value: number)\n    {\n        Transform2DComponent.scaleX[this.id] = value;\n        SetDirtyTransform(this.id);\n    }\n\n    get x (): number\n    {\n        return Transform2DComponent.scaleX[this.id];\n    }\n\n    set y (value: number)\n    {\n        Transform2DComponent.scaleY[this.id] = value;\n        SetDirtyTransform(this.id);\n    }\n\n    get y (): number\n    {\n        return Transform2DComponent.scaleY[this.id];\n    }\n}\n", "import { Color } from '../../../components/color/Color';\nimport { IRenderPass } from './IRenderPass';\n\nexport function SetColor <T extends IRenderPass> (renderPass: T, color: Color): void\n{\n    if (color.colorMatrixEnabled && color.willColorChildren)\n    {\n        renderPass.colorMatrix.set(color);\n    }\n}\n", "import { Extent2DComponent } from './Extent2DComponent';\nimport { IVec2 } from '../../math/vec2/IVec2';\nimport { UpdateExtent } from './UpdateExtent';\n\nexport class Size implements IVec2\n{\n    private id: number;\n\n    constructor (id: number, width: number = 0, height: number = 0)\n    {\n        this.id = id;\n\n        this.set(width, height);\n    }\n\n    set (width: number, height: number = width): this\n    {\n        this.width = width;\n        this.height = height;\n\n        return this;\n    }\n\n    set width (value: number)\n    {\n        UpdateExtent(this.id, value, this.height);\n    }\n\n    get width (): number\n    {\n        return Extent2DComponent.width[this.id];\n    }\n\n    set height (value: number)\n    {\n        UpdateExtent(this.id, this.width, value);\n    }\n\n    get height (): number\n    {\n        return Extent2DComponent.height[this.id];\n    }\n\n    set x (value: number)\n    {\n        this.width = value;\n    }\n\n    get x (): number\n    {\n        return this.width;\n    }\n\n    set y (value: number)\n    {\n        this.height = value;\n    }\n\n    get y (): number\n    {\n        return this.height;\n    }\n}\n", "import { IVec2 } from '../../math/vec2/IVec2';\nimport { SetDirtyTransform } from '../dirty';\nimport { Transform2DComponent } from './Transform2DComponent';\n\nexport class Skew implements IVec2\n{\n    private id: number;\n\n    constructor (id: number, x: number = 0, y: number = 0)\n    {\n        this.id = id;\n\n        this.x = x;\n        this.y = y;\n    }\n\n    set (x: number, y: number = x): this\n    {\n        this.x = x;\n        this.y = y;\n\n        return this;\n    }\n\n    set x (value: number)\n    {\n        Transform2DComponent.skewX[this.id] = value;\n        SetDirtyTransform(this.id);\n    }\n\n    get x (): number\n    {\n        return Transform2DComponent.skewX[this.id];\n    }\n\n    set y (value: number)\n    {\n        Transform2DComponent.skewY[this.id] = value;\n        SetDirtyTransform(this.id);\n    }\n\n    get y (): number\n    {\n        return Transform2DComponent.skewY[this.id];\n    }\n}\n", "import { AddBoundsComponent } from '../../components/bounds/AddBoundsComponent';\nimport { AddTransform2DComponent } from '../../components/transform/AddTransform2DComponent';\nimport { Color } from '../../components/color/Color';\nimport { Flush } from '../../renderer/webgl1/renderpass/Flush';\nimport { GameObject } from '../GameObject';\nimport { GetDefaultOriginX } from '../../config/defaultorigin/GetDefaultOriginX';\nimport { GetDefaultOriginY } from '../../config/defaultorigin/GetDefaultOriginY';\nimport { IContainer } from './IContainer';\nimport { IGameObject } from '../IGameObject';\nimport { IRenderPass } from '../../renderer/webgl1/renderpass/IRenderPass';\nimport { IShader } from '../../renderer/webgl1/shaders/IShader';\nimport { Origin } from '../../components/transform/Origin';\nimport { PopColor } from '../../renderer/webgl1/renderpass/PopColor';\nimport { Position } from '../../components/transform/Position';\nimport { Scale } from '../../components/transform/Scale';\nimport { SetColor } from '../../renderer/webgl1/renderpass/SetColor';\nimport { SetDirtyTransform } from '../../components/dirty';\nimport { Size } from '../../components/transform/Size';\nimport { Skew } from '../../components/transform/Skew';\nimport { Transform2DComponent } from '../../components/transform/Transform2DComponent';\n\nexport class Container extends GameObject implements IContainer\n{\n    readonly type: string = 'Container';\n\n    position: Position;\n    scale: Scale;\n    skew: Skew;\n    origin: Origin;\n    size: Size;\n    color: Color;\n\n    shader: IShader;\n\n    constructor (x: number = 0, y: number = 0)\n    {\n        super();\n\n        const id = this.id;\n\n        AddTransform2DComponent(id, x, y, GetDefaultOriginX(), GetDefaultOriginY());\n        AddBoundsComponent(id);\n\n        this.position = new Position(id, x, y);\n        this.scale = new Scale(id);\n        this.skew = new Skew(id);\n        this.size = new Size(id);\n        this.origin = new Origin(id, GetDefaultOriginX(), GetDefaultOriginY());\n        this.color = new Color(id);\n    }\n\n    renderGL <T extends IRenderPass> (renderPass: T): void\n    {\n        if (this.shader)\n        {\n            Flush(renderPass);\n\n            renderPass.shader.set(this.shader, 0);\n        }\n\n        SetColor(renderPass, this.color);\n\n        this.preRenderGL(renderPass);\n    }\n\n    postRenderGL <T extends IRenderPass> (renderPass: T): void\n    {\n        if (this.shader)\n        {\n            Flush(renderPass);\n\n            renderPass.shader.pop();\n        }\n\n        PopColor(renderPass, this.color);\n    }\n\n    set x (value: number)\n    {\n        this.position.x = value;\n    }\n\n    get x (): number\n    {\n        return this.position.x;\n    }\n\n    set y (value: number)\n    {\n        this.position.y = value;\n    }\n\n    get y (): number\n    {\n        return this.position.y;\n    }\n\n    set rotation (value: number)\n    {\n        Transform2DComponent.rotation[this.id] = value;\n        SetDirtyTransform(this.id);\n    }\n\n    get rotation (): number\n    {\n        return Transform2DComponent.rotation[this.id];\n    }\n\n    get alpha (): number\n    {\n        return this.color.alpha;\n    }\n\n    set alpha (value: number)\n    {\n        this.color.alpha = value;\n    }\n\n    setAlpha (value: number): this\n    {\n        this.alpha = value;\n\n        return this;\n    }\n\n    setPosition (x: number, y?: number): this\n    {\n        this.position.set(x, y);\n\n        return this;\n    }\n\n    setScale (x: number, y?: number): this\n    {\n        this.scale.set(x, y);\n\n        return this;\n    }\n\n    setRotation (value: number): this\n    {\n        this.rotation = value;\n\n        return this;\n    }\n\n    setSkew (x: number, y?: number): this\n    {\n        this.skew.set(x, y);\n\n        return this;\n    }\n\n    setOrigin (x: number, y?: number): this\n    {\n        this.origin.set(x, y);\n\n        return this;\n    }\n\n    destroy (reparentChildren?: IGameObject): void\n    {\n        super.destroy(reparentChildren);\n    }\n}\n", "import { ClearWorldAndParentID } from '../components/hierarchy/ClearWorldAndParentID';\nimport { GameObjectCache } from '../gameobjects/GameObjectCache';\nimport { GameObjectTree } from '../gameobjects/GameObjectTree';\nimport { IGameObject } from '../gameobjects/IGameObject';\nimport { UpdateChildIndexes } from '../components/hierarchy/UpdateChildIndexes';\n\nexport function RemoveChildAt <T extends IGameObject> (parent: T, index: number): IGameObject | undefined\n{\n    const parentID = parent.id;\n\n    const children = GameObjectTree.get(parentID);\n\n    if (index >= 0 && index < children.length)\n    {\n        const removedID = children.splice(index, 1)[0];\n\n        if (removedID)\n        {\n            ClearWorldAndParentID(removedID);\n\n            UpdateChildIndexes(parentID);\n\n            //  Emit remove event?\n\n            return GameObjectCache.get(removedID);\n        }\n    }\n}\n", "import { GetChildIndex } from './GetChildIndex';\nimport { IGameObject } from '../gameobjects/IGameObject';\nimport { RemoveChildAt } from './RemoveChildAt';\n\nexport function RemoveChild <P extends IGameObject, C extends IGameObject> (parent: P, child: C): C\n{\n    if (parent && child.hasParent(parent.id))\n    {\n        RemoveChildAt(parent, GetChildIndex(child));\n    }\n\n    return child;\n}\n", "import { IGameObject } from '../gameobjects/IGameObject';\nimport { RemoveChild } from './RemoveChild';\n\nexport function RemoveChildren <P extends IGameObject> (parent: P, ...children: IGameObject[]): IGameObject[]\n{\n    children.forEach(child =>\n    {\n        RemoveChild(parent, child);\n    });\n\n    return children;\n}\n", "import { QuadVertexComponent } from './QuadVertexComponent';\n\nexport function SetQuadPosition (id: number, x0: number, y0: number, x1: number, y1: number, x2: number, y2: number, x3: number, y3: number): void\n{\n    const data = QuadVertexComponent.values[id];\n\n    //  top left\n    data[0] = x0;\n    data[1] = y0;\n\n    //  bottom left\n    data[9] = x1;\n    data[10] = y1;\n\n    //  bottom right\n    data[18] = x2;\n    data[19] = y2;\n\n    //  top left\n    data[27] = x0;\n    data[28] = y0;\n\n    //  bottom right\n    data[36] = x2;\n    data[37] = y2;\n\n    //  top right\n    data[45] = x3;\n    data[46] = y3;\n}\n", "import { GameObjectWorld } from '../../GameObjectWorld';\nimport { QuadVertexComponent } from './QuadVertexComponent';\nimport { SetQuadColor } from './SetQuadColor';\nimport { SetQuadPosition } from './SetQuadPosition';\nimport { SetUV } from './SetUV';\nimport { addComponent } from 'bitecs';\n\nexport function AddQuadVertex (id: number, width: number = 0, height: number = 0, flipY: boolean = true): void\n{\n    addComponent(GameObjectWorld, QuadVertexComponent, id);\n\n    if (width || height)\n    {\n        // SetQuadColor(id, 1, 0, 0, 0.1);\n        SetUV(id, 0, 0, 1, 1);\n        SetQuadPosition(id, 0, 0, 0, height, width, height, width, 0);\n    }\n}\n", "import { BufferEntry } from '../draw/BufferEntry';\nimport { Flush } from './Flush';\nimport { IRenderPass } from './IRenderPass';\n\nconst bufferEntry: BufferEntry = {\n    buffer: null,\n    F32: null,\n    offset: 0\n};\n\nexport function GetVertexBufferEntry (renderPass: IRenderPass, addToCount: number = 0): BufferEntry\n{\n    const buffer = renderPass.vertexbuffer.current;\n\n    //  If batch cannot take the size of this entry, flush it first\n    if (renderPass.count + addToCount >= buffer.batchSize)\n    {\n        Flush(renderPass);\n    }\n\n    bufferEntry.buffer = buffer;\n    bufferEntry.F32 = buffer.vertexViewF32;\n    bufferEntry.offset = renderPass.count * buffer.entryElementSize;\n\n    renderPass.count += addToCount;\n\n    return bufferEntry;\n}\n", "import { QuadVertexComponent } from './QuadVertexComponent';\n\nexport function SetQuadTextureIndex (id: number, textureIndex: number): void\n{\n    const data = QuadVertexComponent.values[id];\n\n    if (data[4] !== textureIndex)\n    {\n        data[4] = textureIndex;\n        data[13] = textureIndex;\n        data[22] = textureIndex;\n        data[31] = textureIndex;\n        data[40] = textureIndex;\n        data[49] = textureIndex;\n    }\n}\n", "import { GetVertexBufferEntry } from '../renderpass/GetVertexBufferEntry';\nimport { IRenderPass } from '../renderpass/IRenderPass';\nimport { ITexture } from '../../../textures/ITexture';\nimport { QuadVertexComponent } from '../../../components/vertices/QuadVertexComponent';\nimport { SetQuadTextureIndex } from '../../../components/vertices/SetQuadTextureIndex';\n\nexport function BatchTexturedQuadBuffer <T extends ITexture> (texture: T, id: number, renderPass: IRenderPass): void\n{\n    const { F32, offset } = GetVertexBufferEntry(renderPass, 2);\n\n    const textureIndex = renderPass.textures.set(texture);\n\n    SetQuadTextureIndex(id, textureIndex);\n\n    F32.set(QuadVertexComponent.values[id], offset);\n}\n", "import { Frame } from '../../textures/Frame';\nimport { ISprite } from './ISprite';\nimport { Texture } from '../../textures/Texture';\n\nexport function SetFrame <T extends ISprite> (texture: Texture, key?: string | number | Frame, ...children: T[]): T[]\n{\n    const frame = texture.getFrame(key);\n\n    const pivot = frame.pivot;\n\n    children.forEach(child =>\n    {\n        if (!child || frame === child.frame)\n        {\n            return;\n        }\n\n        child.frame = frame;\n        child.hasTexture = true;\n\n        if (pivot)\n        {\n            child.origin.set(pivot.x, pivot.y);\n        }\n\n        frame.copyToExtent(child);\n\n        //  This rarely changes, so we'll set it here, rather than every game step:\n        frame.copyToVertices(child.id);\n    });\n\n    return children;\n}\n", "import { TextureManager } from './TextureManager';\n\nlet instance: TextureManager;\n\nexport const TextureManagerInstance =\n{\n    get: (): TextureManager =>\n    {\n        return instance;\n    },\n\n    set: (manager: TextureManager | null): void =>\n    {\n        if (instance)\n        {\n            throw new Error('Cannot instantiate TextureManager more than once');\n        }\n\n        instance = manager;\n    }\n};\n", "import { Texture } from './Texture';\nimport { TextureManagerInstance } from './TextureManagerInstance';\n\nexport function GetTexture (key: string): Texture\n{\n    return TextureManagerInstance.get().get(key);\n}\n", "import { Frame } from '../../textures/Frame';\nimport { GetTexture } from '../../textures/GetTexture';\nimport { IFrame } from '../../textures/IFrame';\nimport { ISprite } from './ISprite';\nimport { ITexture } from '../../textures/ITexture';\nimport { SetFrame } from './SetFrame';\nimport { Texture } from '../../textures/Texture';\n\nexport function SetTexture <T extends ISprite> (key: string | ITexture | IFrame, frame: string | number | IFrame, ...children: T[]): T[]\n{\n    if (!key)\n    {\n        //  Remove texture from all children\n        children.forEach(child =>\n        {\n            child.texture = null;\n            child.frame = null;\n            child.hasTexture = false;\n        });\n    }\n    else\n    {\n        let texture: Texture;\n\n        if (key instanceof Frame)\n        {\n            frame = key;\n            texture = key.texture;\n        }\n        else if (key instanceof Texture)\n        {\n            texture = key;\n        }\n        else\n        {\n            texture = GetTexture(key as string);\n        }\n\n        if (!texture)\n        {\n            console.warn(`Invalid Texture key: ${key as string}`);\n        }\n        else\n        {\n            children.forEach(child =>\n            {\n                child.texture = texture;\n            });\n\n            SetFrame(texture, frame, ...children);\n        }\n    }\n\n    return children;\n}\n", "import { AddQuadVertex } from '../../components/vertices/AddQuadVertex';\nimport { BatchTexturedQuadBuffer } from '../../renderer/webgl1/draw/BatchTexturedQuadBuffer';\nimport { Container } from '../container/Container';\nimport { Flush } from '../../renderer/webgl1/renderpass/Flush';\nimport { Frame } from '../../textures/Frame';\nimport { ICanvasRenderer } from '../../renderer/canvas/ICanvasRenderer';\nimport { IFrame } from '../../textures/IFrame';\nimport { IGameObject } from '../IGameObject';\nimport { IRenderPass } from '../../renderer/webgl1/renderpass/IRenderPass';\nimport { ISprite } from './ISprite';\nimport { ITexture } from '../../textures/ITexture';\nimport { SetFrame } from './SetFrame';\nimport { SetTexture } from './SetTexture';\nimport { Texture } from '../../textures/Texture';\nimport { WillRender } from '../../components/permissions/WillRender';\n\nexport class Sprite extends Container implements ISprite\n{\n    readonly type: string = 'Sprite';\n\n    texture: Texture;\n    frame: Frame;\n    hasTexture: boolean = false;\n\n    constructor (x: number, y: number, texture: string | Texture | Frame = '__BLANK', frame?: string | number | Frame)\n    {\n        super(x, y);\n\n        AddQuadVertex(this.id);\n\n        this.setTexture(texture, frame);\n    }\n\n    setTexture (key: string | ITexture | IFrame, frame?: string | number | IFrame): this\n    {\n        SetTexture(key, frame, this);\n\n        return this;\n    }\n\n    setFrame (key?: string | number | IFrame): this\n    {\n        SetFrame(this.texture, key, this);\n\n        return this;\n    }\n\n    isRenderable (): boolean\n    {\n        return (this.visible && this.hasTexture && WillRender(this.id) && this.alpha > 0);\n    }\n\n    renderGL <T extends IRenderPass> (renderPass: T): void\n    {\n        const color = this.color;\n\n        if (this.shader)\n        {\n            Flush(renderPass);\n\n            renderPass.shader.set(this.shader, 0);\n        }\n\n        if (color.colorMatrixEnabled)\n        {\n            renderPass.colorMatrix.set(color);\n        }\n\n        this.preRenderGL(renderPass);\n\n        BatchTexturedQuadBuffer(this.texture, this.id, renderPass);\n\n        if (color.colorMatrixEnabled && !color.willColorChildren)\n        {\n            Flush(renderPass);\n\n            renderPass.colorMatrix.pop();\n        }\n    }\n\n    renderCanvas <T extends ICanvasRenderer> (renderer: T): void\n    {\n        // PreRenderVertices(this);\n\n        // DrawImage(this.frame, this.alpha, this.worldTransform, this.transformExtent, renderer);\n    }\n\n    destroy (reparentChildren?: IGameObject): void\n    {\n        super.destroy(reparentChildren);\n\n        this.texture = null;\n        this.frame = null;\n        this.hasTexture = false;\n    }\n}\n", "export function Between (min: number, max: number): number\n{\n    return Math.floor(Math.random() * (max - min + 1) + min);\n}\n", "/* eslint-disable @typescript-eslint/restrict-template-expressions */\n\nimport { CONFIG_DEFAULTS } from '../const';\nimport { ConfigStore } from '../ConfigStore';\n\nexport function AddBanner (): void\n{\n    const { title, version, url, color, background } = ConfigStore.get(CONFIG_DEFAULTS.BANNER);\n\n    if (title !== '')\n    {\n        const str = `${title} ${version}`.trimEnd();\n\n        console.log(\n            `%c${str}%c ${url}`,\n            `padding: 4px 16px; color: ${color}; background: ${background}`,\n            ''\n        );\n    }\n}\n", "import { CONFIG_DEFAULTS } from '../const';\nimport { ConfigStore } from '../ConfigStore';\nimport { Game } from '../../Game';\n\nexport function AddGlobalVar (game: Game): void\n{\n    const globalVar = ConfigStore.get(CONFIG_DEFAULTS.GLOBAL_VAR);\n\n    if (globalVar && window)\n    {\n        (window as unknown)[globalVar] = game;\n    }\n}\n", "import { Types, defineComponent } from 'bitecs';\n\nexport const TimeComponent = defineComponent({\n    lastTick: Types.ui32,\n    elapsed: Types.ui32,\n    delta: Types.f32,\n    fps: Types.f32,\n    fpsCount: Types.ui16,\n    frame: Types.ui32,\n    ms: Types.ui32,\n    prevFrame: Types.ui32\n});\n", "import { GameObjectWorld } from '../../GameObjectWorld';\nimport { TimeComponent } from './TimeComponent';\nimport { addComponent } from 'bitecs';\n\nexport function AddTimeComponent (id: number): void\n{\n    addComponent(GameObjectWorld, TimeComponent, id);\n\n    const now = performance.now();\n\n    TimeComponent.lastTick[id] = now;\n    TimeComponent.prevFrame[id] = now;\n}\n", "import { GetElement } from './GetElement';\n\nexport function AddToDOM (element: HTMLElement, parent?: string | HTMLElement): HTMLElement\n{\n    const target: HTMLElement = GetElement(parent);\n\n    target.appendChild(element);\n\n    return element;\n}\n", "import { AddToDOM } from '../../dom/AddToDOM';\nimport { CONFIG_DEFAULTS } from '../const';\nimport { ConfigStore } from '../ConfigStore';\nimport { RendererInstance } from '../../renderer/RendererInstance';\n\nexport function AddToParent (): void\n{\n    const parent = ConfigStore.get(CONFIG_DEFAULTS.PARENT);\n    const canvas = RendererInstance.get().canvas;\n\n    //  Only add to the DOM if they either didn't set a Parent, or expressly set it to be non-null\n    //  Otherwise we'll let them add the canvas to the DOM themselves\n\n    if (parent && canvas)\n    {\n        AddToDOM(canvas, parent);\n    }\n}\n", "import { CONFIG_DEFAULTS } from '../const';\nimport { ConfigStore } from '../ConfigStore';\n\nexport function CreateRenderer (): void\n{\n    const renderer = ConfigStore.get(CONFIG_DEFAULTS.RENDERER);\n\n    if (renderer)\n    {\n        new renderer();\n    }\n}\n", "import { Types, defineComponent } from 'bitecs';\n\nconst RenderStats = defineComponent({\n\n    //  The current Game Frame number\n    gameFrame: Types.ui32,\n\n    //  Total number of Scenes rendered\n    numScenes: Types.ui8,\n\n    //  Total number of Worlds rendered\n    numWorlds: Types.ui8,\n\n    //  Total number of Game Objects (across all worlds)\n    numGameObjects: Types.ui32,\n\n    //  Total number of Game Objects to be rendered (across all worlds)\n    numGameObjectsRendered: Types.ui32,\n\n    //  Total number of Game Objects with dirty local transforms\n    numDirtyLocalTransforms: Types.ui32,\n\n    //  Total number of Game Objects with dirty world transforms\n    numDirtyWorldTransforms: Types.ui32,\n\n    //  Total number of Game Objects with dirty vertices\n    numDirtyVertices: Types.ui32,\n\n    //  Total number of Worlds that had to recalculate their display lists\n    numDirtyWorldLists: Types.ui8,\n\n    //  How many Cameras were made dirty this frame across all Scenes?\n    numDirtyCameras: Types.ui32\n\n});\n\nexport const RenderStatsComponent = RenderStats;\n", "import { GameObjectWorld } from '../GameObjectWorld';\nimport { RenderStatsComponent } from './RenderStatsComponent';\nimport { addComponent } from 'bitecs';\n\nexport function AddRenderStatsComponent (id: number): void\n{\n    addComponent(GameObjectWorld, RenderStatsComponent, id);\n}\n", "import { Game } from './Game';\n\nexport let instance: Game;\nexport let frame: number = 0;\nexport let elapsed: number = 0;\n\nexport const GameInstance =\n{\n    get: (): Game =>\n    {\n        return instance;\n    },\n\n    set: (game: Game | undefined): void =>\n    {\n        instance = game;\n    },\n\n    getFrame: (): number =>\n    {\n        return frame;\n    },\n\n    setFrame: (current: number): void =>\n    {\n        frame = current;\n    },\n\n    getElapsed: (): number =>\n    {\n        return elapsed;\n    },\n\n    setElapsed: (current: number): void =>\n    {\n        elapsed = current;\n    }\n\n};\n", "import { CONFIG_DEFAULTS } from '../const';\nimport { ConfigStore } from '../ConfigStore';\nimport { ISceneConstructor } from '../../scenes/ISceneConstructor';\n\nexport function GetScenes (): ISceneConstructor[]\n{\n    return ConfigStore.get(CONFIG_DEFAULTS.SCENES);\n}\n", "export class EventInstance\n{\n    callback: Function;\n    context: unknown;\n    once: boolean;\n\n    constructor (callback: Function, context: unknown, once: boolean = false)\n    {\n        this.callback = callback;\n        this.context = context;\n        this.once = once;\n    }\n}\n", "import { EventInstance } from './EventInstance';\nimport { IEventEmitter } from './IEventEmitter';\nimport { IEventInstance } from './IEventInstance';\n\nexport function On (emitter: IEventEmitter, event: string, callback: Function, context: unknown = emitter, once: boolean = false): IEventInstance\n{\n    if (typeof callback !== 'function')\n    {\n        throw new TypeError('Listener not a function');\n    }\n\n    const listener = new EventInstance(callback, context, once);\n    const listeners = emitter.events.get(event);\n\n    if (!listeners)\n    {\n        emitter.events.set(event, new Set([ listener ]));\n    }\n    else\n    {\n        listeners.add(listener);\n    }\n\n    return listener;\n}\n", "import { IEventEmitter } from './IEventEmitter';\nimport { IEventInstance } from './IEventInstance';\nimport { On } from './On';\n\nexport function Once (emitter: IEventEmitter, event: string, callback: Function, context: unknown = emitter): IEventInstance\n{\n    return On(emitter, event, callback, context, true);\n}\n", "import { RenderStatsComponent } from './RenderStatsComponent';\n\nexport function ResetRenderStats (id: number, gameFrame: number, scenes: number): void\n{\n    RenderStatsComponent.gameFrame[id] = gameFrame;\n    RenderStatsComponent.numScenes[id] = scenes;\n    RenderStatsComponent.numWorlds[id] = 0;\n    RenderStatsComponent.numGameObjects[id] = 0;\n    RenderStatsComponent.numGameObjectsRendered[id] = 0;\n    RenderStatsComponent.numDirtyWorldLists[id] = 0;\n    RenderStatsComponent.numDirtyVertices[id] = 0;\n    RenderStatsComponent.numDirtyLocalTransforms[id] = 0;\n    RenderStatsComponent.numDirtyWorldTransforms[id] = 0;\n    RenderStatsComponent.numDirtyCameras[id] = 0;\n}\n", "import { SceneManager } from './SceneManager';\n\nlet instance: SceneManager;\n\nexport const SceneManagerInstance =\n{\n    get: (): SceneManager =>\n    {\n        return instance;\n    },\n\n    set: (manager: SceneManager | null): void =>\n    {\n        if (instance)\n        {\n            throw new Error('Cannot instantiate SceneManager more than once');\n        }\n\n        instance = manager;\n    }\n};\n", "import { IBaseWorld } from './IBaseWorld';\nimport { IScene } from '../scenes/IScene';\n\nexport const WorldList: Map<IScene, IBaseWorld[]> = new Map();\n", "import { AddRenderStatsComponent } from './AddRenderStatsComponent';\nimport { Game } from '../Game';\nimport { GameInstance } from '../GameInstance';\nimport { GameObjectWorld } from '../GameObjectWorld';\nimport { GetScenes } from '../config/scenes/GetScenes';\nimport { IGameObject } from '../gameobjects/IGameObject';\nimport { IRenderPass } from '../renderer/webgl1/renderpass/IRenderPass';\nimport { IScene } from './IScene';\nimport { Once } from '../events/Once';\nimport { RenderStatsComponent } from './RenderStatsComponent';\nimport { ResetRenderStats } from './ResetRenderStats';\nimport { SceneManagerInstance } from './SceneManagerInstance';\nimport { TimeComponent } from '../components/timer/TimeComponent';\nimport { WorldList } from '../world/WorldList';\nimport { addEntity } from 'bitecs';\n\nexport class SceneManager\n{\n    readonly id: number = addEntity(GameObjectWorld);\n\n    game: Game;\n\n    scenes: Map<string, IScene> = new Map();\n\n    //  Used by Install to assign default scene keys when not specified\n    sceneIndex: number = 0;\n\n    //  Force the renderer to fully redraw\n    flush: boolean;\n\n    constructor ()\n    {\n        SceneManagerInstance.set(this);\n\n        this.game = GameInstance.get();\n\n        AddRenderStatsComponent(this.id);\n\n        Once(this.game, 'boot', () => this.boot());\n    }\n\n    boot (): void\n    {\n        const scenes = GetScenes();\n\n        if (scenes)\n        {\n            scenes.forEach(scene => new scene());\n        }\n    }\n\n    update (): void\n    {\n        const id = this.game.id;\n\n        const delta = TimeComponent.delta[id];\n        const time = TimeComponent.lastTick[id];\n        const gameFrame = TimeComponent.frame[id];\n\n        ResetRenderStats(this.id, gameFrame, this.scenes.size);\n\n        for (const scene of this.scenes.values())\n        {\n            const worlds = WorldList.get(scene);\n\n            for (const world of worlds)\n            {\n                world.beforeUpdate(delta, time);\n            }\n\n            if (scene.update)\n            {\n                scene.update(delta, time);\n            }\n\n            for (const world of worlds)\n            {\n                world.update(delta, time);\n            }\n\n            for (const world of worlds)\n            {\n                world.afterUpdate(delta, time);\n            }\n        }\n    }\n\n    //  Run through all Scenes and Worlds within them, telling them to prepare to render\n    preRender (): void\n    {\n        const id = this.game.id;\n\n        const gameFrame = TimeComponent.frame[id];\n\n        for (const scene of this.scenes.values())\n        {\n            const worlds = WorldList.get(scene);\n\n            for (const world of worlds)\n            {\n                if (world.preRender(gameFrame))\n                {\n                    this.flush = true;\n                }\n            }\n        }\n    }\n\n    render (renderPass: IRenderPass): void\n    {\n        for (const scene of this.scenes.values())\n        {\n            const worlds = WorldList.get(scene);\n\n            for (const world of worlds)\n            {\n                world.renderGL(renderPass);\n            }\n        }\n\n        this.flush = false;\n    }\n\n    //  TODO - This isn't used internally - is used by debug panel - move out?\n    /*\n    getRenderList (): IGameObject[]\n    {\n        let output: IGameObject[] = [];\n\n        for (const scene of this.scenes.values())\n        {\n            const worlds = WorldList.get(scene);\n\n            for (const world of worlds)\n            {\n                output = output.concat(world.getRenderList());\n            }\n        }\n\n        return output;\n    }\n\n    updateWorldStats (numGameObjects: number, numRendered: number, numDisplayLists: number, numWorldTransforms: number): void\n    {\n        const id = this.id;\n\n        RenderStatsComponent.numGameObjects[id] += numGameObjects;\n        RenderStatsComponent.numGameObjectsRendered[id] += numRendered;\n        RenderStatsComponent.numDirtyWorldLists[id] += numDisplayLists;\n        RenderStatsComponent.numDirtyWorldTransforms[id] += numWorldTransforms;\n    }\n    */\n}\n", "import { SceneManager } from './SceneManager';\n\nexport function CreateSceneManager (): void\n{\n    new SceneManager();\n}\n", "export function CreateCanvas (width: number, height: number): CanvasRenderingContext2D\n{\n    const canvas = document.createElement('canvas');\n\n    canvas.width = width;\n    canvas.height = height;\n\n    return canvas.getContext('2d');\n}\n", "import { CreateCanvas } from './CreateCanvas';\nimport { IGLTextureBindingConfig } from '../renderer/webgl1/textures/IGLTextureBindingConfig';\nimport { Texture } from './Texture';\nimport { TextureManagerInstance } from './TextureManagerInstance';\nimport { WhiteTexture } from './WhiteTexture';\n\nexport class TextureManager\n{\n    textures: Map<string, Texture>;\n\n    constructor ()\n    {\n        TextureManagerInstance.set(this);\n\n        this.textures = new Map();\n\n        this.createDefaultTextures();\n    }\n\n    private createDefaultTextures (): void\n    {\n        this.add('__BLANK', new Texture(CreateCanvas(2, 2).canvas));\n\n        const missing = CreateCanvas(32, 32);\n\n        missing.strokeStyle = '#0f0';\n        missing.moveTo(0, 0);\n        missing.lineTo(32, 32);\n        missing.stroke();\n        missing.strokeRect(0.5, 0.5, 31, 31);\n\n        this.add('__MISSING', new Texture(missing.canvas));\n\n        const white = CreateCanvas(2, 2);\n\n        white.fillStyle = '#fff';\n        white.fillRect(0, 0, 2, 2);\n\n        const whiteTexture = this.add('__WHITE', new Texture(white.canvas));\n\n        //  Because this is used frequently by Graphics and Shapes\n        WhiteTexture.set(whiteTexture);\n    }\n\n    get (key: string): Texture\n    {\n        const textures = this.textures;\n\n        if (textures.has(key))\n        {\n            return textures.get(key);\n        }\n        else\n        {\n            return textures.get('__MISSING');\n        }\n    }\n\n    has (key: string): boolean\n    {\n        return this.textures.has(key);\n    }\n\n    add (key: string, source: Texture | TexImageSource, glConfig?: IGLTextureBindingConfig): Texture\n    {\n        let texture: Texture;\n\n        if (!this.textures.has(key))\n        {\n            if (source instanceof Texture)\n            {\n                texture = source;\n            }\n            else\n            {\n                texture = new Texture(source, 0, 0, glConfig);\n            }\n\n            texture.key = key;\n\n            this.textures.set(key, texture);\n        }\n\n        return texture;\n    }\n\n    update (key: string, source: TexImageSource, glConfig?: IGLTextureBindingConfig): Texture\n    {\n        const texture = this.textures.get(key);\n\n        if (texture)\n        {\n            texture.update(source, glConfig);\n        }\n\n        return texture;\n    }\n}\n", "import { TextureManager } from './TextureManager';\n\nexport function CreateTextureManager (): void\n{\n    new TextureManager();\n}\n", "export function DOMContentLoaded (callback: () => void): void\n{\n    const readyState = document.readyState;\n\n    if (readyState === 'complete' || readyState === 'interactive')\n    {\n        callback();\n\n        return;\n    }\n\n    const check = (): void =>\n    {\n        document.removeEventListener('deviceready', check, true);\n        document.removeEventListener('DOMContentLoaded', check, true);\n        window.removeEventListener('load', check, true);\n\n        callback();\n    };\n\n    // TODO - Swap is IsCordova call\n\n    if (!document.body)\n    {\n        window.setTimeout(check, 20);\n    }\n    else if (window.hasOwnProperty('cordova'))\n    {\n        document.addEventListener('deviceready', check, true);\n    }\n    else\n    {\n        document.addEventListener('DOMContentLoaded', check, true);\n        window.addEventListener('load', check, true);\n    }\n}\n", "import { IEventInstance } from './IEventInstance';\n\nexport class EventEmitter\n{\n    events: Map<string, Set<IEventInstance>>;\n\n    constructor ()\n    {\n        this.events = new Map();\n    }\n}\n", "import { IRenderStats } from './IRenderStats';\nimport { RenderStatsComponent } from './RenderStatsComponent';\nimport { SceneManagerInstance } from './SceneManagerInstance';\n\nexport function GetRenderStatsAsObject (obj?: IRenderStats): IRenderStats\n{\n    const id = SceneManagerInstance.get().id;\n\n    if (!obj)\n    {\n        obj = { fps: 0, delta: 0, gameFrame: 0, numScenes: 0, numWorlds: 0, numGameObjects: 0, numGameObjectsRendered: 0, numDirtyLocalTransforms: 0, numDirtyWorldTransforms: 0, numDirtyVertices: 0, numDirtyWorldLists: 0, numDirtyCameras: 0 };\n    }\n\n    obj.gameFrame = RenderStatsComponent.gameFrame[id];\n    obj.numScenes = RenderStatsComponent.numScenes[id];\n    obj.numWorlds = RenderStatsComponent.numWorlds[id];\n    obj.numGameObjects = RenderStatsComponent.numGameObjects[id];\n    obj.numGameObjectsRendered = RenderStatsComponent.numGameObjectsRendered[id];\n    obj.numDirtyLocalTransforms = RenderStatsComponent.numDirtyLocalTransforms[id];\n    obj.numDirtyWorldTransforms = RenderStatsComponent.numDirtyWorldTransforms[id];\n    obj.numDirtyVertices = RenderStatsComponent.numDirtyVertices[id];\n    obj.numDirtyWorldLists = RenderStatsComponent.numDirtyWorldLists[id];\n    obj.numDirtyCameras = RenderStatsComponent.numDirtyCameras[id];\n\n    return obj;\n}\n", "import { TimeComponent } from './TimeComponent';\n\nexport function ResetLastTick (id: number): void\n{\n    TimeComponent.lastTick[id] = performance.now();\n}\n", "import { ISceneConfig } from './ISceneConfig';\n\nexport function GetConfigValue<Property extends keyof ISceneConfig> (config: ISceneConfig, property: Property, defaultValue: ISceneConfig[Property]): ISceneConfig[Property]\n{\n    if (Object.prototype.hasOwnProperty.call(config, property))\n    {\n        return config[property];\n    }\n    else\n    {\n        return defaultValue;\n    }\n}\n", "import { GetConfigValue } from './GetConfigValue';\nimport { IScene } from './IScene';\nimport { ISceneConfig } from './ISceneConfig';\nimport { SceneManagerInstance } from './SceneManagerInstance';\nimport { WorldList } from '../world/WorldList';\n\nexport function Install (scene: IScene, config: string | ISceneConfig = {}): void\n{\n    const sceneManager = SceneManagerInstance.get();\n\n    const size = sceneManager.scenes.size;\n    const sceneIndex = sceneManager.sceneIndex;\n    const firstScene = (size === 0);\n\n    if (typeof config === 'string')\n    {\n        scene.key = config;\n    }\n    else if (config || (!config && firstScene))\n    {\n        scene.key = GetConfigValue(config, 'key', 'scene' + sceneIndex.toString());\n    }\n\n    if (sceneManager.scenes.has(scene.key))\n    {\n        console.warn('Scene key already in use: ' + scene.key);\n    }\n    else\n    {\n        sceneManager.scenes.set(scene.key, scene);\n\n        sceneManager.flush = true;\n\n        sceneManager.sceneIndex++;\n    }\n\n    WorldList.set(scene, []);\n}\n", "import { Game } from '../Game';\nimport { GameInstance } from '../GameInstance';\nimport { IEventEmitter } from '../events/IEventEmitter';\nimport { IEventInstance } from '../events/IEventInstance';\nimport { IScene } from './IScene';\nimport { ISceneConfig } from './ISceneConfig';\nimport { Install } from './Install';\n\nexport class Scene implements IScene, IEventEmitter\n{\n    key: string;\n    game: Game;\n    events: Map<string, Set<IEventInstance>>;\n\n    constructor (config?: string | ISceneConfig)\n    {\n        this.game = GameInstance.get();\n        this.events = new Map();\n\n        Install(this, config);\n    }\n}\n", "import { SetBackgroundColor } from './backgroundcolor/SetBackgroundColor';\nimport { SetBanner } from './banner/SetBanner';\nimport { SetBatchSize } from './batchsize/SetBatchSize';\nimport { SetDefaultOrigin } from './defaultorigin/SetDefaultOrigin';\nimport { SetMaxTextures } from './maxtextures/SetMaxTextures';\nimport { SetSize } from './size/SetSize';\nimport { SetWebGLContext } from './webglcontext/SetWebGLContext';\nimport { SetWorldSize } from './worldsize/SetWorldSize';\n\n//  Phaser 4 defaults\n\nexport function SetConfigDefaults (): void\n{\n    SetBackgroundColor(0);\n    SetBatchSize(2048);\n    SetBanner('Phaser', '4.0.0', 'https://phaser4.io');\n    SetMaxTextures(0);\n    SetDefaultOrigin(0.5, 0.5);\n    SetSize(800, 600, 1);\n    SetWebGLContext({\n        antialias: true,\n        desynchronized: true,\n        preserveDrawingBuffer: true\n    });\n    SetWorldSize();\n}\n", "import { GameInstance } from '../../GameInstance';\nimport { TimeComponent } from './TimeComponent';\n\nexport function UpdateDelta (id: number, time: number): void\n{\n    //  Note that privacy.resistFingerprinting can round this value to 100ms or more!\n    const now = performance.now();\n\n    //  How long it took to process this frame\n    const delta = now - time;\n\n    TimeComponent.fpsCount[id]++;\n\n    if (now >= TimeComponent.prevFrame[id] + 1000)\n    {\n        TimeComponent.fps[id] = (TimeComponent.fpsCount[id] * 1000) / (now - TimeComponent.prevFrame[id]);\n        TimeComponent.prevFrame[id] = now;\n        TimeComponent.fpsCount[id] = 0;\n    }\n\n    TimeComponent.lastTick[id] = now;\n    TimeComponent.elapsed[id] += delta;\n    TimeComponent.delta[id] = delta;\n    TimeComponent.frame[id]++;\n\n    GameInstance.setFrame(TimeComponent.frame[id]);\n}\n", "import { TimeComponent } from './TimeComponent';\n\nexport function UpdateTime (id: number, time: number): void\n{\n    TimeComponent.ms[id] = time - TimeComponent.lastTick[id];\n}\n", "import { AddBanner } from './config/banner/AddBanner';\nimport { AddGlobalVar } from './config/globalvar/AddGlobalVar';\nimport { AddTimeComponent } from './components/timer/AddTimeComponent';\nimport { AddToParent } from './config/parent/AddToParent';\nimport { CreateRenderer } from './config/renderer/CreateRenderer';\nimport { CreateSceneManager } from './scenes/CreateSceneManager';\nimport { CreateTextureManager } from './textures/CreateTextureManager';\nimport { DOMContentLoaded } from './dom/DOMContentLoaded';\nimport { Emit } from './events/Emit';\nimport { EventEmitter } from './events/EventEmitter';\nimport { GameInstance } from './GameInstance';\nimport { GameObjectWorld } from './GameObjectWorld';\nimport { GetRenderStatsAsObject } from './scenes/GetRenderStatsAsObject';\nimport { IRenderPass } from './renderer/webgl1/renderpass/IRenderPass';\nimport { IRenderStats } from './scenes/IRenderStats';\nimport { RendererInstance } from './renderer/RendererInstance';\nimport { ResetLastTick } from './components/timer/ResetLastTick';\nimport { SceneManagerInstance } from './scenes';\nimport { SetConfigDefaults } from './config/SetConfigDefaults';\nimport { TimeComponent } from './components/timer/TimeComponent';\nimport { UpdateDelta } from './components/timer/UpdateDelta';\nimport { UpdateTime } from './components/timer/UpdateTime';\nimport { addEntity } from 'bitecs';\n\nexport class Game extends EventEmitter\n{\n    readonly id: number = addEntity(GameObjectWorld);\n\n    readonly VERSION: string = '4.0.0-beta1';\n\n    isBooted: boolean = false;\n    isPaused: boolean = false;\n\n    //  TODO - Allow update to run on different tick to render\n    //  TODO - Allow update and render to be called directly\n    willUpdate: boolean = true;\n    willRender: boolean = true;\n\n    renderStats: IRenderStats;\n\n    constructor (...settings: { (): void }[])\n    {\n        super();\n\n        GameInstance.set(this);\n\n        SetConfigDefaults();\n\n        DOMContentLoaded(() => this.boot(settings));\n    }\n\n    boot (settings: { (): void }[]): void\n    {\n        //  Activate the settings post DOM Content Loaded\n        settings.forEach(setting => setting());\n\n        CreateRenderer();\n        CreateTextureManager();\n        CreateSceneManager();\n\n        AddTimeComponent(this.id);\n        AddBanner();\n        AddGlobalVar(this);\n        AddToParent();\n\n        this.renderStats = GetRenderStatsAsObject();\n\n        this.isBooted = true;\n\n        Emit(this, 'boot');\n\n        requestAnimationFrame(now => this.step(now));\n    }\n\n    pause (): void\n    {\n        this.isPaused = true;\n    }\n\n    resume (): void\n    {\n        this.isPaused = false;\n\n        ResetLastTick(this.id);\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    update (delta: number, time: number): void\n    {\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    render (renderPass: IRenderPass, delta: number, time: number): void\n    {\n    }\n\n    step (time: number): void\n    {\n        const id = this.id;\n        const renderer = RendererInstance.get();\n        const sceneManager = SceneManagerInstance.get();\n\n        UpdateTime(id, time);\n\n        if (!this.isPaused)\n        {\n            const delta = TimeComponent.delta[id];\n\n            if (this.willUpdate)\n            {\n                sceneManager.update();\n\n                this.update(delta, time);\n\n                Emit(this, 'update', delta, time);\n            }\n\n            if (this.willRender)\n            {\n                sceneManager.preRender();\n\n                renderer.begin(sceneManager.flush);\n\n                sceneManager.render(renderer.renderPass);\n\n                this.render(renderer.renderPass, delta, time);\n\n                Emit(this, 'render', renderer.renderPass, delta, time);\n\n                renderer.end();\n            }\n        }\n\n        UpdateDelta(id, time);\n\n        GetRenderStatsAsObject(this.renderStats);\n\n        this.renderStats.fps = TimeComponent.fps[id];\n        this.renderStats.delta = TimeComponent.delta[id];\n\n        Emit(this, 'step');\n\n        requestAnimationFrame(now => this.step(now));\n    }\n\n    destroy (): void\n    {\n        //  TODO - Code destroy function\n    }\n}\n", "import { IFile } from './IFile';\n\nexport function CreateFile (key: string, url: string, skipCache: boolean = false): IFile\n{\n    return {\n        key,\n        url,\n        skipCache\n    };\n}\n", "// import { Loader } from './Loader';\n\nexport function GetURL (key: string, url: string, extension: string): string\n{\n    if (!url)\n    {\n        url = `${key}.${extension}`;\n    }\n\n    if ((/^(?:blob:|data:|http:\\/\\/|https:\\/\\/|\\/\\/)/).exec(url))\n    {\n        return url;\n    }\n    // else if (loader)\n    // {\n    //     return loader.baseURL + loader.path + url;\n    // }\n    else\n    {\n        return url;\n    }\n}\n", "import { IFile } from './IFile';\nimport { IFileData } from './IFileData';\n\nexport async function RequestFile (file: IFile, preload: (file: IFile) => boolean, onload: (file: IFile) => Promise<boolean>, fileData?: IFileData): Promise<IFile>\n{\n    if (!preload(file))\n    {\n        return Promise.reject(file);\n    }\n\n    try\n    {\n        const request = new Request(file.url, fileData?.requestInit);\n\n        file.response = await fetch(request);\n\n        if (file.response.ok && await onload(file))\n        {\n            return Promise.resolve(file);\n        }\n        else\n        {\n            return Promise.reject(file);\n        }\n    }\n    catch (error)\n    {\n        file.error = error;\n\n        return Promise.reject(file);\n    }\n}\n", "import { CreateFile } from '../CreateFile';\nimport { GetURL } from '../GetURL';\nimport { IFile } from '../IFile';\nimport { IFileData } from '../IFileData';\nimport { RequestFile } from '../RequestFile';\nimport { TextureManagerInstance } from '../../textures/TextureManagerInstance';\n\nexport async function ImageFile (key: string, url?: string, fileData: IFileData = {}): Promise<IFile>\n{\n    const file = CreateFile(key, GetURL(key, url, 'png'), fileData?.skipCache);\n\n    const textureManager = TextureManagerInstance.get();\n\n    const preload = () =>\n    {\n        return (textureManager && (!textureManager.has(key) || !textureManager.get(key).locked));\n    };\n\n    const onload = async (file: IFile) =>\n    {\n        const blob = await file.response.blob();\n\n        let image;\n\n        if (window && 'createImageBitmap' in window && !fileData?.getImage)\n        {\n            image = await createImageBitmap(blob);\n        }\n        else\n        {\n            image = await new Promise <HTMLImageElement> ((resolve, reject)  =>\n            {\n                const url = URL.createObjectURL(blob);\n\n                const img = new Image();\n\n                img.onload = (): void =>\n                {\n                    URL.revokeObjectURL(url);\n\n                    resolve(img);\n                };\n\n                img.onerror = (): void =>\n                {\n                    reject();\n                };\n\n                img.src = url;\n\n                // Image is immediately-available or cached\n\n                if (img.complete && img.width && img.height)\n                {\n                    img.onload = null;\n                    img.onerror = null;\n\n                    resolve(img);\n                }\n            });\n        }\n\n        if (!image)\n        {\n            return false;\n        }\n\n        if (fileData.skipCache)\n        {\n            file.data = image;\n        }\n        else if (textureManager.has(key))\n        {\n            file.data = textureManager.update(key, image, fileData?.glConfig);\n        }\n        else\n        {\n            file.data = textureManager.add(key, image, fileData?.glConfig);\n        }\n\n        return true;\n    };\n\n    return RequestFile(file, preload, onload, fileData);\n}\n", "import { Emit } from '../../events/Emit';\nimport { EventEmitter } from '../../events/EventEmitter';\nimport { IKey } from './IKey';\n\nexport class Keyboard extends EventEmitter\n{\n    keys: Map<string, IKey>;\n\n    private keydownHandler: { (event: KeyboardEvent): void; (this: Window, ev: KeyboardEvent): void };\n    private keyupHandler: { (event: KeyboardEvent): void; (this: Window, ev: KeyboardEvent): void };\n    private blurHandler: { (): void; (this: Window, ev: FocusEvent): void };\n\n    /* eslint-disable @typescript-eslint/naming-convention */\n    keyConversion: { [ key: string ]: string } = {\n        Up: 'ArrowUp',\n        Down: 'ArrowDown',\n        Left: 'ArrowLeft',\n        Right: 'ArrowRight',\n        Spacebar: ' ',\n        Win: 'Meta',\n        Scroll: 'ScrollLock',\n        Del: 'Delete',\n        Apps: 'ContextMenu',\n        Esc: 'Escape',\n        Add: '+',\n        Subtract: '-',\n        Multiply: '*',\n        Decimal: '.',\n        Divide: '/'\n    };\n    /* eslint-enable @typescript-eslint/naming-convention */\n\n    constructor ()\n    {\n        super();\n\n        this.keydownHandler = (event: KeyboardEvent): void => this.onKeyDown(event);\n        this.keyupHandler = (event: KeyboardEvent): void => this.onKeyUp(event);\n        this.blurHandler = (): void => this.onBlur();\n\n        window.addEventListener('keydown', this.keydownHandler);\n        window.addEventListener('keyup', this.keyupHandler);\n        window.addEventListener('blur', this.blurHandler);\n\n        this.keys = new Map();\n    }\n\n    addKeys (...keys: IKey[]): void\n    {\n        keys.forEach(key =>\n        {\n            this.keys.set(key.getValue(), key);\n        });\n    }\n\n    clearKeys (): void\n    {\n        this.keys.clear();\n    }\n\n    private onBlur (): void\n    {\n        //  Iterate Keys and reset their state\n        this.keys.forEach(key =>\n        {\n            key.reset();\n        });\n    }\n\n    private getKeyValue (key: string): string\n    {\n        if (this.keyConversion.hasOwnProperty(key))\n        {\n            return this.keyConversion[key];\n        }\n        else\n        {\n            return key;\n        }\n    }\n\n    private onKeyDown (event: KeyboardEvent): void\n    {\n        const value = this.getKeyValue(event.key);\n\n        if (this.keys.has(value))\n        {\n            const key = this.keys.get(value);\n\n            key.down(event);\n        }\n\n        //  Key specific event\n        Emit(this, 'keydown-' + value, event);\n\n        //  Global keydown event\n        Emit(this, 'keydown', event);\n    }\n\n    private onKeyUp (event: KeyboardEvent): void\n    {\n        const value = this.getKeyValue(event.key);\n\n        if (this.keys.has(value))\n        {\n            const key = this.keys.get(value);\n\n            key.up(event);\n        }\n\n        //  Key specific event\n        Emit(this, 'keyup-' + value, event);\n\n        //  Global keyup event\n        Emit(this, 'keyup', event);\n    }\n\n    destroy (): void\n    {\n        window.removeEventListener('keydown', this.keydownHandler);\n        window.removeEventListener('keyup', this.keyupHandler);\n        window.removeEventListener('blur', this.blurHandler);\n\n        Emit(this, 'destroy');\n    }\n}\n", "import { BoundsComponent } from './BoundsComponent';\nimport { GameObjectWorld } from '../../GameObjectWorld';\nimport { hasComponent } from 'bitecs';\n\nexport function BoundsIntersects (id: number, x: number, y: number, right: number, bottom: number): boolean\n{\n    if (hasComponent(GameObjectWorld, BoundsComponent, id))\n    {\n        const [ bx, by, br, bb ] = BoundsComponent.global[id];\n\n        return !(right < bx || bottom < by || x > br || y > bb);\n    }\n\n    //  No bounds component? Always return true then\n    return true;\n}\n", "import { QuadVertexComponent } from './QuadVertexComponent';\n\nexport function SetQuadColor (id: number, red: number, green: number, blue: number, alpha: number): void\n{\n    const data = QuadVertexComponent.values[id];\n\n    data[5] = red;\n    data[6] = green;\n    data[7] = blue;\n    data[8] = alpha;\n\n    data[14] = red;\n    data[15] = green;\n    data[16] = blue;\n    data[17] = alpha;\n\n    data[23] = red;\n    data[24] = green;\n    data[25] = blue;\n    data[26] = alpha;\n\n    data[32] = red;\n    data[33] = green;\n    data[34] = blue;\n    data[35] = alpha;\n\n    data[41] = red;\n    data[42] = green;\n    data[43] = blue;\n    data[44] = alpha;\n\n    data[50] = red;\n    data[51] = green;\n    data[52] = blue;\n    data[53] = alpha;\n}\n", "import { IWorld, Query, defineSystem } from 'bitecs';\n\nimport { ClearDirtyColor } from '../dirty/ClearDirtyColor';\nimport { ColorComponent } from './ColorComponent';\nimport { HasDirtyColor } from '../dirty/HasDirtyColor';\nimport { SetQuadColor } from '../vertices/SetQuadColor';\n\nlet entities: number[];\nlet total: number = 0;\n\nconst system = defineSystem(world =>\n{\n    for (let i = 0; i < entities.length; i++)\n    {\n        const id = entities[i];\n\n        if (HasDirtyColor(id))\n        {\n            const r = ColorComponent.r[id] / 255;\n            const g = ColorComponent.g[id] / 255;\n            const b = ColorComponent.b[id] / 255;\n            const a = ColorComponent.a[id];\n\n            SetQuadColor(id, r, g, b, a);\n\n            total++;\n\n            ClearDirtyColor(id);\n        }\n    }\n\n    return world;\n});\n\nexport const UpdateQuadColorSystem = (id: number, world: IWorld, query: Query): number =>\n{\n    total = 0;\n    entities = query(world);\n\n    if (entities.length > 0)\n    {\n        system(world);\n    }\n\n    return total;\n};\n", "import { HierarchyComponent } from './HierarchyComponent';\n\nexport function SetWorldID (id: number, worldID: number): void\n{\n    HierarchyComponent.world[id] = worldID;\n}\n", "import { GetNumChildren } from '../hierarchy/GetNumChildren';\nimport { HasDirtyChildCache } from '../dirty/HasDirtyChildCache';\nimport { PermissionsComponent } from './PermissionsComponent';\nimport { WillCacheChildren } from './WillCacheChildren';\n\nexport function HasRenderableChildren (id: number): boolean\n{\n    if (PermissionsComponent.visibleChildren[id] === 0 || PermissionsComponent.willRenderChildren[id] === 0 || GetNumChildren(id) === 0)\n    {\n        return false;\n    }\n\n    //  By this stage we know it has some children\n\n    //  A Container won't cache children\n    //  A RenderLayer will cache children, but check if any are dirty or not\n    if (!WillCacheChildren(id) || (WillCacheChildren(id) && HasDirtyChildCache(id)))\n    {\n        return true;\n    }\n\n    return false;\n}\n", "import { PermissionsComponent } from './PermissionsComponent';\n\nexport function WillRenderChildren (id: number): boolean\n{\n    return Boolean(PermissionsComponent.visibleChildren[id]) && Boolean(PermissionsComponent.willRenderChildren[id]);\n}\n", "import { PermissionsComponent } from './PermissionsComponent';\n\nexport function WillUpdate (id: number): boolean\n{\n    return Boolean(PermissionsComponent.willUpdate[id]);\n}\n", "import { PermissionsComponent } from './PermissionsComponent';\n\nexport function WillUpdateChildren (id: number): boolean\n{\n    return Boolean(PermissionsComponent.willUpdateChildren[id]);\n}\n", "import { Transform2DComponent } from './Transform2DComponent';\n\nexport function CopyLocalToWorld (source: number, target: number): void\n{\n    Transform2DComponent.world[target].set(Transform2DComponent.local[source]);\n}\n", "import { Transform2DComponent } from './Transform2DComponent';\n\nexport function CopyWorldToWorld (source: number, target: number): void\n{\n    Transform2DComponent.world[target].set(Transform2DComponent.world[source]);\n}\n", "import { SetDirtyTransform } from '../dirty';\nimport { Transform2DComponent } from './Transform2DComponent';\n\nexport function MultiplyLocalWithWorld (parentID: number, childID: number): void\n{\n    const world = Transform2DComponent.world[childID];\n    const local = Transform2DComponent.local[childID];\n\n    const [ pa, pb, pc, pd, ptx, pty ] = Transform2DComponent.world[parentID];\n    const [ a, b, c, d, tx, ty ] = local;\n\n    world[0] = a * pa + b * pc;\n    world[1] = a * pb + b * pd;\n    world[2] = c * pa + d * pc;\n    world[3] = c * pb + d * pd;\n    world[4] = tx * pa + ty * pc + ptx;\n    world[5] = tx * pb + ty * pd + pty;\n\n    SetDirtyTransform(childID);\n}\n", "import { CopyLocalToWorld } from './CopyLocalToWorld';\nimport { CopyWorldToWorld } from './CopyWorldToWorld';\nimport { GameObjectWorld } from '../../GameObjectWorld';\nimport { GetParentID } from '../hierarchy/GetParentID';\nimport { MultiplyLocalWithWorld } from './MultiplyLocalWithWorld';\nimport { Transform2DComponent } from './Transform2DComponent';\nimport { WillTransformChildren } from '../permissions/WillTransformChildren';\nimport { hasComponent } from 'bitecs';\n\nexport function UpdateWorldTransform (id: number): void\n{\n    const parentID = GetParentID(id);\n\n    if (!hasComponent(GameObjectWorld, Transform2DComponent, parentID))\n    {\n        CopyLocalToWorld(id, id);\n    }\n    else if (!WillTransformChildren(id))\n    {\n        CopyWorldToWorld(parentID, id);\n    }\n    else\n    {\n        MultiplyLocalWithWorld(parentID, id);\n    }\n}\n", "import { Types, defineComponent } from 'bitecs';\n\nconst RenderData = defineComponent({\n    gameFrame: Types.ui32,\n    dirtyLocal: Types.ui32,\n    dirtyVertices: Types.ui32,\n    numChildren: Types.ui32,\n    numRendered: Types.ui32,\n    numRenderable: Types.ui32,\n    rebuiltList: Types.ui8,\n    rebuiltWorld: Types.ui8\n});\n\nexport const RenderDataComponent = RenderData;\n", "import { IWorld, Query, defineSystem } from 'bitecs';\n\nimport { GetParentID } from '../hierarchy/GetParentID';\nimport { HasDirtyTransform } from '../dirty/HasDirtyTransform';\nimport { SetDirtyParents } from '../dirty/SetDirtyParents';\nimport { Transform2DComponent } from './Transform2DComponent';\n\nlet entities: number[];\nlet total: number = 0;\n\nconst system = defineSystem(world =>\n{\n    let prevParent: number = 0;\n\n    for (let i = 0; i < entities.length; i++)\n    {\n        const id = entities[i];\n\n        if (!HasDirtyTransform(id))\n        {\n            continue;\n        }\n\n        const x = Transform2DComponent.x[id];\n        const y = Transform2DComponent.y[id];\n        const rotation = Transform2DComponent.rotation[id];\n        const scaleX = Transform2DComponent.scaleX[id];\n        const scaleY = Transform2DComponent.scaleY[id];\n        const skewX = Transform2DComponent.skewX[id];\n        const skewY = Transform2DComponent.skewY[id];\n\n        const local = Transform2DComponent.local[id];\n\n        local[0] = Math.cos(rotation + skewY) * scaleX;\n        local[1] = Math.sin(rotation + skewY) * scaleX;\n        local[2] = -Math.sin(rotation - skewX) * scaleY;\n        local[3] = Math.cos(rotation - skewX) * scaleY;\n        local[4] = x;\n        local[5] = y;\n\n        const parentID = GetParentID(id);\n\n        if (parentID !== prevParent)\n        {\n            SetDirtyParents(id);\n\n            prevParent = parentID;\n        }\n\n        total++;\n    }\n\n    return world;\n});\n\n//  All children of a World that have a dirty Transform2DComponent\n//  are passed through this system and have their LocalMatrix2DComponent values set +\n//  SetDirtyTransform + SetDirtyParents (which includes SetDirtyDisplayList for the World)\n\nexport const UpdateLocalTransform = (id: number, world: IWorld, query: Query): number =>\n{\n    total = 0;\n    entities = query(world);\n\n    if (entities.length > 0)\n    {\n        system(world);\n    }\n\n    return total;\n};\n", "import { IWorld, Query, defineSystem } from 'bitecs';\n\nimport { BoundsComponent } from '../bounds/BoundsComponent';\nimport { ClearDirtyTransform } from '../dirty/ClearDirtyTransform';\nimport { Extent2DComponent } from '../transform/Extent2DComponent';\nimport { HasDirtyTransform } from '../dirty/HasDirtyTransform';\nimport { RenderDataComponent } from '../../world/RenderDataComponent';\nimport { SetQuadPosition } from './SetQuadPosition';\nimport { Transform2DComponent } from '../transform/Transform2DComponent';\n\nlet entities: number[];\nlet total: number = 0;\n\nconst updateVertexPositionSystem = defineSystem(world =>\n{\n    for (let i = 0; i < entities.length; i++)\n    {\n        const id = entities[i];\n\n        if (!HasDirtyTransform(id))\n        {\n            continue;\n        }\n\n        const [ a, b, c, d, tx, ty ] = Transform2DComponent.world[id];\n\n        const x = Extent2DComponent.x[id];\n        const y = Extent2DComponent.y[id];\n        const right = Extent2DComponent.right[id];\n        const bottom = Extent2DComponent.bottom[id];\n\n        const x0 = (x * a) + (y * c) + tx;\n        const y0 = (x * b) + (y * d) + ty;\n\n        const x1 = (x * a) + (bottom * c) + tx;\n        const y1 = (x * b) + (bottom * d) + ty;\n\n        const x2 = (right * a) + (bottom * c) + tx;\n        const y2 = (right * b) + (bottom * d) + ty;\n\n        const x3 = (right * a) + (y * c) + tx;\n        const y3 = (right * b) + (y * d) + ty;\n\n        SetQuadPosition(id, x0, y0, x1, y1, x2, y2, x3, y3);\n\n        //  x, y, right, bottom:\n        const bx = Math.min(x0, x1, x2, x3);\n        const by = Math.min(y0, y1, y2, y3);\n        const br = Math.max(x0, x1, x2, x3);\n        const bb = Math.max(y0, y1, y2, y3);\n\n        const bounds = BoundsComponent.global[id];\n\n        bounds[0] = bx;\n        bounds[1] = by;\n        bounds[2] = br;\n        bounds[3] = bb;\n\n        ClearDirtyTransform(id);\n\n        total++;\n    }\n\n    return world;\n});\n\n//  Update all vertices and bounds across the World.\n//  This updates the QuadVertexComponent and BoundsComponent (per Game Object)\n\n//  This will only update entities that had their WorldTransform changed this frame.\n\n//  We cannot control the order of these entities, children may be updated before parents, etc.\n\nexport const UpdateVertexPositionSystem = (id: number, world: IWorld, query: Query): void =>\n{\n    total = 0;\n    entities = query(world);\n\n    if (entities.length > 0)\n    {\n        updateVertexPositionSystem(world);\n    }\n\n    ClearDirtyTransform(id);\n\n    RenderDataComponent.dirtyVertices[id] = total;\n};\n", "import { IBaseWorld } from '../IBaseWorld';\n\nexport const WorldAfterUpdateEvent: string = 'afterupdate';\n\nexport type WorldAfterUpdateEventHandler = <T extends IBaseWorld> (delta: number, time: number, world: T) => void;\n", "import { IBaseWorld } from '../IBaseWorld';\n\nexport const WorldBeforeUpdateEvent: string = 'beforeupdate';\n\nexport type WorldBeforeUpdateEventHandler = <T extends IBaseWorld> (delta: number, time: number, world: T) => void;\n", "import { IBaseWorld } from '../IBaseWorld';\nimport { IRenderPass } from '../../renderer/webgl1/renderpass/IRenderPass';\n\nexport const WorldPostRenderEvent: string = 'worldpostrender';\n\nexport type WorldPostRenderEventHandler = (renderPass: IRenderPass, world: IBaseWorld) => void;\n", "import { IBaseWorld } from '../IBaseWorld';\nimport { IWorldRenderData } from '../IWorldRenderData';\n\nexport const WorldRenderEvent: string = 'worldrender';\n\nexport type WorldRenderEventHandler = (renderData: IWorldRenderData, world: IBaseWorld) => void;\n", "import { IBaseWorld } from '../IBaseWorld';\n\nexport const WorldShutdownEvent: string = 'worldshutdown';\n\nexport type WorldShutdownEventHandler = (world: IBaseWorld) => void;\n", "import { IBaseWorld } from '../IBaseWorld';\n\nexport const WorldUpdateEvent: string = 'update';\n\nexport type WorldUpdateEventHandler = <T extends IBaseWorld> (delta: number, time: number, world: T) => void;\n", "import { GameObjectWorld } from '../GameObjectWorld';\nimport { RenderDataComponent } from './RenderDataComponent';\nimport { addComponent } from 'bitecs';\n\nexport function AddRenderDataComponent (id: number): void\n{\n    addComponent(GameObjectWorld, RenderDataComponent, id);\n}\n", "export const SceneDestroyEvent: string = 'destroy';\n\nexport type SceneDestroyEventHandler = () => void;\n", "import * as WorldEvents from './events';\n\nimport { Query, defineComponent, defineQuery } from 'bitecs';\n\nimport { AddRenderDataComponent } from './AddRenderDataComponent';\nimport { Color } from '../components/color/Color';\nimport { Emit } from '../events/Emit';\nimport { GameObject } from '../gameobjects/GameObject';\nimport { GameObjectWorld } from '../GameObjectWorld';\nimport { GetWorldSize } from '../config/worldsize/GetWorldSize';\nimport { HasDirtyDisplayList } from '../components/dirty/HasDirtyDisplayList';\nimport { IBaseCamera } from '../camera/IBaseCamera';\nimport { IBaseWorld } from './IBaseWorld';\nimport { IGameObject } from '../gameobjects/IGameObject';\nimport { IRenderPass } from '../renderer/webgl1/renderpass/IRenderPass';\nimport { IScene } from '../scenes/IScene';\nimport { Once } from '../events/Once';\nimport { RemoveChildren } from '../display/RemoveChildren';\nimport { SceneDestroyEvent } from '../scenes/events/SceneDestroyEvent';\nimport { SetWorldID } from '../components/hierarchy/SetWorldID';\nimport { WillUpdate } from '../components/permissions/WillUpdate';\nimport { WorldList } from './WorldList';\n\nexport class BaseWorld extends GameObject implements IBaseWorld\n{\n    readonly type: string = 'BaseWorld';\n\n    tag = defineComponent();\n\n    scene: IScene;\n\n    camera: IBaseCamera;\n\n    is3D: boolean = false;\n\n    color: Color;\n\n    renderList: Uint32Array;\n    listLength: number = 0;\n\n    private totalChildren: number = 0;\n\n    private totalChildrenQuery: Query;\n\n    constructor (scene: IScene)\n    {\n        super();\n\n        const id = this.id;\n        const tag = this.tag;\n\n        this.scene = scene;\n\n        this.totalChildrenQuery = defineQuery([ tag ]);\n\n        //  * 4 because each Game Object ID is added twice (render and post render) + each has the render type flag\n        // this.renderList = new Uint32Array(GetWorldSize() * 4);\n\n        AddRenderDataComponent(id);\n\n        SetWorldID(id, id);\n\n        WorldList.get(scene).push(this);\n\n        this.color = new Color(id);\n\n        Once(scene, SceneDestroyEvent, () => this.destroy());\n    }\n\n    getNumChildren (): number\n    {\n        if (HasDirtyDisplayList(this.id))\n        {\n            this.totalChildren = this.totalChildrenQuery(GameObjectWorld).length;\n        }\n\n        return this.totalChildren;\n    }\n\n    beforeUpdate (delta: number, time: number): void\n    {\n        Emit(this, WorldEvents.WorldBeforeUpdateEvent, delta, time, this);\n    }\n\n    update (delta: number, time: number): void\n    {\n        if (!WillUpdate(this.id))\n        {\n            return;\n        }\n\n        Emit(this, WorldEvents.WorldUpdateEvent, delta, time, this);\n\n        super.update(delta, time);\n    }\n\n    afterUpdate (delta: number, time: number): void\n    {\n        Emit(this, WorldEvents.WorldAfterUpdateEvent, delta, time, this);\n    }\n\n    preRender (gameFrame: number): boolean\n    {\n        return true;\n    }\n\n    renderGL <T extends IRenderPass> (renderPass: T): void\n    {\n    }\n\n    shutdown (): void\n    {\n        RemoveChildren(this);\n\n        Emit(this, WorldEvents.WorldShutdownEvent, this);\n    }\n\n    destroy (reparentChildren?: IGameObject): void\n    {\n        super.destroy(reparentChildren);\n\n        this.shutdown();\n\n        if (this.camera)\n        {\n            this.camera.destroy();\n        }\n\n        this.camera = null;\n    }\n}\n", "import { Flush } from './Flush';\nimport { IBaseCamera } from '../../../camera/IBaseCamera';\nimport { IRenderPass } from './IRenderPass';\n\nexport function SetCamera (renderPass: IRenderPass, camera: IBaseCamera): void\n{\n    if (renderPass.current2DCamera !== camera)\n    {\n        Flush(renderPass);\n\n        renderPass.current2DCamera = camera;\n        renderPass.cameraMatrix = camera.getMatrix();\n    }\n\n    if (camera.update())\n    {\n        renderPass.getCurrentShader().bind(renderPass);\n    }\n}\n", "import { IBaseCamera } from '../../../camera/IBaseCamera';\nimport { IRenderPass } from './IRenderPass';\nimport { SetCamera } from './SetCamera';\n\n//  Call at the start of each World rendering\n\nexport function Begin (renderPass: IRenderPass, camera: IBaseCamera): void\n{\n    renderPass.shader.bindDefault();\n\n    SetCamera(renderPass, camera);\n}\n", "import { GetFirstChildID } from './GetFirstChildID';\nimport { GetNextSiblingID } from './GetNextSiblingID';\nimport { GetParentID } from './GetParentID';\nimport { GetWorldID } from './GetWorldID';\nimport { WillRenderChildren } from '../permissions/WillRenderChildren';\n\nexport function MoveNextRenderable (id: number): number\n{\n    //  Does 'id' have any children of its own?\n    const firstChild = GetFirstChildID(id);\n\n    if (firstChild > 0 && WillRenderChildren(id))\n    {\n        return firstChild;\n    }\n    else\n    {\n        const sibling = GetNextSiblingID(id);\n\n        if (sibling === 0)\n        {\n            //  No more children, how about from the parent?\n            const parent = GetParentID(id);\n\n            if (parent === GetWorldID(id))\n            {\n                //  We're at the end of the list\n                return 0;\n            }\n            else\n            {\n                return GetNextSiblingID(parent);\n            }\n        }\n        else\n        {\n            return sibling;\n        }\n    }\n}\n", "import { GetFirstChildID } from './GetFirstChildID';\nimport { GetNextSiblingID } from './GetNextSiblingID';\nimport { GetParentID } from './GetParentID';\nimport { GetWorldID } from './GetWorldID';\nimport { WillUpdateChildren } from '../permissions/WillUpdateChildren';\n\nexport function MoveNextUpdatable (id: number): number\n{\n    //  Does 'id' have any children of its own?\n    const firstChild = GetFirstChildID(id);\n\n    if (firstChild > 0 && WillUpdateChildren(id))\n    {\n        return firstChild;\n    }\n    else\n    {\n        const sibling = GetNextSiblingID(id);\n\n        if (sibling === 0)\n        {\n            //  No more children, how about from the parent?\n            const parent = GetParentID(id);\n\n            if (parent === GetWorldID(id))\n            {\n                //  We're at the end of the list\n                return 0;\n            }\n            else\n            {\n                return GetNextSiblingID(parent);\n            }\n        }\n        else\n        {\n            return sibling;\n        }\n    }\n}\n", "import { GameObjectTree } from '../gameobjects/GameObjectTree';\nimport { GameObjectWorld } from '../GameObjectWorld';\nimport { GetFirstChildID } from '../components/hierarchy/GetFirstChildID';\nimport { GetNumChildren } from '../components/hierarchy/GetNumChildren';\nimport { HasDirtyTransform } from '../components/dirty/HasDirtyTransform';\nimport { IBaseWorld } from './IBaseWorld';\nimport { MoveNextRenderable } from '../components/hierarchy/MoveNextRenderable';\nimport { Transform2DComponent } from '../components/transform/Transform2DComponent';\nimport { UpdateWorldTransform } from '../components/transform/UpdateWorldTransform';\nimport { WillRender } from '../components/permissions/WillRender';\nimport { WillRenderChildren } from '../components/permissions/WillRenderChildren';\nimport { hasComponent } from 'bitecs';\n\nexport function RebuildWorldTransforms (world: IBaseWorld): void\n{\n    let next = GetFirstChildID(world.id);\n\n    while (next > 0)\n    {\n        if (WillRender(next) && HasDirtyTransform(next))\n        {\n            UpdateWorldTransform(next);\n        }\n\n        next = MoveNextRenderable(next);\n    }\n}\n\n/*\nexport function RebuildWorldTransforms (world: IBaseWorld, parent: number, forceUpdate: boolean): void\n{\n    if (WillRender(parent))\n    {\n        if (!forceUpdate && HasDirtyTransform(parent))\n        {\n            forceUpdate = true;\n        }\n\n        if (forceUpdate && hasComponent(GameObjectWorld, Transform2DComponent, parent))\n        {\n            UpdateWorldTransform(parent);\n        }\n\n        const children = GameObjectTree.get(parent);\n\n        for (let i = 0; i < children.length; i++)\n        {\n            const nodeID = children[i];\n\n            if (WillRender(nodeID))\n            {\n                if (GetNumChildren(nodeID) > 0)\n                {\n                    if (WillRenderChildren(nodeID))\n                    {\n                        RebuildWorldTransforms(world, nodeID, forceUpdate);\n                    }\n                }\n                else if (forceUpdate || HasDirtyTransform(nodeID))\n                {\n                    UpdateWorldTransform(nodeID);\n                }\n            }\n        }\n    }\n}\n*/\n", "import { RenderDataComponent } from './RenderDataComponent';\n\nexport function ResetWorldRenderData (id: number, gameFrame: number): void\n{\n    RenderDataComponent.gameFrame[id] = gameFrame;\n    RenderDataComponent.dirtyLocal[id] = 0;\n    RenderDataComponent.dirtyVertices[id] = 0;\n    RenderDataComponent.numRendered[id] = 0;\n}\n", "import { AddTransform2DComponent, Position, Size, Transform2DComponent } from '../components/transform';\nimport { addEntity, removeComponent, removeEntity } from 'bitecs';\n\nimport { AddBoundsComponent } from '../components/bounds/AddBoundsComponent';\nimport { AddMatrix4Component } from '../math/mat4/AddMatrix4Component';\nimport { BoundsComponent } from '../components/bounds/BoundsComponent';\nimport { GameObjectWorld } from '../GameObjectWorld';\nimport { IStaticCamera } from './IStaticCamera';\nimport { Matrix4Component } from '../math/mat4/Matrix4Component';\n\nexport class WorldCamera implements IStaticCamera\n{\n    readonly id: number = addEntity(GameObjectWorld);\n\n    readonly type: string = 'WorldCamera';\n\n    //  User defined name. Never used internally.\n    name: string = '';\n\n    size: Size;\n    position: Position;\n\n    isDirty: boolean = true;\n\n    constructor (width: number, height: number)\n    {\n        const id = this.id;\n\n        AddTransform2DComponent(id, 0, 0, 0, 0);\n        AddMatrix4Component(id);\n        AddBoundsComponent(id);\n\n        this.position = new Position(id, 0, 0);\n        this.size = new Size(id, width, height);\n\n        this.reset(width, height);\n    }\n\n    set x (value: number)\n    {\n        this.position.x = value;\n        this.isDirty = true;\n    }\n\n    get x (): number\n    {\n        return this.position.x;\n    }\n\n    set y (value: number)\n    {\n        this.position.y = value;\n        this.isDirty = true;\n    }\n\n    get y (): number\n    {\n        return this.position.y;\n    }\n\n    setPosition (x: number, y?: number): this\n    {\n        this.position.set(x, y);\n        this.isDirty = true;\n\n        return this;\n    }\n\n    update (): boolean\n    {\n        if (this.isDirty)\n        {\n            const bounds = this.getBounds();\n            const matrix = this.getMatrix();\n\n            const x = this.x;\n            const y = this.y;\n\n            const w = this.size.width;\n            const h = this.size.height;\n\n            const ox = -x + (w / 2);\n            const oy = -y + (h / 2);\n\n            matrix[12] = x;\n            matrix[13] = y;\n\n            bounds[0] = ox - (w / 2);\n            bounds[1] = oy - (h / 2);\n            bounds[2] = bounds[0] + w;\n            bounds[3] = bounds[1] + h;\n\n            this.isDirty = false;\n\n            return true;\n        }\n\n        return false;\n    }\n\n    getBounds (): Float32Array\n    {\n        return BoundsComponent.global[this.id];\n    }\n\n    getMatrix (): Float32Array\n    {\n        return Matrix4Component.data[this.id];\n    }\n\n    reset (width: number, height: number): void\n    {\n        this.size.set(width, height);\n\n        this.isDirty = true;\n    }\n\n    destroy (): void\n    {\n        const id = this.id;\n\n        removeComponent(GameObjectWorld, Transform2DComponent, id);\n        removeComponent(GameObjectWorld, Matrix4Component, id);\n        removeComponent(GameObjectWorld, BoundsComponent, id);\n\n        removeEntity(GameObjectWorld, id);\n    }\n}\n", "import * as WorldEvents from './events';\n\nimport { HasRenderableChildren, WillUpdate } from '../components/permissions';\nimport { Query, defineQuery } from 'bitecs';\n\nimport { BaseWorld } from './BaseWorld';\nimport { Begin } from '../renderer/webgl1/renderpass/Begin';\nimport { BoundsIntersects } from '../components/bounds/BoundsIntersects';\nimport { ClearDirtyChild } from '../components/dirty/ClearDirtyChild';\nimport { ClearDirtyDisplayList } from '../components/dirty/ClearDirtyDisplayList';\nimport { ColorComponent } from '../components/color/ColorComponent';\nimport { Emit } from '../events/Emit';\nimport { GameObjectCache } from '../gameobjects/GameObjectCache';\nimport { GameObjectTree } from '../gameobjects/GameObjectTree';\nimport { GameObjectWorld } from '../GameObjectWorld';\nimport { GetFirstChildID } from '../components/hierarchy/GetFirstChildID';\nimport { GetNextSiblingID } from '../components/hierarchy/GetNextSiblingID';\nimport { GetNumChildren } from '../components/hierarchy/GetNumChildren';\nimport { HasDirtyChild } from '../components/dirty/HasDirtyChild';\nimport { HasDirtyDisplayList } from '../components/dirty/HasDirtyDisplayList';\nimport { IRenderPass } from '../renderer/webgl1/renderpass/IRenderPass';\nimport { IScene } from '../scenes/IScene';\nimport { IStaticCamera } from '../camera/IStaticCamera';\nimport { IStaticWorld } from './IStaticWorld';\nimport { MoveNext } from '../components/hierarchy/MoveNext';\nimport { MoveNextRenderable } from '../components/hierarchy/MoveNextRenderable';\nimport { MoveNextUpdatable } from '../components/hierarchy/MoveNextUpdatable';\nimport { PopColor } from '../renderer/webgl1/renderpass/PopColor';\nimport { QuadVertexComponent } from '../components/vertices';\nimport { RebuildWorldList } from './RebuildWorldList';\nimport { RebuildWorldTransforms } from './RebuildWorldTransforms';\nimport { RenderDataComponent } from './RenderDataComponent';\nimport { RendererInstance } from '../renderer/RendererInstance';\nimport { ResetWorldRenderData } from './ResetWorldRenderData';\nimport { SetColor } from '../renderer/webgl1/renderpass/SetColor';\nimport { StaticCamera } from '../camera/StaticCamera';\nimport { Transform2DComponent } from '../components/transform/Transform2DComponent';\nimport { UpdateLocalTransform } from '../components/transform/UpdateLocalTransform';\nimport { UpdateQuadColorSystem } from '../components/color/UpdateQuadColorSystem';\nimport { UpdateVertexPositionSystem } from '../components/vertices/UpdateVertexPositionSystem';\nimport { WillRender } from '../components/permissions/WillRender';\nimport { WillRenderChildren } from '../components/permissions/WillRenderChildren';\nimport { WorldCamera } from '../camera/WorldCamera';\n\n//  A Static World is designed specifically to have a bounds of a fixed size\n//  and a camera that doesn't move at all (no scrolling, rotation, etc)\n//  Because it has a fixed size, there is no camera culling enabled.\n//  Games that use this kind of world include Pacman, Bejeweled and 2048.\n\nexport class StaticWorld extends BaseWorld implements IStaticWorld\n{\n    readonly type: string = 'StaticWorld';\n\n    declare camera: IStaticCamera;\n\n    private colorQuery: Query;\n    private transformQuery: Query;\n\n    private rendered: number;\n\n    constructor (scene: IScene)\n    {\n        super(scene);\n\n        const tag = this.tag;\n\n        this.colorQuery = defineQuery([ tag, ColorComponent, QuadVertexComponent ]);\n        this.transformQuery = defineQuery([ tag, Transform2DComponent ]);\n\n        const renderer = RendererInstance.get();\n\n        // this.camera = new StaticCamera(renderer.width, renderer.height);\n        this.camera = new WorldCamera(renderer.width, renderer.height);\n    }\n\n    //  We should update the display list and world transforms regardless of\n    //  if this World will render or not (i.e. all children are outside viewport)\n    preRender (gameFrame: number): boolean\n    {\n        const id = this.id;\n\n        ResetWorldRenderData(id, gameFrame);\n\n        RenderDataComponent.rebuiltList[id] = 0;\n        RenderDataComponent.rebuiltWorld[id] = 0;\n\n        ClearDirtyChild(id);\n\n        const totalDirty = UpdateLocalTransform(id, GameObjectWorld, this.transformQuery);\n\n        RenderDataComponent.dirtyLocal[id] = totalDirty;\n\n        const dirtyDisplayList = HasDirtyDisplayList(id);\n\n        if (dirtyDisplayList || totalDirty > 0)\n        {\n            //  TODO - This should only run over the branches that are dirty, not the whole World.\n\n            //  This will update the Transform2DComponent.world values.\n            RebuildWorldTransforms(this);\n            // RebuildWorldTransforms(this, id, false);\n\n            RenderDataComponent.rebuiltWorld[id] = 1;\n\n            this.getNumChildren();\n\n            ClearDirtyDisplayList(id);\n\n            // isDirty = true;\n        }\n\n        UpdateVertexPositionSystem(id, GameObjectWorld, this.transformQuery);\n\n        /*\n        if (dirtyDisplayList)\n        {\n            this.listLength = 0;\n\n            RebuildWorldList(this, id);\n\n            RenderDataComponent.numChildren[id] = this.getNumChildren();\n            RenderDataComponent.numRenderable[id] = this.listLength / 4;\n            RenderDataComponent.rebuiltList[id] = 1;\n\n            ClearDirtyDisplayList(id);\n\n            // isDirty = true;\n        }\n        */\n\n        UpdateQuadColorSystem(id, GameObjectWorld, this.colorQuery);\n\n        //  By this point we've got a fully rebuilt World, where all dirty Game Objects have been\n        //  refreshed and had their coordinates moved to their quad vertices.\n\n        //  We've also got a complete local render list, in display order, that can be processed further\n        //  before rendering (i.e. spatial tree, bounds, etc)\n\n        return true;\n    }\n\n    update (delta: number, time: number): void\n    {\n        this.beforeUpdate(delta, time);\n\n        let next = GetFirstChildID(this.id);\n\n        while (next > 0)\n        {\n            if (WillUpdate(next))\n            {\n                GameObjectCache.get(next).update(delta, time);\n            }\n\n            next = MoveNextUpdatable(next);\n        }\n\n        this.afterUpdate(delta, time);\n    }\n\n    listRender <T extends IRenderPass> (renderPass: T, x: number, y: number, right: number, bottom: number): void\n    {\n        let next = GetFirstChildID(this.id);\n\n        // let parent;\n\n        while (next > 0)\n        {\n            if (WillRender(next))\n            {\n                const intersects = BoundsIntersects(next, x, y, right, bottom);\n\n                let gameObject;\n\n                if (intersects)\n                {\n                    gameObject = GameObjectCache.get(next);\n\n                    this.rendered++;\n\n                    gameObject.renderGL(renderPass);\n                    gameObject.postRenderGL(renderPass);\n                }\n            }\n\n            // next = MoveNext(next);\n            next = MoveNextRenderable(next);\n\n            // else\n            // {\n            //     next = GetNextSiblingID(next);\n            // }\n        }\n    }\n\n    runRender <T extends IRenderPass> (renderPass: T, entry: number, x: number, y: number, right: number, bottom: number): void\n    {\n        if (WillRender(entry))\n        {\n            const intersects = (entry !== this.id) && BoundsIntersects(entry, x, y, right, bottom);\n\n            let gameObject;\n\n            if (intersects)\n            {\n                gameObject = GameObjectCache.get(entry);\n            }\n\n            if (HasRenderableChildren(entry))\n            {\n                if (intersects)\n                {\n                    this.rendered++;\n\n                    gameObject.renderGL(renderPass);\n                }\n\n                const children = GameObjectTree.get(entry);\n\n                for (let i = 0; i < children.length; i++)\n                {\n                    const childID = children[i];\n\n                    if (WillRender(childID))\n                    {\n                        this.runRender(renderPass, childID, x, y, right, bottom);\n                    }\n                }\n\n                if (intersects)\n                {\n                    gameObject.postRenderGL(renderPass);\n                }\n            }\n            else if (intersects)\n            {\n                this.rendered++;\n\n                gameObject.renderGL(renderPass);\n                gameObject.postRenderGL(renderPass);\n            }\n        }\n    }\n\n    renderGL <T extends IRenderPass> (renderPass: T): void\n    {\n        SetColor(renderPass, this.color);\n\n        Emit(this, WorldEvents.WorldRenderEvent, this);\n\n        const camera = this.camera;\n\n        Begin(renderPass, camera);\n\n        const [ x, y, right, bottom ] = camera.getBounds();\n\n        this.rendered = 0;\n\n        this.listRender(renderPass, x, y, right, bottom);\n\n        // this.runRender(renderPass, this.id, x, y, right, bottom);\n\n        // const children = GameObjectTree.get(this.id);\n\n        // const list = this.renderList;\n\n        // let rendered = 0;\n\n        /*\n        for (let i = 0; i < this.listLength; i += 2)\n        {\n            const eid = list[i];\n            const type = list[i + 1];\n            const entry = GameObjectCache.get(eid);\n\n            if (type === 1)\n            {\n                //  We've already rendered this Game Object, so skip bounds checking\n                entry.postRenderGL(renderPass);\n            }\n            else if (BoundsIntersects(eid, x, y, right, bottom))\n            {\n                entry.renderGL(renderPass);\n\n                if (type === 2)\n                {\n                    entry.postRenderGL(renderPass);\n                }\n\n                this.rendered++;\n            }\n        }\n        */\n\n        PopColor(renderPass, this.color);\n\n        const id = this.id;\n\n        //#ifdef RENDER_STATS\n        window['renderStats'] = {\n            gameFrame: RenderDataComponent.gameFrame[id],\n            numChildren: this.getNumChildren(),\n            numRendererd: this.rendered,\n            numRenderable: RenderDataComponent.numRenderable[id],\n            dirtyLocal: RenderDataComponent.dirtyLocal[id],\n            dirtyVertices: RenderDataComponent.dirtyVertices[id],\n            rebuiltList: RenderDataComponent.rebuiltList[id],\n            rebuiltWorld: RenderDataComponent.rebuiltWorld[id]\n        };\n        //#endif\n\n        Emit(this, WorldEvents.WorldPostRenderEvent, renderPass, this);\n    }\n}\n", "import { BackgroundColor, BatchSize, GlobalVar, Parent, Scenes, WebGL } from '../../../../phaser-genesis/src/config';\nimport { DownKey, LeftKey, RightKey, UpKey } from '../../../../phaser-genesis/src/input/keyboard/keys';\n\nimport { AddChild } from '../../../../phaser-genesis/src/display';\nimport { Between } from '../../../../phaser-genesis/src/math';\nimport { DrawImage } from '../../../../phaser-genesis/src/renderer/webgl1/draw';\nimport { Game } from '../../../../phaser-genesis/src/Game';\nimport { GetTexture } from '../../../../phaser-genesis/src/textures';\nimport { ImageFile } from '../../../../phaser-genesis/src/loader/files/ImageFile';\nimport { Keyboard } from '../../../../phaser-genesis/src/input/keyboard';\nimport { On } from '../../../../phaser-genesis/src/events';\nimport { Scene } from '../../../../phaser-genesis/src/scenes/Scene';\nimport { Sprite } from '../../../../phaser-genesis/src/gameobjects';\nimport { StaticWorld } from '../../../../phaser-genesis/src/world/StaticWorld';\nimport { WorldCamera } from '../../../../phaser-genesis/src/camera/WorldCamera';\n\nclass Star extends Sprite\n{\n    speed: number;\n\n    constructor ()\n    {\n        super(Between(-8000, 8000), Between(-8000, 8000), 'snow');\n\n        this.speed = Between(1, 8);\n    }\n\n    update (): void\n    {\n        this.position.x -= this.speed;\n\n        if (this.position.x < -8000)\n        {\n            this.position.x = 8000;\n        }\n    }\n}\n\nclass Demo extends Scene\n{\n    leftKey: LeftKey;\n    rightKey: RightKey;\n    upKey: RightKey;\n    downKey: RightKey;\n\n    camera: WorldCamera;\n\n    cameraSpeed: number = 8;\n\n    constructor ()\n    {\n        super();\n\n        const keyboard = new Keyboard();\n\n        this.leftKey = new LeftKey();\n        this.rightKey = new RightKey();\n        this.upKey = new UpKey();\n        this.downKey = new DownKey();\n\n        keyboard.addKeys(this.leftKey, this.rightKey, this.upKey, this.downKey);\n\n        this.create();\n    }\n\n    async create ()\n    {\n        // await ImageFile('snow', 'assets/snowflake-pixel.png');\n        await ImageFile('snow', 'assets/cybertank-bullet.png');\n\n        const world = new StaticWorld(this);\n        \n        this.camera = world.camera;\n\n        for (let i = 0; i < 100000; i++)\n        {\n            // const star = new Star();\n            // const star = new Sprite(400, 300, 'snow');\n\n            // if (i % 1000 === 0)\n            // {\n            //     console.log(star);\n            // }\n\n            // AddChild(world, star);\n\n            AddChild(world, new Star());\n        }\n    }\n\n    update (): void\n    {\n        if (!this.camera)\n        {\n            return;\n        }\n\n        if (this.leftKey.isDown)\n        {\n            this.camera.x += this.cameraSpeed;\n        }\n        else if (this.rightKey.isDown)\n        {\n            this.camera.x -= this.cameraSpeed;\n        }\n\n        if (this.upKey.isDown)\n        {\n            this.camera.y += this.cameraSpeed;\n        }\n        else if (this.downKey.isDown)\n        {\n            this.camera.y -= this.cameraSpeed;\n        }\n    }\n}\n\nnew Game(\n    WebGL(),\n    BatchSize(4096),\n    Parent('gameParent'),\n    GlobalVar('Phaser4'),\n    BackgroundColor(0x0a0a0a),\n    Scenes(Demo)\n);\n"],
  "mappings": "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",
  "names": []
}
